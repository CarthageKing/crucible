[
    {
        "_id": {
            "$oid": "560f06924d4d3266f8850200"
        },
        "created_at": {
            "$date": "2015-10-02T18:34:58.440-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'CAEP1','Create a Patient then check for AuditEvent' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/auditevent.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create']\n          requires resource: 'AuditEvent', methods: ['search']\n          validates resource: 'Patient', methods: ['create']\n          validates resource: 'AuditEvent', methods: ['search']\n        }\n        @patient = @resources.minimal_patient\n        @patient.xmlId = nil # clear the identifier\n        reply = @client.create(@patient)      \n        assert_response_ok(reply)\n        @patient.xmlId = reply.id\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'reference' => \"Patient/#{@patient.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::AuditEvent, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(1, reply.resource.entry.size, 'There should only be one AuditEvent for the test Patient currently in the system.', reply.body)\n        assert(reply.resource.entry[0].try(:resource).try(:object).try(:reference).include?(@patient.xmlId), 'The correct AuditEvent was not returned.', reply.body)\n        warning { assert_equal('110110', reply.resource.entry[0].try(:resource).try(:event).try(:type).try(:code), 'Was expecting an AuditEvent.event.type.code of 110110 (Patient Record).', reply.body) }\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter reference does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>",
                "description": "Create a Patient then check for AuditEvent",
                "id": "CAEP1",
                "key": "CAEP1",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/patient.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/auditevent.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ],
                "status": "fail",
                "test_method": "caep1_create_a_patient_then_check_for_auditevent_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'CAEP2','Create a Patient then check for Provenance' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/provenance.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create']\n          requires resource: 'Provenance', methods: ['search']\n          validates resource: 'Patient', methods: ['create']\n          validates resource: 'Provenance', methods: ['search']\n        }\n        @patient1 = @resources.minimal_patient\n        @patient1.xmlId = nil # clear the identifier\n        reply = @client.create(@patient1)      \n        assert_response_ok(reply)\n        @patient1.xmlId = reply.id\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'target' => \"Patient/#{@patient1.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::Provenance, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(1, reply.resource.entry.size, 'There should only be one Provenance for the test Patient currently in the system.', reply.body)\n        assert(reply.resource.entry[0].try(:resource).try(:target).try(:reference).include?(@patient1.xmlId), 'The correct Provenance was not returned.', reply.body)\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter target does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>",
                "description": "Create a Patient then check for Provenance",
                "id": "CAEP2",
                "key": "CAEP2",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/patient.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/provenance.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ],
                "status": "fail",
                "test_method": "caep2_create_a_patient_then_check_for_provenance_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'CAEP3','Update a Patient then check for AuditEvent' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/auditevent.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create','update']\n          requires resource: 'AuditEvent', methods: ['search']\n          validates resource: 'Patient', methods: ['update']\n          validates resource: 'AuditEvent', methods: ['search']\n        }\n        @patient.gender = 'male'\n        reply = @client.update(@patient,@patient.xmlId)      \n        assert_response_ok(reply)\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'reference' => \"Patient/#{@patient.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::AuditEvent, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(2, reply.resource.entry.size, 'There should be two AuditEvents for the test Patient currently in the system.', reply.body)\n        reply.resource.entry.each do |entry|\n          assert(entry.try(:resource).try(:object).try(:reference).include?(@patient.xmlId), 'An incorrect AuditEvent was returned.', reply.body)\n          warning { assert_equal('110110', entry.try(:resource).try(:event).try(:type).try(:code), 'Was expecting an AuditEvent.event.type.code of 110110 (Patient Record).', reply.body) }\n        end\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter reference does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>",
                "description": "Update a Patient then check for AuditEvent",
                "id": "CAEP3",
                "key": "CAEP3",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/patient.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/auditevent.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ],
                "status": "fail",
                "test_method": "caep3_update_a_patient_then_check_for_auditevent_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'CAEP4','Update a Patient then check for Provenance' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/provenance.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create','update']\n          requires resource: 'Provenance', methods: ['search']\n          validates resource: 'Patient', methods: ['update']\n          validates resource: 'Provenance', methods: ['search']\n        }\n        @patient1.gender = 'male'\n        reply = @client.update(@patient1,@patient1.xmlId)      \n        assert_response_ok(reply)\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'target' => \"Patient/#{@patient1.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::Provenance, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(2, reply.resource.entry.size, 'There should be two Provenance resources for the test Patient currently in the system.', reply.body)\n        reply.resource.entry.each do |entry|\n          assert(entry.try(:resource).try(:target).try(:reference).include?(@patient1.xmlId), 'An incorrect Provenance was returned.', reply.body)\n        end\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter target does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>",
                "description": "Update a Patient then check for Provenance",
                "id": "CAEP4",
                "key": "CAEP4",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/patient.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/provenance.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ],
                "status": "fail",
                "test_method": "caep4_update_a_patient_then_check_for_provenance_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'CAEP5','Read a Patient and check for AuditEvent' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/auditevent.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create','read']\n          requires resource: 'AuditEvent', methods: ['search']\n          validates resource: 'Patient', methods: ['read']\n          validates resource: 'AuditEvent', methods: ['search']\n        }\n        reply = @client.read(FHIR::Patient,@patient.xmlId)      \n        assert_response_ok(reply)\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'reference' => \"Patient/#{@patient.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::AuditEvent, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(3, reply.resource.entry.size, 'There should be three AuditEvents for the test Patient currently in the system.', reply.body)\n        reply.resource.entry.each do |entry|\n          assert(entry.try(:resource).try(:object).try(:reference).include?(@patient.xmlId), 'An incorrect AuditEvent was returned.', reply.body)\n          warning { assert_equal('110110', entry.try(:resource).try(:event).try(:type).try(:code), 'Was expecting an AuditEvent.event.type.code of 110110 (Patient Record).', reply.body) }\n        end\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter reference does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>",
                "description": "Read a Patient and check for AuditEvent",
                "id": "CAEP5",
                "key": "CAEP5",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/patient.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/auditevent.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ],
                "status": "fail",
                "test_method": "caep5_read_a_patient_and_check_for_auditevent_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0434d4d3261a6000000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:34:58.440-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f06ad4d4d3266f8860200"
        },
        "created_at": {
            "$date": "2015-10-02T18:35:25.379-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'C8T2_1A', 'Fetch all patient records' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['$everything']\n          validates resource: 'Patient', methods: ['$everything']\n        }\n\n        reply = @client.fetch_patient_record\n\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation everything is not supported on the Patient resource\" /></details></issue></OperationOutcome>",
                "description": "Fetch all patient records",
                "id": "C8T2_1A",
                "key": "C8T2_1A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient-operations.html#everything",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "requires": [
                    {
                        "methods": [
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "c8t2_1a_fetch_all_patient_records_test",
                "validates": [
                    {
                        "methods": [
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'C8T2_1B', 'Fetch all patient records with [start, end]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['$everything']\n          validates resource: 'Patient', methods: ['$everything']\n        }\n\n        reply = @client.fetch_patient_record(nil, \"2012-01-01\", \"2012-12-31\")\n\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        skip # TODO: Determine how start/end scope all patient records (e.g., birthdate?)\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation everything is not supported on the Patient resource\" /></details></issue></OperationOutcome>",
                "description": "Fetch all patient records with [start, end]",
                "id": "C8T2_1B",
                "key": "C8T2_1B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient-operations.html#everything",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "requires": [
                    {
                        "methods": [
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "c8t2_1b_fetch_all_patient_records_with_[start,_end]_test",
                "validates": [
                    {
                        "methods": [
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'C8T2_2A', 'Fetch specific patient record' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['create', '$everything']\n          validates resource: 'Patient', methods: ['create', '$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@patient_id)\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        patient = @patient\n        patient.xmlId = @patient_id\n\n        assert patient.equals?(record.resource.entry[0].resource), \"Returned patient doesn't match original patient.\"\n      end\n",
                "description": "Fetch specific patient record",
                "id": "C8T2_2A",
                "key": "C8T2_2A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient-operations.html#everything",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t2_2a_fetch_specific_patient_record_test",
                "validates": [
                    {
                        "methods": [
                            "create",
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'C8T2_2B', 'Fetch specific patient record with [start, end]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['create', '$everything']\n          validates resource: 'Patient', methods: ['create', '$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@patient_id, \"2012-01-01\", \"2012-12-31\")\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        patient = @patient\n        patient.xmlId = @patient_id\n\n        assert patient.equals?(record.resource.entry[0].resource), \"Returned patient doesn't match original patient.\"\n\n        # TODO: Determine how start/end scope specific patient records (e.g., birthdate?)\n      end\n",
                "description": "Fetch specific patient record with [start, end]",
                "id": "C8T2_2B",
                "key": "C8T2_2B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient-operations.html#everything",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t2_2b_fetch_specific_patient_record_with_[start,_end]_test",
                "validates": [
                    {
                        "methods": [
                            "create",
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'C8T2_2C', 'Fetch specific patient record - BONUS: Update' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['create', 'update', '$everything']\n          validates resource: 'Patient', methods: ['create', 'update', '$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@patient_id)\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        @patient.telecom[0].value='1-234-567-8901'\n        @patient.name[0].given = [\"Not\", \"Given\"]\n\n        reply = @client.update @patient, @patient_id\n\n        assert_response_ok(reply)\n\n        record = @client.fetch_patient_record(@patient_id)\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n        assert record.resource.entry[0].resource.telecom[0].value == '1-234-567-8901'\n        assert record.resource.entry[0].resource.name[0].given == ['Not', 'Given']\n      end\n",
                "description": "Fetch specific patient record - BONUS: Update",
                "id": "C8T2_2C",
                "key": "C8T2_2C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient-operations.html#everything",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t2_2c_fetch_specific_patient_record_-_bonus:_update_test",
                "validates": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'C8T2_3_A', 'Fetch an entire patient record - exact' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links \"#{BASE_SPEC_LINK}/argonauts.html\"\n          requires resource: 'Organization', methods: ['create']\n          requires resource: 'Practitioner', methods: ['create']\n          requires resource: 'Patient', methods: ['create']\n          requires resource: 'Condition', methods: ['create']\n          requires resource: 'Observation', methods: ['create']\n          requires resource: 'DiagnosticReport', methods: ['create']\n          requires resource: 'Encounter', methods: ['create']\n          requires resource: 'Procedure', methods: ['create']\n          validates resource: 'Patient', methods: ['create', '$everything']\n          validates resource: 'Organization', methods: ['create']\n          validates resource: 'Practitioner', methods: ['create']\n          validates resource: 'Patient', methods: ['create']\n          validates resource: 'Condition', methods: ['create']\n          validates resource: 'Observation', methods: ['create']\n          validates resource: 'DiagnosticReport', methods: ['create']\n          validates resource: 'Encounter', methods: ['create']\n          validates resource: 'Procedure', methods: ['create']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@pat_reply.id)\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        mismatches = []\n        record.resource.entry.each do |bundle_entry|\n          case bundle_entry.resource.class\n          when FHIR::Organization\n            case bundle_entry.resource.xmlId\n            when @org1_id\n              mismatches << bundle_entry.resource.mismatch(@organization_1) unless bundle_entry.resource.equals?(@organization_1)\n            when @org2_id\n              mismatches << bundle_entry.resource.mismatch(@organization_2) unless bundle_entry.resource.equals?(@organization_2)\n            end\n          when FHIR::Practitioner\n            mismatches << bundle_entry.resource.mismatch(@practitioner) unless bundle_entry.resource.equals?(@practitioner)\n          when FHIR::Patient\n            mismatches << bundle_entry.resource.mismatch(@patient) unless bundle_entry.resource.equals?(@patient)\n          when FHIR::Condition\n            case bundle_entry.resource.xmlId\n            when @cond1_id\n              mismatches << bundle_entry.resource.mismatch(@condition_1) unless bundle_entry.resource.equals?(@condition_1)\n            when @cond2_id\n              mismatches << bundle_entry.resource.mismatch(@condition_2) unless bundle_entry.resource.equals?(@condition_2)\n            end\n          when FHIR::Observation\n            mismatches << bundle_entry.resource.mismatch(@observation) unless bundle_entry.resource.equals?(@observation)\n          when FHIR::DiagnosticReport\n            mismatches << bundle_entry.resource.mismatch(@diagnosticreport) unless bundle_entry.resource.equals?(@diagnosticreport)\n          when FHIR::Encounter\n            case bundle_entry.resource.xmlId\n            when @enc1_id\n              mismatches << bundle_entry.resource.mismatch(@encounter_1) unless bundle_entry.resource.equals?(@encounter_1)\n            when @enc2_id\n              mismatches << bundle_entry.resource.mismatch(@encounter_2) unless bundle_entry.resource.equals?(@encounter_2)\n            end\n          when FHIR::Procedure\n            mismatches << bundle_entry.resource.mismatch(@procedure) unless bundle_entry.resource.equals?(@procedure)\n          end\n        end\n\n        assert mismatches.flatten.empty?, \"Data returned from the server did not match source data: #{mismatches.flatten}\"\n      end\n",
                "data": null,
                "description": "Fetch an entire patient record - exact",
                "id": "C8T2_3_A",
                "key": "C8T2_3_A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient-operations.html#everything",
                    "http://hl7.org/fhir/DSTU2/argonauts.html"
                ],
                "message": "Data returned from the server did not match source data: [\"FHIR::Patient::meta\", \"FHIR::Observation::meta\", \"FHIR::Encounter::meta\", \"FHIR::Encounter::meta\", \"FHIR::Condition::text\", \"FHIR::Narrative::div\", \"FHIR::Condition::meta\", \"FHIR::Condition::text\", \"FHIR::Narrative::div\", \"FHIR::Condition::meta\", \"FHIR::DiagnosticReport::text\", \"FHIR::Narrative::div\", \"FHIR::DiagnosticReport::meta\", \"FHIR::Procedure::text\", \"FHIR::Narrative::div\", \"FHIR::Procedure::meta\"]",
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Organization"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Practitioner"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Condition"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Observation"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DiagnosticReport"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Encounter"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Procedure"
                    }
                ],
                "status": "fail",
                "test_method": "c8t2_3_a_fetch_an_entire_patient_record_-_exact_test",
                "validates": [
                    {
                        "methods": [
                            "create",
                            "$everything"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Organization"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Practitioner"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Condition"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Observation"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DiagnosticReport"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Encounter"
                    },
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'C8T2_3_B', 'Fetch an entire patient record - ignore meta & text' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links \"#{BASE_SPEC_LINK}/argonauts.html\"\n          validates resource: 'Patient', methods: ['$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@pat_reply.id)\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        mismatches = []\n        record.resource.entry.each do |bundle_entry|\n          case bundle_entry.resource.class\n          when FHIR::Organization\n            case bundle_entry.resource.xmlId\n            when @org1_id\n              mismatches << bundle_entry.resource.mismatch(@organization_1, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@organization_1)\n            when @org2_id\n              mismatches << bundle_entry.resource.mismatch(@organization_2, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@organization_2)\n            end\n          when FHIR::Practitioner\n            mismatches << bundle_entry.resource.mismatch(@practitioner, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@practitioner)\n          when FHIR::Patient\n            mismatches << bundle_entry.resource.mismatch(@patient, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@patient)\n          when FHIR::Condition\n            case bundle_entry.resource.xmlId\n            when @cond1_id\n              mismatches << bundle_entry.resource.mismatch(@condition_1, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@condition_1)\n            when @cond2_id\n              mismatches << bundle_entry.resource.mismatch(@condition_2, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@condition_2)\n            end\n          when FHIR::Observation\n            mismatches << bundle_entry.resource.mismatch(@observation, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@observation)\n          when FHIR::DiagnosticReport\n            mismatches << bundle_entry.resource.mismatch(@diagnosticreport, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@diagnosticreport)\n          when FHIR::Encounter\n            case bundle_entry.resource.xmlId\n            when @enc1_id\n              mismatches << bundle_entry.resource.mismatch(@encounter_1, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@encounter_1)\n            when @enc2_id\n              mismatches << bundle_entry.resource.mismatch(@encounter_2, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@encounter_2)\n            end\n          when FHIR::Procedure\n            mismatches << bundle_entry.resource.mismatch(@procedure, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@procedure)\n          end\n        end\n\n        assert mismatches.flatten.empty?, \"Data returned from the server did not match source data: #{mismatches.flatten}\"\n      end\n",
                "description": "Fetch an entire patient record - ignore meta & text",
                "id": "C8T2_3_B",
                "key": "C8T2_3_B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient-operations.html#everything",
                    "http://hl7.org/fhir/DSTU2/argonauts.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "c8t2_3_b_fetch_an_entire_patient_record_-_ignore_meta_&_text_test",
                "validates": [
                    {
                        "methods": [
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'C8T2_3_C', 'Fetch an entire patient record - count' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links \"#{BASE_SPEC_LINK}/argonauts.html\"\n          validates resource: 'Patient', methods: ['$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@pat_reply.id)\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        record.resource.entry.each do |bundle_entry|\n          if @ids_count.keys.include?(bundle_entry.resource.class.to_s)\n            @ids_count[bundle_entry.resource.class.to_s].delete bundle_entry.resource.xmlId\n          else\n            warning { assert @ids_count.keys.include?(bundle_entry.resource.class.to_s),\n              \"Found additional resource(s) in $everything Bundle: #{bundle_entry.resource.class}#{ \"-#{bundle_entry.resource.code.text}\" if bundle_entry.resource.class == FHIR::List}\" }\n          end\n        end\n\n        @ids_count.each {|klass,ids| @ids_count.delete(klass) if ids.blank?}\n        assert @ids_count.flatten.empty?, \"Returned Bundle is missing resources: #{@ids_count}\"\n      end\n",
                "data": null,
                "description": "Fetch an entire patient record - count",
                "id": "C8T2_3_C",
                "key": "C8T2_3_C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient-operations.html#everything",
                    "http://hl7.org/fhir/DSTU2/argonauts.html"
                ],
                "message": "Returned Bundle is missing resources: {\"FHIR::Organization\"=>[\"bd274af642254a019681b4b4e338d0cf\", \"5cc2d404428244cca63310f6488dac7a\"], \"FHIR::Practitioner\"=>[\"4090bd6b52b441f39377af5f9abfe177\"]}",
                "status": "fail",
                "test_method": "c8t2_3_c_fetch_an_entire_patient_record_-_count_test",
                "validates": [
                    {
                        "methods": [
                            "$everything"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0434d4d3261a6010000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:35:25.379-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f06c84d4d3266f88b0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:35:52.208-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'C9F_1A','Register a simple claim' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/claim.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'Claim', methods: ['create']\n          validates resource: 'Claim', methods: ['create']\n        }\n\n        reply = @client.create(@simple)\n        assert_response_ok(reply)\n        @simple_id = reply.id\n        sleep(10) # sleep to allow server to process claim, no wait time was causing incorrect failures in subsequent tests\n\n        if !reply.resource.nil?\n          # Response is Claim\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @simple.equals?(reply.resource), 'The server did not correctly preserve the Claim data.' }\n          reply.resource.xmlId = temp\n        elsif !reply.body.nil?\n          begin\n            cr = FHIR::Resource.from_contents(reply.body)\n            if cr.class==FHIR::ClaimResponse\n              # Response is ClaimResponse\n              @simple_response_id = cr.xmlId\n              @simple_id = cr.request.reference if cr.request\n            else\n              warning { assert(false,\"The Claim request responded with an unexpected resource: #{cr.class}\",reply.body) }\n            end\n          rescue Exception => ex\n            warning { assert(false,'The Claim request responded with an unexpected body.',reply.body) }\n          end\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Register a simple claim",
                "id": "C9F_1A",
                "key": "C9F_1A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/claim.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Claim"
                    }
                ],
                "status": "pass",
                "test_method": "c9f_1a_register_a_simple_claim_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'C9F_1B','Register an average claim' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/claim.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'Claim', methods: ['create']\n          validates resource: 'Claim', methods: ['create']\n        }\n\n        reply = @client.create(@average)\n        assert_response_ok(reply)\n        @average_id = reply.id\n        sleep(10) # sleep to allow server to process claim, no wait time was causing incorrect failures in subsequent tests\n\n        if !reply.resource.nil?\n          # Response is Claim\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @average.equals?(reply.resource), 'The server did not correctly preserve the Claim data.' }\n          reply.resource.xmlId = temp\n        elsif !reply.body.nil?\n          begin\n            cr = FHIR::Resource.from_contents(reply.body)\n            if cr.class==FHIR::ClaimResponse\n              # Response is ClaimResponse\n              @average_response_id = cr.xmlId\n              @average_id = cr.request.reference if cr.request\n            else\n              warning { assert(false,\"The Claim request responded with an unexpected resource: #{cr.class}\",reply.body) }\n            end\n          rescue Exception => ex\n            warning { assert(false,'The Claim request responded with an unexpected body.',reply.body) }\n          end\n        end\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Register an average claim",
                "id": "C9F_1B",
                "key": "C9F_1B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/claim.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Claim"
                    }
                ],
                "status": "pass",
                "test_method": "c9f_1b_register_an_average_claim_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'C9F_1C','Check on simple claim' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/claim.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'Claim', methods: ['read']\n          validates resource: 'Claim', methods: ['read']\n        }\n\n        reply = @client.read(FHIR::Claim,@simple_id)\n        assert_response_ok(reply)\n        assert_resource_type(reply,FHIR::Claim)\n        reply.resource.coverage.each do |coverage|\n          assert(!coverage.try(:claimResponse).try(:reference).nil?,'Claim does not reference a ClaimResponse.',reply.body)\n        end\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "data": "\ufeff<Claim xmlns=\"http://hl7.org/fhir\"><id value=\"7c84273592f543bfbf9ae4641a523a56\" /><meta><versionId value=\"28\" /><lastUpdated value=\"2015-10-02T22:35:26.18+00:00\" /></meta><type value=\"oral\" /><created value=\"2015-04-16\" /><target><reference value=\"Organization/654123\" /></target><organization><reference value=\"Organization/1535\" /></organization><use value=\"complete\" /><priority><code value=\"normal\" /></priority><payee><type><code value=\"provider\" /></type></payee><diagnosis><sequence value=\"1\" /><diagnosis><code value=\"123456\" /></diagnosis></diagnosis><patient><reference value=\"Patient/1\" /></patient><coverage><sequence value=\"1\" /><focal value=\"true\" /><coverage><reference value=\"Coverage/9876B1\" /></coverage><relationship><code value=\"self\" /></relationship></coverage><item><sequence value=\"1\" /><type><code value=\"service\" /></type><provider><reference value=\"Practitioner/1\" /></provider><service><code value=\"1201\" /></service><serviceDate value=\"2015-04-16\" /><unitPrice><value value=\"135.57\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"135.57\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net></item></Claim>",
                "description": "Check on simple claim",
                "id": "C9F_1C",
                "key": "C9F_1C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/claim.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": "Claim does not reference a ClaimResponse.",
                "requires": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Claim"
                    }
                ],
                "status": "fail",
                "test_method": "c9f_1c_check_on_simple_claim_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'C9F_1D','Check on average claim' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/claim.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'Claim', methods: ['read']\n          validates resource: 'Claim', methods: ['read']\n        }\n\n        reply = @client.read(FHIR::Claim,@average_id)\n        assert_response_ok(reply)\n        assert_resource_type(reply,FHIR::Claim)\n        reply.resource.coverage.each do |coverage|\n          assert(!coverage.try(:claimResponse).try(:reference).nil?,'Claim does not reference a ClaimResponse.',reply.body)\n        end\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "data": "\ufeff<Claim xmlns=\"http://hl7.org/fhir\"><id value=\"d2db78a4f58540808b041589448abc34\" /><meta><versionId value=\"29\" /><lastUpdated value=\"2015-10-02T22:35:36.97+00:00\" /></meta><type value=\"oral\" /><created value=\"2014-08-16\" /><target><reference value=\"Organization/2\" /></target><organization><reference value=\"Organization/1\" /></organization><use value=\"complete\" /><priority><code value=\"normal\" /></priority><payee><type><code value=\"provider\" /></type></payee><diagnosis><sequence value=\"1\" /><diagnosis><code value=\"123456\" /></diagnosis></diagnosis><patient><reference value=\"Patient/1\" /></patient><coverage><sequence value=\"1\" /><focal value=\"true\" /><coverage><reference value=\"Coverage/9876B1\" /></coverage><relationship><code value=\"self\" /></relationship></coverage><item><sequence value=\"1\" /><type><code value=\"service\" /></type><provider><reference value=\"Practitioner/1\" /></provider><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"1200\" /></service><serviceDate value=\"2014-08-16\" /><unitPrice><value value=\"135.57\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"135.57\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net></item><item><sequence value=\"2\" /><type><code value=\"service\" /></type><provider><reference value=\"Practitioner/1\" /></provider><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"21211\" /></service><serviceDate value=\"2014-08-16\" /><unitPrice><value value=\"105.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"105.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net><bodySite><system value=\"http://fdi.org/fhir/oraltoothcodes\" /><code value=\"21\" /></bodySite><subSite><system value=\"http://fdi.org/fhir/oralsurfacecodes\" /><code value=\"L\" /></subSite></item><item><sequence value=\"3\" /><type><code value=\"group\" /></type><provider><reference value=\"Practitioner/1\" /></provider><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"27211\" /></service><serviceDate value=\"2014-08-16\" /><unitPrice><value value=\"1100.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"1100.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net><bodySite><system value=\"http://fdi.org/fhir/oraltoothcodes\" /><code value=\"36\" /></bodySite><detail><sequence value=\"1\" /><type><code value=\"service\" /></type><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"27211\" /></service><unitPrice><value value=\"750.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"750.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net></detail><detail><sequence value=\"2\" /><type><code value=\"service\" /></type><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"lab\" /></service><unitPrice><value value=\"350.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"350.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net></detail></item></Claim>",
                "description": "Check on average claim",
                "id": "C9F_1D",
                "key": "C9F_1D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/claim.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": "Claim does not reference a ClaimResponse.",
                "requires": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Claim"
                    }
                ],
                "status": "fail",
                "test_method": "c9f_1d_check_on_average_claim_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'C9F_2A_request', 'Search ClaimResponse by simple claim ID' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @simple_id\n\n        search_string = @simple_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              'request' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @simple_response_id = reply.resource.entry[0].resource.xmlId unless @simple_response_id\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search ClaimResponse by simple claim ID",
                "id": "C9F_2A_request",
                "key": "C9F_2A_request",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "requires": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ],
                "status": "fail",
                "test_method": "c9f_2a_request_search_claimresponse_by_simple_claim_id_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'C9F_2A_text', 'Search ClaimResponse by simple claim ID in the text' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @simple_id\n\n        search_string = @simple_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              '_text' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @simple_response_id = reply.resource.entry[0].resource.xmlId unless @simple_response_id\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search ClaimResponse by simple claim ID in the text",
                "id": "C9F_2A_text",
                "key": "C9F_2A_text",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "requires": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ],
                "status": "fail",
                "test_method": "c9f_2a_text_search_claimresponse_by_simple_claim_id_in_the_text_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'C9F_2A_content', 'Search ClaimResponse by simple claim ID in the content' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @simple_id\n\n        search_string = @simple_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              '_content' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @simple_response_id = reply.resource.entry[0].resource.xmlId unless @simple_response_id\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search ClaimResponse by simple claim ID in the content",
                "id": "C9F_2A_content",
                "key": "C9F_2A_content",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "requires": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ],
                "status": "fail",
                "test_method": "c9f_2a_content_search_claimresponse_by_simple_claim_id_in_the_content_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'C9F_2B_request', 'Search ClaimResponse by average claim ID' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @average_id\n\n        search_string = @average_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              'request' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @average_response_id = reply.resource.entry[0].resource.xmlId unless @average_response_id\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search ClaimResponse by average claim ID",
                "id": "C9F_2B_request",
                "key": "C9F_2B_request",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "requires": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ],
                "status": "fail",
                "test_method": "c9f_2b_request_search_claimresponse_by_average_claim_id_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'C9F_2B_text', 'Search ClaimResponse by average claim ID in the text' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @average_id\n\n        search_string = @average_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              '_text' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @average_response_id = reply.resource.entry[0].resource.xmlId unless @average_response_id\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search ClaimResponse by average claim ID in the text",
                "id": "C9F_2B_text",
                "key": "C9F_2B_text",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "requires": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ],
                "status": "fail",
                "test_method": "c9f_2b_text_search_claimresponse_by_average_claim_id_in_the_text_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'C9F_2B_content', 'Search ClaimResponse by average claim ID in the content' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @average_id\n\n        search_string = @average_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              '_content' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @average_response_id = reply.resource.entry[0].resource.xmlId unless @average_response_id\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search ClaimResponse by average claim ID in the content",
                "id": "C9F_2B_content",
                "key": "C9F_2B_content",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html",
                    "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "requires": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ],
                "status": "fail",
                "test_method": "c9f_2b_content_search_claimresponse_by_average_claim_id_in_the_content_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0434d4d3261a6020000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:35:52.208-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f06d14d4d3266f8950200"
        },
        "created_at": {
            "$date": "2015-10-02T18:36:01.431-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'C8T1_1A','Register a new patient' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#1._Register_a_new_patient'\n          requires resource: 'Patient', methods: ['create']\n          validates resource: 'Patient', methods: ['create']\n        }\n\n        reply = @client.create @patient\n        @patient_id = reply.id\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Register a new patient",
                "id": "C8T1_1A",
                "key": "C8T1_1A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#1._Register_a_new_patient"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t1_1a_register_a_new_patient_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'C8T1_1B','Register a new patient - BONUS: Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#1._Register_a_new_patient'\n          requires resource: 'Patient', methods: ['create']\n          validates resource: 'Patient', methods: ['create']\n          validates extensions: ['extensions']\n        }\n\n        reply = @client.create @patient_us\n        @patient_us_id = reply.id\n\t\t    @patient_us.xmlId = reply.resource.xmlId || reply.id\n\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Register a new patient - BONUS: Extensions",
                "id": "C8T1_1B",
                "key": "C8T1_1B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#1._Register_a_new_patient"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t1_1b_register_a_new_patient_-_bonus:_extensions_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "extensions": [
                            "extensions"
                        ]
                    }
                ],
                "warnings": [
                    "The server did not correctly preserve the Patient data."
                ]
            },
            {
                "code": "      test 'C8T1_2A','Update a patient' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create', 'update']\n          validates resource: 'Patient', methods: ['update']\n        }\n        skip unless @patient_id\n\n\t\t    @patient.xmlId = @patient_id\n        @patient.telecom[0].value='1-800-TOLL-FREE'\n        @patient.telecom[0].system='phone'\n        @patient.name[0].given = ['Crocodile','Pants']\n\n        reply = @client.update @patient, @patient_id\n\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Update a patient",
                "id": "C8T1_2A",
                "key": "C8T1_2A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t1_2a_update_a_patient_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "The server did not correctly preserve the Patient data."
                ]
            },
            {
                "code": "      test 'C8T1_2B','Update a patient - BONUS: Unmodifier Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create','update']\n          validates resource: 'Patient', methods: ['update']\n          validates extensions: ['extensions']\n        }\n        skip unless @patient_us_id\n\t\t\n        @patient_us.xmlId = @patient_us_id\n        @patient_us.extension[0].value.value.coding[0].code = '1569-3'\n        @patient_us.extension[1].value.value.coding[0].code = '2186-5'\n\n        reply = @client.update @patient_us, @patient_us_id\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Update a patient - BONUS: Unmodifier Extensions",
                "id": "C8T1_2B",
                "key": "C8T1_2B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t1_2b_update_a_patient_-_bonus:_unmodifier_extensions_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "extensions": [
                            "extensions"
                        ]
                    }
                ],
                "warnings": [
                    "The server did not correctly preserve the Patient data."
                ]
            },
            {
                "code": "      test 'C8T1_2C','Update a patient - BONUS: Modifier Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create','update']\n          validates resource: 'Patient', methods: ['update']\n          validates extensions: ['modifying extensions']\n        }\n        skip unless @patient_us_id\n\n\t\t    @patient_us.xmlId = @patient_us_id\n        @patient_us.modifierExtension << FHIR::Extension.new\n        @patient_us.modifierExtension[0].url='http://projectcrucible.org/modifierExtension/foo'\n        @patient_us.modifierExtension[0].value = FHIR::AnyType.new('Boolean',true)\n\n        reply = @client.update @patient_us, @patient_us_id\n\n        @patient_us.modifierExtension.clear\n\n        assert([200,201,422].include?(reply.code), 'The server should except a modifierExtension, or return 422 if it chooses to reject a modifierExtension it does not understand.',\"Server response code: #{reply.code}\\n#{reply.body}\")\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Update a patient - BONUS: Modifier Extensions",
                "id": "C8T1_2C",
                "key": "C8T1_2C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t1_2c_update_a_patient_-_bonus:_modifier_extensions_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "extensions": [
                            "modifying extensions"
                        ]
                    }
                ],
                "warnings": [
                    "The server did not correctly preserve the Patient data."
                ]
            },
            {
                "code": "      test 'C8T1_2D','Update a patient - BONUS: Primitive Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create','update']\n          validates resource: 'Patient', methods: ['update']\n          validates extensions: ['primitive extensions']\n        }\n        skip unless @patient_us_id\n\n        @patient_us.xmlId = @patient_us_id\n        @patient_us.gender = 'male'\n        pe = FHIR::PrimitiveExtension.new\n        pe.path='_gender'\n        pe['extension'] = [ FHIR::Extension.new ]\n        pe['extension'][0].url = 'http://hl7.org/test/gender'\n        pe['extension'][0].value = FHIR::AnyType.new('String','Male')\n        @patient_us.primitiveExtension << pe\n\n        reply = @client.update @patient_us, @patient_us_id\n\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Update a patient - BONUS: Primitive Extensions",
                "id": "C8T1_2D",
                "key": "C8T1_2D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t1_2d_update_a_patient_-_bonus:_primitive_extensions_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "extensions": [
                            "primitive extensions"
                        ]
                    }
                ],
                "warnings": [
                    "The server did not correctly preserve the Patient data."
                ]
            },
            {
                "code": "      test 'C8T1_2E','Update a patient - BONUS: Complex Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create','update']\n          validates resource: 'Patient', methods: ['update']\n          validates extensions: ['complex extensions']\n        }\n        skip unless @patient_us_id\n\n        @patient_us.xmlId = @patient_us_id\n        begin\n          @patient_us.primitiveExtension.clear\n        rescue Exception => e\n          # IGNORE: the above call always throws an exception -- even though it succeeds!!\n        end\n        ext = FHIR::Extension.new\n        ext.url = 'http://hl7.org/complex/foo'\n        ext.extension << FHIR::Extension.new\n        ext.extension[0].url='http://complex/foo/bar'\n        ext.extension[0].value=FHIR::AnyType.new('String','foobar')\n        @patient.extension << ext\n\n        reply = @client.update @patient_us, @patient_us_id\n\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n",
                "description": "Update a patient - BONUS: Complex Extensions",
                "id": "C8T1_2E",
                "key": "C8T1_2E",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t1_2e_update_a_patient_-_bonus:_complex_extensions_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "extensions": [
                            "complex extensions"
                        ]
                    }
                ],
                "warnings": [
                    "The server did not correctly preserve the Patient data."
                ]
            },
            {
                "code": "      test  'C8T1_3','Retrieve Patient History' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#3._Retrieve_Patient_history'\n          requires resource: 'Patient', methods: ['create', 'update']\n          validates resource: 'Patient', methods: ['history']\n        }\n        skip unless @patient_id\n\n        result = @client.resource_instance_history(FHIR::Patient,@patient_id)\n        assert_response_ok result\n        assert_equal 2, result.resource.total, 'The number of returned versions is not correct'\n        warning { assert_equal 'history', result.resource.fhirType, 'The bundle does not have the correct type: history' }\n        warning { check_sort_order(result.resource.entry) }\n      end\n",
                "description": "Retrieve Patient History",
                "id": "C8T1_3",
                "key": "C8T1_3",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#3._Retrieve_Patient_history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "c8t1_3_retrieve_patient_history_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'C8T1_4', 'Search patient resource on given name' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#4._Search_for_a_patient_on_name'\n          requires resource: 'Patient', methods: ['create']\n          validates resource: 'Patient', methods: ['search']\n        }\n\n        search_string = @patient.name[0].given[0]\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'given' => search_string\n            }\n          }\n        }\n        @client.use_format_param = false\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n      end\n",
                "data": null,
                "description": "Search patient resource on given name",
                "id": "C8T1_4",
                "key": "C8T1_4",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#4._Search_for_a_patient_on_name"
                ],
                "message": "The server did not report any results.",
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "c8t1_4_search_patient_resource_on_given_name_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0434d4d3261a6030000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:36:01.431-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f06d84d4d3266f8960200"
        },
        "created_at": {
            "$date": "2015-10-02T18:36:08.267-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'C8T3_2A','Validate Observations against the General Specification' do\n        metadata {\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#Track_3_-_Experimental:_Profiles_and_conformance'\n          links \"#{BASE_SPEC_LINK}/structuredefinition.html\"\n          links \"#{BASE_SPEC_LINK}/observation.html\"\n          links \"#{BASE_SPEC_LINK}/operation-resource-validate.html\"\n          requires resource: 'StructureDefinition', methods: ['create']\n          validates resource: 'Observation', methods: ['$validate']\n          validates profiles: ['validate-profile']\n        }\n\n        @obs.each do |x|\n          reply = @client.validate(x)\n          assert_response_ok(reply)\n          if !reply.id.nil?\n            assert( !reply.id.include?('_validate'), \"Server created an Observation with the ID `_validate` rather than validate the resource.\", reply.id)\n          end\n        end\n      end\n",
                "description": "Validate Observations against the General Specification",
                "id": "C8T3_2A",
                "key": "C8T3_2A",
                "links": [
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#Track_3_-_Experimental:_Profiles_and_conformance",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html",
                    "http://hl7.org/fhir/DSTU2/observation.html",
                    "http://hl7.org/fhir/DSTU2/operation-resource-validate.html"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "StructureDefinition"
                    }
                ],
                "status": "pass",
                "test_method": "c8t3_2a_validate_observations_against_the_general_specification_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Observation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'C8T3_2B','Validate Observations against a Server-Side Profile' do\n        metadata {\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#Track_3_-_Experimental:_Profiles_and_conformance'\n          links \"#{BASE_SPEC_LINK}/structuredefinition.html\"\n          links \"#{BASE_SPEC_LINK}/observation.html\"\n          links \"#{BASE_SPEC_LINK}/operation-resource-validate.html\"\n          requires resource: 'StructureDefinition', methods: ['create']\n          validates resource: 'Observation', methods: ['$validate']\n          validates profiles: ['validate-profile']\n        }\n        \n        # @profile_url = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n        @obs.each do |x|\n          x.meta = FHIR::Resource::ResourceMetaComponent.new\n          x.meta.profile = [ @profile_url ]\n          reply = @client.validate(x,{profile_uri: @profile_url})\n          assert_response_ok(reply)\n          if !reply.id.nil?\n            assert( !reply.id.include?('_validate'), \"Server created an Observation with the ID `_validate` rather than validate the resource.\", reply.id)\n          end\n        end\n      end\n",
                "description": "Validate Observations against a Server-Side Profile",
                "id": "C8T3_2B",
                "key": "C8T3_2B",
                "links": [
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#Track_3_-_Experimental:_Profiles_and_conformance",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html",
                    "http://hl7.org/fhir/DSTU2/observation.html",
                    "http://hl7.org/fhir/DSTU2/operation-resource-validate.html"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "StructureDefinition"
                    }
                ],
                "status": "pass",
                "test_method": "c8t3_2b_validate_observations_against_a_server-side_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Observation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0434d4d3261a6040000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:36:08.267-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f06e64d4d3266f8970200"
        },
        "created_at": {
            "$date": "2015-10-02T18:36:22.886-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'CST01','Find Practitioner\\'s Schedule' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/schedule.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Schedule', methods: ['search']\n          validates resource: 'Schedule', methods: ['search']\n        }\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'actor' => \"Practitioner/#{@practitioner.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::Schedule, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(1, reply.resource.entry.size, 'There should only be one Schedule for the test Practitioner currently in the system.', reply.body)\n        assert_equal(@schedule.xmlId, reply.resource.entry[0].try(:resource).try(:xmlId), 'The correct Schedule was not returned.', reply.body)\n      end\n",
                "description": "Find Practitioner's Schedule",
                "id": "CST01",
                "key": "CST01",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/schedule.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ],
                "status": "pass",
                "test_method": "cst01_find_practitioner's_schedule_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'CST02','Find Slot in Practitioner\\'s Schedule' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/slot.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Slot', methods: ['search']\n          validates resource: 'Slot', methods: ['search']\n        }\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'schedule' => \"Schedule/#{@schedule.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::Slot, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(1, reply.resource.entry.size, 'There should only be one Slot for the test Practitioner\\'s Schedule currently in the system.', reply.body)\n        assert_equal(@slot.xmlId, reply.resource.entry[0].try(:resource).try(:xmlId), 'The correct Slot was not returned.', reply.body)\n      end\n",
                "description": "Find Slot in Practitioner's Schedule",
                "id": "CST02",
                "key": "CST02",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/slot.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ],
                "status": "pass",
                "test_method": "cst02_find_slot_in_practitioner's_schedule_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'CST03','Create Proposed Appointment in Slot' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['create']\n          validates resource: 'Appointment', methods: ['create']\n        }\n        @appointment = @resources.scheduling_appointment\n        @appointment.xmlId = nil # clear the identifier\n        @appointment.participant[0].actor.reference = \"Patient/#{@patient.xmlId}\"\n        @appointment.participant[1].actor.reference = \"Practitioner/#{@practitioner.xmlId}\"\n        reply = @client.create(@appointment)      \n        assert_response_ok(reply)\n        @appointment.xmlId = reply.id\n      end \n",
                "description": "Create Proposed Appointment in Slot",
                "id": "CST03",
                "key": "CST03",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/appointment.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Appointment"
                    }
                ],
                "status": "pass",
                "test_method": "cst03_create_proposed_appointment_in_slot_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'CST04','Update Slot status to busy-tentative' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/slot.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Slot', methods: ['update']\n          validates resource: 'Slot', methods: ['update']\n        }\n        @slot.freeBusyType = 'busy-tentative'\n        reply = @client.update(@slot,@slot.xmlId)      \n        assert_response_ok(reply)\n      end   \n",
                "description": "Update Slot status to busy-tentative",
                "id": "CST04",
                "key": "CST04",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/slot.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Slot"
                    }
                ],
                "status": "pass",
                "test_method": "cst04_update_slot_status_to_busy-tentative_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'CST05','Create AppointmentResponse for Patient (accepted)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/appointmentresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'AppointmentResponse', methods: ['create']\n          validates resource: 'AppointmentResponse', methods: ['create']\n        }\n        @appointment_response_patient = @resources.scheduling_response_patient\n        @appointment_response_patient.xmlId = nil # clear the identifier\n        @appointment_response_patient.appointment.reference = \"Appointment/#{@appointment.xmlId}\"\n        reply = @client.create(@appointment_response_patient)      \n        assert_response_ok(reply)\n        @appointment_response_patient.xmlId = reply.id\n      end \n",
                "description": "Create AppointmentResponse for Patient (accepted)",
                "id": "CST05",
                "key": "CST05",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ],
                "status": "pass",
                "test_method": "cst05_create_appointmentresponse_for_patient_(accepted)_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'CST06','Update Appointment.participant.status for Patient (accepted)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['update']\n          validates resource: 'Appointment', methods: ['update']\n        }\n        @appointment.participant[0].status = 'accepted'\n        reply = @client.update(@appointment,@appointment.xmlId)      \n        assert_response_ok(reply)\n      end\n",
                "description": "Update Appointment.participant.status for Patient (accepted)",
                "id": "CST06",
                "key": "CST06",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/appointment.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ],
                "status": "pass",
                "test_method": "cst06_update_appointment.participant.status_for_patient_(accepted)_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'CST07','Create AppointmentResponse for Practitioner (accepted)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/appointmentresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'AppointmentResponse', methods: ['create']\n          validates resource: 'AppointmentResponse', methods: ['create']\n        }\n        @appointment_response_practitioner = @resources.scheduling_response_practitioner\n        @appointment_response_practitioner.xmlId = nil # clear the identifier\n        @appointment_response_practitioner.appointment.reference = \"Appointment/#{@appointment.xmlId}\"\n        reply = @client.create(@appointment_response_practitioner)      \n        assert_response_ok(reply)\n        @appointment_response_practitioner.xmlId = reply.id\n      end \n",
                "description": "Create AppointmentResponse for Practitioner (accepted)",
                "id": "CST07",
                "key": "CST07",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ],
                "status": "pass",
                "test_method": "cst07_create_appointmentresponse_for_practitioner_(accepted)_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'CST08','Update Appointment.participant.status for Practitioner (accepted)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['update']\n          validates resource: 'Appointment', methods: ['update']\n        }\n        @appointment.participant[1].status = 'accepted'\n        reply = @client.update(@appointment,@appointment.xmlId)      \n        assert_response_ok(reply)\n      end\n",
                "description": "Update Appointment.participant.status for Practitioner (accepted)",
                "id": "CST08",
                "key": "CST08",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/appointment.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ],
                "status": "pass",
                "test_method": "cst08_update_appointment.participant.status_for_practitioner_(accepted)_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'CST09','Update Slot status (busy)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/slot.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Slot', methods: ['update']\n          validates resource: 'Slot', methods: ['update']\n        }\n        @slot.freeBusyType = 'busy'\n        reply = @client.update(@slot,@slot.xmlId)      \n        assert_response_ok(reply)\n      end  \n",
                "description": "Update Slot status (busy)",
                "id": "CST09",
                "key": "CST09",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/slot.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Slot"
                    }
                ],
                "status": "pass",
                "test_method": "cst09_update_slot_status_(busy)_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'CST10','Update Appointment status (booked)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['update']\n          validates resource: 'Appointment', methods: ['update']\n        }\n        @appointment.status = 'booked'\n        reply = @client.update(@appointment,@appointment.xmlId)      \n        assert_response_ok(reply)\n      end \n",
                "description": "Update Appointment status (booked)",
                "id": "CST10",
                "key": "CST10",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/appointment.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ],
                "status": "pass",
                "test_method": "cst10_update_appointment_status_(booked)_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'CST11','Update Appointment status (cancelled)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['update']\n          validates resource: 'Appointment', methods: ['update']\n        }\n        @appointment.status = 'cancelled'\n        reply = @client.update(@appointment,@appointment.xmlId)      \n        assert_response_ok(reply)\n      end \n",
                "description": "Update Appointment status (cancelled)",
                "id": "CST11",
                "key": "CST11",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/appointment.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ],
                "status": "pass",
                "test_method": "cst11_update_appointment_status_(cancelled)_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'CST12','Update Slot status (free)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/slot.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Slot', methods: ['update']\n          validates resource: 'Slot', methods: ['update']\n        }\n        @slot.freeBusyType = 'free'\n        reply = @client.update(@slot,@slot.xmlId)      \n        assert_response_ok(reply)\n      end \n",
                "description": "Update Slot status (free)",
                "id": "CST12",
                "key": "CST12",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/slot.html",
                    "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Slot"
                    }
                ],
                "status": "pass",
                "test_method": "cst12_update_slot_status_(free)_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Slot"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0434d4d3261a6050000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:36:22.886-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f06f54d4d3266f8980200"
        },
        "created_at": {
            "$date": "2015-10-02T18:36:37.305-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "        test \"CT01#{how[0]}\", \"Expand a specific ValueSet (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#expand\"\n            validates resource: 'ValueSet', methods: ['$expand']\n          }\n          skip if @valueset.nil?\n          options = {\n            :id => @valueset.xmlId,\n            :operation => {\n              :method => how\n            }\n          }\n          reply = @client.value_set_expansion(options)\n          assert_response_ok(reply)\n          assert_resource_type(reply, FHIR::ValueSet)\n          check_expansion_for_concepts(reply.resource)\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"ArgumentNullException: Value cannot be null.&#xD;&#xA;Parameter name: s\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.IO.StringReader..ctor(String s)&#xD;&#xA;   at Hl7.Fhir.Serialization.FhirParser.XmlReaderFromXml(String xml) in C:\\src\\FHIR\\fhir-net-api-DSTU2\\src\\Hl7.Fhir.Core\\Serialization\\FhirParser.cs:line 273&#xD;&#xA;   at Hl7.Fhir.Serialization.FhirParser.ParseResourceFromXml(String xml) in C:\\src\\FHIR\\fhir-net-api-DSTU2\\src\\Hl7.Fhir.Core\\Serialization\\FhirParser.cs:line 311&#xD;&#xA;   at HealthConnex.Fhir.Models.ValueSetModel.GetForExpansion(fhirstore store, String ResourceId, Int64&amp; internal_id) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\ValueSetModel.cs:line 159&#xD;&#xA;   at HealthConnex.Fhir.Models.ValueSetModel.PerformOperation(String id, String operation, Parameters operationParameters, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\ValueSetModel.cs:line 179&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.PerformOperation(String ResourceName, String id, String operation) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 346&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue></OperationOutcome>",
                "description": "Expand a specific ValueSet (GET)",
                "id": "CT01G",
                "key": "CT01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#expand"
                ],
                "message": "Bad response code: expected 200, 201, but found 500. ",
                "status": "fail",
                "test_method": "ct01g_expand_a_specific_valueset_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "$expand"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT02#{how[0]}\", \"Expand a ValueSet by context (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#expand\"\n            validates resource: 'ValueSet', methods: ['$expand']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'context' => { type: 'Uri', value: 'http://hl7.org/fhir/StructureDefinition/StructureDefinition#StructureDefinition.constrainedType' }\n              }\n            }\n          }\n          reply = @client.value_set_expansion(options)\n          assert_response_ok(reply)\n          assert_resource_type(reply, FHIR::ValueSet)\n          check_expansion_for_concepts(reply.resource)\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation expand is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>",
                "description": "Expand a ValueSet by context (GET)",
                "id": "CT02G",
                "key": "CT02G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#expand"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "status": "fail",
                "test_method": "ct02g_expand_a_valueset_by_context_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "$expand"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT03#{how[0]}\", \"Validate a code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$validate-code']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'female' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/ValueSet/administrative-gender' }\n              }\n            }\n          }\n          reply = @client.value_set_code_validation(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'result','valueBoolean','true')\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation validate-code is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>",
                "description": "Validate a code (GET)",
                "id": "CT03G",
                "key": "CT03G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "status": "fail",
                "test_method": "ct03g_validate_a_code_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "$validate-code"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT04#{how[0]}\", \"Validate a v2 code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$validate-code']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'BRN' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/v2/0487' }\n              }\n            }\n          }\n          reply = @client.value_set_code_validation(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'result','valueBoolean','true')\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation validate-code is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>",
                "description": "Validate a v2 code (GET)",
                "id": "CT04G",
                "key": "CT04G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "status": "fail",
                "test_method": "ct04g_validate_a_v2_code_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "$validate-code"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT05#{how[0]}\", \"Lookup a v2 code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$lookup']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'BRN' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/v2/0487' }\n              }\n            }\n          }\n          reply = @client.value_set_code_lookup(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'display','valueString','Burn')\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation lookup is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>",
                "description": "Lookup a v2 code (GET)",
                "id": "CT05G",
                "key": "CT05G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "status": "fail",
                "test_method": "ct05g_lookup_a_v2_code_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "$lookup"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT01#{how[0]}\", \"Expand a specific ValueSet (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#expand\"\n            validates resource: 'ValueSet', methods: ['$expand']\n          }\n          skip if @valueset.nil?\n          options = {\n            :id => @valueset.xmlId,\n            :operation => {\n              :method => how\n            }\n          }\n          reply = @client.value_set_expansion(options)\n          assert_response_ok(reply)\n          assert_resource_type(reply, FHIR::ValueSet)\n          check_expansion_for_concepts(reply.resource)\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Body parsing failed: Cannot parse xml: Root element is missing.\" /></details></issue></OperationOutcome>",
                "description": "Expand a specific ValueSet (POST)",
                "id": "CT01P",
                "key": "CT01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#expand"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "status": "fail",
                "test_method": "ct01p_expand_a_specific_valueset_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "$expand"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT02#{how[0]}\", \"Expand a ValueSet by context (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#expand\"\n            validates resource: 'ValueSet', methods: ['$expand']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'context' => { type: 'Uri', value: 'http://hl7.org/fhir/StructureDefinition/StructureDefinition#StructureDefinition.constrainedType' }\n              }\n            }\n          }\n          reply = @client.value_set_expansion(options)\n          assert_response_ok(reply)\n          assert_resource_type(reply, FHIR::ValueSet)\n          check_expansion_for_concepts(reply.resource)\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation expand is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>",
                "description": "Expand a ValueSet by context (POST)",
                "id": "CT02P",
                "key": "CT02P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#expand"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "status": "fail",
                "test_method": "ct02p_expand_a_valueset_by_context_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "$expand"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT03#{how[0]}\", \"Validate a code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$validate-code']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'female' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/ValueSet/administrative-gender' }\n              }\n            }\n          }\n          reply = @client.value_set_code_validation(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'result','valueBoolean','true')\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation validate-code is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>",
                "description": "Validate a code (POST)",
                "id": "CT03P",
                "key": "CT03P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "status": "fail",
                "test_method": "ct03p_validate_a_code_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "$validate-code"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT04#{how[0]}\", \"Validate a v2 code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$validate-code']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'BRN' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/v2/0487' }\n              }\n            }\n          }\n          reply = @client.value_set_code_validation(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'result','valueBoolean','true')\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation validate-code is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>",
                "description": "Validate a v2 code (POST)",
                "id": "CT04P",
                "key": "CT04P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "status": "fail",
                "test_method": "ct04p_validate_a_v2_code_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "$validate-code"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "        test \"CT05#{how[0]}\", \"Lookup a v2 code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$lookup']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'BRN' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/v2/0487' }\n              }\n            }\n          }\n          reply = @client.value_set_code_lookup(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'display','valueString','Burn')\n        end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation lookup is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>",
                "description": "Lookup a v2 code (POST)",
                "id": "CT05P",
                "key": "CT05P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operations.html#executing",
                    "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code"
                ],
                "message": "Bad response code: expected 200, 201, but found 501. ",
                "status": "fail",
                "test_method": "ct05p_lookup_a_v2_code_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "$lookup"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0434d4d3261a6060000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:36:37.305-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f070c4d4d3266f8990200"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:00.273-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'CT01', 'Request xml using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format)\n          assert compare_response_format(patient, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (headers) resource does not match created resource' }\n        rescue => e\n          raise AssertionException.new(\"CTO1 - Failed to handle XML format header response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request xml using headers",
                "id": "CT01",
                "key": "CT01",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct01_request_xml_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (headers) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT02A', 'Request [xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[0], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [xml] using [_format]",
                "id": "CT02A",
                "key": "CT02A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct02a_request_[xml]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT02B', 'Request [text/xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[1], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [text/xml] using [_format]",
                "id": "CT02B",
                "key": "CT02B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct02b_request_[text/xml]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT02C', 'Request [application/xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[2], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/xml] using [_format]",
                "id": "CT02C",
                "key": "CT02C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct02c_request_[application/xml]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT02D', 'Request [application/xml+fhir] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[3], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/xml+fhir] using [_format]",
                "id": "CT02D",
                "key": "CT02D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct02d_request_[application/xml+fhir]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT03', 'Request json using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format)\n          assert compare_response_format(patient, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (headers) resource does not match created resource' }\n        rescue => e\n          raise AssertionException.new(\"CTO3 - Failed to handle JSON format header response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request json using headers",
                "id": "CT03",
                "key": "CT03",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct03_request_json_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (headers) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT04A', 'Request [json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[0], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [json] using [_format]",
                "id": "CT04A",
                "key": "CT04A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct04a_request_[json]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT04B', 'Request [text/json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[1], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [text/json] using [_format]",
                "id": "CT04B",
                "key": "CT04B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct04b_request_[text/json]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT04C', 'Request [application/json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[2], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/json] using [_format]",
                "id": "CT04C",
                "key": "CT04C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct04c_request_[application/json]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT04D', 'Request [application/json+fhir] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[3], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/json+fhir] using [_format]",
                "id": "CT04D",
                "key": "CT04D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct04d_request_[application/json+fhir]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'FT01', 'Request xml and json using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML','JSON']\n        }\n        begin\n          patient_xml = request_entry(FHIR::Patient, @id, @xml_format)\n          patient_json = request_entry(FHIR::Patient, @id, @json_format)\n\n          assert compare_response_format(patient_xml, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient_xml.response_format}\"\n          assert compare_response_format(patient_json, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient_json.response_format}\"\n          warning { assert compare_entries(patient_xml, patient_json), 'requested XML & JSON (headers) resources do not match created resource or each other' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"FTO1 - Failed to handle XML & JSON header param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request xml and json using headers",
                "id": "FT01",
                "key": "FT01",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft01_request_xml_and_json_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "XML",
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML & JSON (headers) resources do not match created resource or each other"
                ]
            },
            {
                "code": "      test 'FT02', 'Request xml and json using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML','JSON']\n        }\n        begin\n          patient_xml = request_entry(FHIR::Patient, @id, @xml_format, true)\n          patient_json = request_entry(FHIR::Patient, @id, @json_format, true)\n\n          assert compare_response_format(patient_xml, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient_xml.response_format}\"\n          assert compare_response_format(patient_json, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient_json.response_format}\"\n          warning { assert compare_entries(patient_xml, patient_json), 'requested XML & JSON (_format) resources do not match created resource or each other' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"FTO2 - Failed to handle XML & JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request xml and json using [_format]",
                "id": "FT02",
                "key": "FT02",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft02_request_xml_and_json_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML",
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML & JSON (_format) resources do not match created resource or each other"
                ]
            },
            {
                "code": "      test 'FT03', 'Request xml Bundle using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format header mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO3 - Failed to handle Bundle XML format header response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request xml Bundle using headers",
                "id": "FT03",
                "key": "FT03",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft03_request_xml_bundle_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT04A', 'Request [xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[0], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [xml] Bundle using [_format]",
                "id": "FT04A",
                "key": "FT04A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft04a_request_[xml]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT04B', 'Request [text/xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[1], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [text/xml] Bundle using [_format]",
                "id": "FT04B",
                "key": "FT04B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft04b_request_[text/xml]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT04C', 'Request [application/xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[2], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/xml] Bundle using [_format]",
                "id": "FT04C",
                "key": "FT04C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft04c_request_[application/xml]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT04D', 'Request [application/xml+fhir] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[3], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/xml+fhir] Bundle using [_format]",
                "id": "FT04D",
                "key": "FT04D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft04d_request_[application/xml+fhir]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT05', 'Request json Bundle using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format header mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FT05 - Failed to handle Bundle JSON format header response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request json Bundle using headers",
                "id": "FT05",
                "key": "FT05",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft05_request_json_bundle_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT06A', 'Request [json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[0], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [json] Bundle using [_format]",
                "id": "FT06A",
                "key": "FT06A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft06a_request_[json]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT06B', 'Request [text/json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[1], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [text/json] Bundle using [_format]",
                "id": "FT06B",
                "key": "FT06B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft06b_request_[text/json]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT06C', 'Request [application/json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[2], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/json] Bundle using [_format]",
                "id": "FT06C",
                "key": "FT06C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft06c_request_[application/json]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT06D', 'Request [application/json+fhir] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[3], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/json+fhir] Bundle using [_format]",
                "id": "FT06D",
                "key": "FT06D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft06d_request_[application/json+fhir]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a6070000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:00.273-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07244d4d3266f89d0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:24.408-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test  'HI01','History for specific resource' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n        bundle = result.resource\n\n        assert_equal \"history\", bundle.fhirType, \"The bundle type is not correct\"\n        assert_equal @version_count, bundle.total, \"the number of returned versions is not correct\"\n        check_sort_order(bundle.entry)\n      end\n",
                "description": "History for specific resource",
                "id": "HI01",
                "key": "HI01",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi01_history_for_specific_resource_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test  'HI01.1','History request entries' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history\"]\n        }\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n        bundle = result.resource\n        entries = bundle.entry\n\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'DELETE' }.size, 'Wrong number of DELETE transactions in the history bundle'\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'PUT' }.size, 'Wrong number of PUT transactions in the history bundle'\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'POST' }.size, 'Wrong number of POST transactions in the history bundle'\n\n      end\n",
                "data": null,
                "description": "History request entries",
                "id": "HI01.1",
                "key": "HI01.1",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "Wrong number of PUT transactions in the history bundle Expected: 1, but found: 0.",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi01.1_history_request_entries_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI02\", \"full history of a resource by id with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history\"]\n        }\n\n        before = @create_date - 1.minute\n        after = before + 1.hour\n\n        all_history = @client.resource_instance_history(FHIR::Patient,@id)\n\n        result = @client.resource_instance_history_as_of(FHIR::Patient,@id,before)\n        assert_response_ok result\n        bundle = result.resource\n\n        assert_equal @version_count, bundle.total, \"the number of returned versions since the creation date is not correct\"\n\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n        result = @client.resource_instance_history_as_of(FHIR::Patient,@id,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"there should not be any history one hour after the creation date\"\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Exception of type 'Hl7.Fhir.Server.FhirServerException' was thrown.\" /></details></issue></OperationOutcome>",
                "description": "full history of a resource by id with since",
                "id": "HI02",
                "key": "HI02",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "Bad response code: expected 200, 201, but found 404. ",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi02_full_history_of_a_resource_by_id_with_since_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI03\", \"individual history versions\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"vread\", \"history\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n\n        bundle = result.resource\n\n        active_entries(bundle.entry).each do |entry|\n          pulled = @client.vread(FHIR::Patient, entry.resource.xmlId, entry.resource.meta.versionId)\n          assert_response_ok pulled\n          assert !pulled.nil?, \"Cannot find version that was present in history\"\n        end\n\n        deleted_entries(bundle.entry).each do |entry|\n          # FIXME: Should we parse the request URL or drop this assertion?\n          if entry.resource\n            pulled = @client.vread(FHIR::Patient, entry.resource.xmlId, entry.resource.meta.versionId)\n            assert pulled.resource.nil?, \"resource should not be found since it was deleted\"\n            assert_response_gone pulled\n          end\n        end\n      end\n",
                "description": "individual history versions",
                "id": "HI03",
                "key": "HI03",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi03_individual_history_versions_test",
                "validates": [
                    {
                        "methods": [
                            "vread",
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI04\", \"history for missing resource\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,'3141592unlikely')\n        assert_response_not_found result\n        assert result.resource.nil?, 'bad history request should not return a resource'\n      end\n",
                "description": "history for missing resource",
                "id": "HI04",
                "key": "HI04",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi04_history_for_missing_resource_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI06\", \"all history for resource with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        before = @create_date - 1.minute\n        after = Time.now.utc + 1.minute\n\n        result = @client.resource_history_as_of(FHIR::Patient,before)\n        assert_response_ok result\n        bundle = result.resource\n\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n\n        result = @client.resource_history_as_of(FHIR::Patient,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"Setting since to a future moment still returns history\"\n\n      end\n",
                "data": null,
                "description": "all history for resource with since",
                "id": "HI06",
                "key": "HI06",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "Setting since to a future moment still returns history Expected: 0, but found: 9.",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi06_all_history_for_resource_with_since_test",
                "validates": [
                    {
                        "methods": [
                            "history-type"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI08\", \"all history whole system with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: nil, methods: [\"history-system\"]\n        }\n\n        before = @create_date - 1.minute\n        after = Time.now.utc + 1.minute\n\n        result = @client.all_history_as_of(before)\n        assert_response_ok result\n        bundle = result.resource\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n        warning { assert_navigation_links(bundle) }\n\n        result = @client.resource_history_as_of(FHIR::Patient,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"Setting since to a future moment still returns history\"\n\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Resource [_history] is not supported on this server\" /></details></issue></OperationOutcome>",
                "description": "all history whole system with since",
                "id": "HI08",
                "key": "HI08",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "Bad response code: expected 200, 201, but found 404. ",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi08_all_history_whole_system_with_since_test",
                "validates": [
                    {
                        "methods": [
                            "history-system"
                        ],
                        "resource": null
                    }
                ]
            },
            {
                "code": "      test \"HI09\", \"resource history page forward\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        page_size = 2\n        page = @client.history(resource: FHIR::Patient, history: {since: (Time.now.utc - 1.hour), count: page_size})\n\n        forward_count = 0\n        # browse forwards\n        while page != nil\n          assert !page.resource.nil?, \"Unable to page forward through results.  A bundle was not returned from the page forward request.\"\n          warning { entry_ids_are_present(page.resource.entry) }\n          assert page.resource.entry.size <= page_size, \"Server returned a page with more entries than set by _count\"\n          forward_count += page.resource.entry.size\n          page = @client.next_page(page)\n        end\n\n        assert forward_count > 2, \"there should be at least 2 history entries\"\n      end\n",
                "description": "resource history page forward",
                "id": "HI09",
                "key": "HI09",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi09_resource_history_page_forward_test",
                "validates": [
                    {
                        "methods": [
                            "history-type"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI10\", \"resource history page backwards\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        page_size = 2\n        page = @client.history(resource: FHIR::Patient, history: {since: (Time.now.utc - 1.hour), count: page_size})\n\n        forward_count = 0\n        last_page = page\n        # browse forwards\n        while page != nil\n          assert !page.resource.nil?, \"Unable to page forward through results.  A bundle was not returned from the page forward request.\"\n          forward_count += page.resource.entry.size\n          page = @client.next_page(page)\n          last_page = page if page\n        end\n\n        backward_count = 0\n        page = last_page\n        # browse backwards\n        while page != nil\n          warning { entry_ids_are_present(page.resource.entry) }\n          assert page.resource.entry.size <= page_size, \"Server returned a page with more entries than set by _count\"\n          backward_count += page.resource.entry.size\n          page = @client.next_page(page, FHIR::Sections::Feed::BACKWARD)\n        end\n\n        assert_equal forward_count, backward_count, \"entry numbers were different moving forwards and backwards\"\n\n      end\n",
                "description": "resource history page backwards",
                "id": "HI10",
                "key": "HI10",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi10_resource_history_page_backwards_test",
                "validates": [
                    {
                        "methods": [
                            "history-type"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI11\", \"first page full history\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: nil, methods: [\"history-system\"]\n        }\n\n        history = @client.all_history\n        assert !history.resource.nil?, \"A bundle was not returned from the history request.\"\n        assert history.resource.entry.size >= 3, \"there should be at least 3 history entries\"\n      end\n",
                "data": null,
                "description": "first page full history",
                "id": "HI11",
                "key": "HI11",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "A bundle was not returned from the history request.",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi11_first_page_full_history_test",
                "validates": [
                    {
                        "methods": [
                            "history-system"
                        ],
                        "resource": null
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a6080000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:24.408-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07274d4d3266f89e0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:27.821-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'R001', 'Result headers on normal read.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        assert(@id, 'Setup was unable to create a patient.',@body)\n        reply = @client.read(FHIR::Patient, @id)\n        assert_response_ok(reply)\n        assert_equal @id, reply.id, 'Server returned wrong patient.'\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_etag_present(reply) }\n        warning { assert_last_modified_present(reply) }\n      end\n",
                "description": "Result headers on normal read.",
                "id": "R001",
                "key": "R001",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "r001_result_headers_on_normal_read._test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'R002', 'Read unknown resource type.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{REST_SPEC_LINK}#update\"\n        }\n\n        reply = @client.read(Crucible::Tests::ReadTest, @id)\n        assert_response_not_found(reply)\n      end\n",
                "description": "Read unknown resource type.",
                "id": "R002",
                "key": "R002",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/http.html#update"
                ],
                "message": null,
                "status": "pass",
                "test_method": "r002_read_unknown_resource_type._test"
            },
            {
                "code": "      test 'R003', 'Read non-existing resource id.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        reply = @client.read(FHIR::Patient, 'Supercalifragilisticexpialidocious')\n        assert_response_not_found(reply)\n      end\n",
                "description": "Read non-existing resource id.",
                "id": "R003",
                "key": "R003",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "r003_read_non-existing_resource_id._test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'R004', 'Read invalid format resource id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/datatypes.html#id\"\n          links \"#{BASE_SPEC_LINK}/resource.html#id\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        reply = @client.read(FHIR::Patient, 'Invalid-ID-Because_Of_!@$Special_Characters_and_Length_Over_Sixty_Four_Characters')\n        assert_response_bad(reply)\n      end\n",
                "data": null,
                "description": "Read invalid format resource id",
                "id": "R004",
                "key": "R004",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/datatypes.html#id",
                    "http://hl7.org/fhir/DSTU2/resource.html#id"
                ],
                "message": "Bad response code: expected 400, but found 404",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "r004_read_invalid_format_resource_id_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'R005', 'Read _summary=text' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/datatypes.html#id\"\n          links \"#{BASE_SPEC_LINK}/resource.html#id\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        assert(@id, 'Setup was unable to create a patient.', @body)\n        reply = @client.read(FHIR::Patient, @id, @client.default_format, 'text')\n        assert_response_ok(reply)\n        assert(reply.try(:resource).try(:text), 'Requested summary narrative was not provided.', reply.body)\n      end      \n",
                "data": "\ufeff<Patient xmlns=\"http://hl7.org/fhir\"><id value=\"9940f2415237475d8e8d62753dd1b79f\" /><meta><versionId value=\"458\" /><lastUpdated value=\"2015-10-02T22:37:24.957+00:00\" /></meta><name><family value=\"Emerald\" /><given value=\"Caro\" /></name></Patient>",
                "description": "Read _summary=text",
                "id": "R005",
                "key": "R005",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/datatypes.html#id",
                    "http://hl7.org/fhir/DSTU2/resource.html#id"
                ],
                "message": "Requested summary narrative was not provided.",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "r005_read__summary=text_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a6090000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:27.821-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f072f4d4d3266f89f0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:35.185-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Account: Read Type",
                "id": "X000_Account",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Account: Create New",
                "id": "X010_Account",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "New Account was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Account: Read Existing",
                "id": "X020_Account",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Successfully read preexisting Account.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Account: Update Existing",
                "id": "X030_Account",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Updated existing Account.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Account: Read History of existing",
                "id": "X040_Account",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Account: Version read existing",
                "id": "X050_Account",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Read current version of preexisting Account.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Account: Previous version read existing",
                "id": "X055_Account",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Read previous version of preexisting Account.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Account: Validate",
                "id": "X060_Account",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Account was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Account"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Account: Validate Existing",
                "id": "X065_Account",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Existing Account was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Account"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Account: Validate against a profile",
                "id": "X067_Account",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Account was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Account"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Account: Delete Existing",
                "id": "X070_Account",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Existing Account was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Account: Get Deleted Resource",
                "id": "X075_Account",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Deleted Account was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Account"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:35.185-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07364d4d3266f8a00200"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:42.691-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "AllergyIntolerance: Read Type",
                "id": "X000_AllergyIntolerance",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Create New",
                "id": "X010_AllergyIntolerance",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "New AllergyIntolerance was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "AllergyIntolerance: Read Existing",
                "id": "X020_AllergyIntolerance",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Successfully read preexisting AllergyIntolerance.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Update Existing",
                "id": "X030_AllergyIntolerance",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Updated existing AllergyIntolerance.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "AllergyIntolerance: Read History of existing",
                "id": "X040_AllergyIntolerance",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AllergyIntolerance: Version read existing",
                "id": "X050_AllergyIntolerance",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Read current version of preexisting AllergyIntolerance.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AllergyIntolerance: Previous version read existing",
                "id": "X055_AllergyIntolerance",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Read previous version of preexisting AllergyIntolerance.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Validate",
                "id": "X060_AllergyIntolerance",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "AllergyIntolerance was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AllergyIntolerance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Validate Existing",
                "id": "X065_AllergyIntolerance",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Existing AllergyIntolerance was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AllergyIntolerance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Validate against a profile",
                "id": "X067_AllergyIntolerance",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "AllergyIntolerance was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AllergyIntolerance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Delete Existing",
                "id": "X070_AllergyIntolerance",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Existing AllergyIntolerance was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Get Deleted Resource",
                "id": "X075_AllergyIntolerance",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Deleted AllergyIntolerance was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:42.691-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f073e4d4d3266f8a10200"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:50.242-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Appointment: Read Type",
                "id": "X000_Appointment",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Appointment: Create New",
                "id": "X010_Appointment",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "New Appointment was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Appointment: Read Existing",
                "id": "X020_Appointment",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Successfully read preexisting Appointment.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Appointment: Update Existing",
                "id": "X030_Appointment",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Updated existing Appointment.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Appointment: Read History of existing",
                "id": "X040_Appointment",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Appointment: Version read existing",
                "id": "X050_Appointment",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Read current version of preexisting Appointment.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Appointment: Previous version read existing",
                "id": "X055_Appointment",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Read previous version of preexisting Appointment.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Appointment: Validate",
                "id": "X060_Appointment",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Appointment was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Appointment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Appointment: Validate Existing",
                "id": "X065_Appointment",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Existing Appointment was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Appointment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Appointment: Validate against a profile",
                "id": "X067_Appointment",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Appointment was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Appointment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Appointment: Delete Existing",
                "id": "X070_Appointment",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Existing Appointment was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Appointment: Get Deleted Resource",
                "id": "X075_Appointment",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Deleted Appointment was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Appointment"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:50.242-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07454d4d3266f8a20200"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:57.257-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "AppointmentResponse: Read Type",
                "id": "X000_AppointmentResponse",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Create New",
                "id": "X010_AppointmentResponse",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "New AppointmentResponse was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "AppointmentResponse: Read Existing",
                "id": "X020_AppointmentResponse",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Successfully read preexisting AppointmentResponse.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Update Existing",
                "id": "X030_AppointmentResponse",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Updated existing AppointmentResponse.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "AppointmentResponse: Read History of existing",
                "id": "X040_AppointmentResponse",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AppointmentResponse: Version read existing",
                "id": "X050_AppointmentResponse",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Read current version of preexisting AppointmentResponse.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AppointmentResponse: Previous version read existing",
                "id": "X055_AppointmentResponse",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Read previous version of preexisting AppointmentResponse.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Validate",
                "id": "X060_AppointmentResponse",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "AppointmentResponse was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AppointmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Validate Existing",
                "id": "X065_AppointmentResponse",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Existing AppointmentResponse was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AppointmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Validate against a profile",
                "id": "X067_AppointmentResponse",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "AppointmentResponse was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AppointmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Delete Existing",
                "id": "X070_AppointmentResponse",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Existing AppointmentResponse was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Get Deleted Resource",
                "id": "X075_AppointmentResponse",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Deleted AppointmentResponse was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:57.257-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f074e4d4d3266f8a30200"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:06.839-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "AuditEvent: Read Type",
                "id": "X000_AuditEvent",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Create New",
                "id": "X010_AuditEvent",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "New AuditEvent was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "AuditEvent: Read Existing",
                "id": "X020_AuditEvent",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Successfully read preexisting AuditEvent.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"System AuditEvents cannot be modified\" /></details></issue></OperationOutcome>",
                "description": "AuditEvent: Update Existing",
                "id": "X030_AuditEvent",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": [
                    "error: : System AuditEvents cannot be modified"
                ],
                "status": "fail",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "AuditEvent: Read History of existing",
                "id": "X040_AuditEvent",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AuditEvent: Version read existing",
                "id": "X050_AuditEvent",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Read current version of preexisting AuditEvent.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AuditEvent: Previous version read existing",
                "id": "X055_AuditEvent",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Read previous version of preexisting AuditEvent.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Validate",
                "id": "X060_AuditEvent",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "AuditEvent was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AuditEvent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Validate Existing",
                "id": "X065_AuditEvent",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Existing AuditEvent was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AuditEvent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Validate against a profile",
                "id": "X067_AuditEvent",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "AuditEvent was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AuditEvent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Delete Existing",
                "id": "X070_AuditEvent",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Existing AuditEvent was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Get Deleted Resource",
                "id": "X075_AuditEvent",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Deleted AuditEvent was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:06.839-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07584d4d3266f8a40200"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:16.381-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Basic: Read Type",
                "id": "X000_Basic",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Basic: Create New",
                "id": "X010_Basic",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "New Basic was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Basic: Read Existing",
                "id": "X020_Basic",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Successfully read preexisting Basic.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Basic: Update Existing",
                "id": "X030_Basic",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Updated existing Basic.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Basic: Read History of existing",
                "id": "X040_Basic",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Basic: Version read existing",
                "id": "X050_Basic",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Read current version of preexisting Basic.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Basic: Previous version read existing",
                "id": "X055_Basic",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Read previous version of preexisting Basic.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Basic: Validate",
                "id": "X060_Basic",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Basic was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Basic"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Basic: Validate Existing",
                "id": "X065_Basic",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Existing Basic was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Basic"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Basic: Validate against a profile",
                "id": "X067_Basic",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Basic was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Basic"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Basic: Delete Existing",
                "id": "X070_Basic",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Existing Basic was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Basic: Get Deleted Resource",
                "id": "X075_Basic",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Deleted Basic was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Basic"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a60f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:16.381-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f075f4d4d3266f8a50200"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:23.689-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>",
                "description": "Binary: Read Type",
                "id": "X000_Binary",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Expected FHIR Bundle but found: OperationOutcome",
                "status": "fail",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Binary: Create New",
                "id": "X010_Binary",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "New Binary was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Binary: Read Existing",
                "id": "X020_Binary",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Successfully read preexisting Binary.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Binary: Update Existing",
                "id": "X030_Binary",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Updated existing Binary.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Binary: Read History of existing",
                "id": "X040_Binary",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Binary: Version read existing",
                "id": "X050_Binary",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Read current version of preexisting Binary.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Binary: Previous version read existing",
                "id": "X055_Binary",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Read previous version of preexisting Binary.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "data": "{\"Message\":\"The request is invalid.\"}",
                "description": "Binary: Validate",
                "id": "X060_Binary",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Response code 400 with no OperationOutcome provided.",
                "status": "fail",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Binary"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": "{\"Message\":\"The request is invalid.\"}",
                "description": "Binary: Validate Existing",
                "id": "X065_Binary",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Response code 400 with no OperationOutcome provided.",
                "status": "fail",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Binary"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "data": "{\"Message\":\"The request is invalid.\"}",
                "description": "Binary: Validate against a profile",
                "id": "X067_Binary",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Response code 400 with no OperationOutcome provided.",
                "status": "fail",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Binary"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Binary: Delete Existing",
                "id": "X070_Binary",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Existing Binary was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Binary: Get Deleted Resource",
                "id": "X075_Binary",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Deleted Binary was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Binary"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a6100000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:23.689-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07674d4d3266f8a60200"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:31.253-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "BodySite: Read Type",
                "id": "X000_BodySite",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "BodySite: Create New",
                "id": "X010_BodySite",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "New BodySite was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "BodySite: Read Existing",
                "id": "X020_BodySite",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Successfully read preexisting BodySite.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "BodySite: Update Existing",
                "id": "X030_BodySite",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Updated existing BodySite.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "BodySite: Read History of existing",
                "id": "X040_BodySite",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "BodySite: Version read existing",
                "id": "X050_BodySite",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Read current version of preexisting BodySite.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "BodySite: Previous version read existing",
                "id": "X055_BodySite",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Read previous version of preexisting BodySite.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "BodySite: Validate",
                "id": "X060_BodySite",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "BodySite was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "BodySite"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "BodySite: Validate Existing",
                "id": "X065_BodySite",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Existing BodySite was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "BodySite"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "BodySite: Validate against a profile",
                "id": "X067_BodySite",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "BodySite was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "BodySite"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "BodySite: Delete Existing",
                "id": "X070_BodySite",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Existing BodySite was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "BodySite: Get Deleted Resource",
                "id": "X075_BodySite",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Deleted BodySite was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "BodySite"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a6110000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:31.253-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f076d4d4d3266f8a70200"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:37.718-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Bundle: Read Type",
                "id": "X000_Bundle",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Bundle: Create New",
                "id": "X010_Bundle",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "New Bundle was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Bundle: Read Existing",
                "id": "X020_Bundle",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Successfully read preexisting Bundle.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Bundle: Update Existing",
                "id": "X030_Bundle",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Updated existing Bundle.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Bundle: Read History of existing",
                "id": "X040_Bundle",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Bundle: Version read existing",
                "id": "X050_Bundle",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Read current version of preexisting Bundle.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Bundle: Previous version read existing",
                "id": "X055_Bundle",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Read previous version of preexisting Bundle.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Bundle: Validate",
                "id": "X060_Bundle",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Bundle was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Bundle"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Bundle: Validate Existing",
                "id": "X065_Bundle",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Existing Bundle was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Bundle"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Bundle: Validate against a profile",
                "id": "X067_Bundle",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Bundle was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Bundle"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Bundle: Delete Existing",
                "id": "X070_Bundle",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Existing Bundle was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Bundle: Get Deleted Resource",
                "id": "X075_Bundle",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Deleted Bundle was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Bundle"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a6120000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:37.718-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07774d4d3266f8a80200"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:47.180-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "CarePlan: Read Type",
                "id": "X000_CarePlan",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "CarePlan: Create New",
                "id": "X010_CarePlan",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "New CarePlan was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "CarePlan: Read Existing",
                "id": "X020_CarePlan",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Successfully read preexisting CarePlan.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "CarePlan: Update Existing",
                "id": "X030_CarePlan",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Updated existing CarePlan.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "CarePlan: Read History of existing",
                "id": "X040_CarePlan",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "CarePlan: Version read existing",
                "id": "X050_CarePlan",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Read current version of preexisting CarePlan.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "CarePlan: Previous version read existing",
                "id": "X055_CarePlan",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Read previous version of preexisting CarePlan.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "CarePlan: Validate",
                "id": "X060_CarePlan",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "CarePlan was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "CarePlan"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "CarePlan: Validate Existing",
                "id": "X065_CarePlan",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Existing CarePlan was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "CarePlan"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "CarePlan: Validate against a profile",
                "id": "X067_CarePlan",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "CarePlan was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "CarePlan"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "CarePlan: Delete Existing",
                "id": "X070_CarePlan",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Existing CarePlan was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "CarePlan: Get Deleted Resource",
                "id": "X075_CarePlan",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Deleted CarePlan was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a6130000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:47.180-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07814d4d3266f8a90200"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:57.814-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Claim: Read Type",
                "id": "X000_Claim",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Claim: Create New",
                "id": "X010_Claim",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "New Claim was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Claim: Read Existing",
                "id": "X020_Claim",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Successfully read preexisting Claim.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Claim: Update Existing",
                "id": "X030_Claim",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Updated existing Claim.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Claim: Read History of existing",
                "id": "X040_Claim",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Claim: Version read existing",
                "id": "X050_Claim",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Read current version of preexisting Claim.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Claim: Previous version read existing",
                "id": "X055_Claim",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Read previous version of preexisting Claim.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Claim: Validate",
                "id": "X060_Claim",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Claim was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Claim"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Claim: Validate Existing",
                "id": "X065_Claim",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Existing Claim was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Claim"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Claim: Validate against a profile",
                "id": "X067_Claim",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Claim was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Claim"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Claim: Delete Existing",
                "id": "X070_Claim",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Existing Claim was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Claim: Get Deleted Resource",
                "id": "X075_Claim",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Deleted Claim was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Claim"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a6140000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:57.814-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07894d4d3266f8aa0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:39:05.667-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ClaimResponse: Read Type",
                "id": "X000_ClaimResponse",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ClaimResponse: Create New",
                "id": "X010_ClaimResponse",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "New ClaimResponse was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ClaimResponse: Read Existing",
                "id": "X020_ClaimResponse",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Successfully read preexisting ClaimResponse.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ClaimResponse: Update Existing",
                "id": "X030_ClaimResponse",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Updated existing ClaimResponse.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ClaimResponse: Read History of existing",
                "id": "X040_ClaimResponse",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ClaimResponse: Version read existing",
                "id": "X050_ClaimResponse",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Read current version of preexisting ClaimResponse.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ClaimResponse: Previous version read existing",
                "id": "X055_ClaimResponse",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Read previous version of preexisting ClaimResponse.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ClaimResponse: Validate",
                "id": "X060_ClaimResponse",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "ClaimResponse was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ClaimResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ClaimResponse: Validate Existing",
                "id": "X065_ClaimResponse",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Existing ClaimResponse was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ClaimResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ClaimResponse: Validate against a profile",
                "id": "X067_ClaimResponse",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "ClaimResponse was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ClaimResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ClaimResponse: Delete Existing",
                "id": "X070_ClaimResponse",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Existing ClaimResponse was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ClaimResponse: Get Deleted Resource",
                "id": "X075_ClaimResponse",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Deleted ClaimResponse was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a6150000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:39:05.667-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07914d4d3266f8ab0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:39:13.632-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ClinicalImpression: Read Type",
                "id": "X000_ClinicalImpression",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ClinicalImpression: Create New",
                "id": "X010_ClinicalImpression",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "New ClinicalImpression was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ClinicalImpression: Read Existing",
                "id": "X020_ClinicalImpression",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Successfully read preexisting ClinicalImpression.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ClinicalImpression: Update Existing",
                "id": "X030_ClinicalImpression",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Updated existing ClinicalImpression.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ClinicalImpression: Read History of existing",
                "id": "X040_ClinicalImpression",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ClinicalImpression: Version read existing",
                "id": "X050_ClinicalImpression",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Read current version of preexisting ClinicalImpression.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ClinicalImpression: Previous version read existing",
                "id": "X055_ClinicalImpression",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Read previous version of preexisting ClinicalImpression.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ClinicalImpression: Validate",
                "id": "X060_ClinicalImpression",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "ClinicalImpression was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ClinicalImpression"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ClinicalImpression: Validate Existing",
                "id": "X065_ClinicalImpression",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Existing ClinicalImpression was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ClinicalImpression"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ClinicalImpression: Validate against a profile",
                "id": "X067_ClinicalImpression",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "ClinicalImpression was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ClinicalImpression"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ClinicalImpression: Delete Existing",
                "id": "X070_ClinicalImpression",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Existing ClinicalImpression was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ClinicalImpression: Get Deleted Resource",
                "id": "X075_ClinicalImpression",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Deleted ClinicalImpression was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0464d4d3261a6160000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:39:13.632-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07994d4d3266f8ac0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:39:21.263-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Communication: Read Type",
                "id": "X000_Communication",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Communication: Create New",
                "id": "X010_Communication",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "New Communication was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Communication: Read Existing",
                "id": "X020_Communication",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Successfully read preexisting Communication.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Communication: Update Existing",
                "id": "X030_Communication",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Updated existing Communication.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Communication: Read History of existing",
                "id": "X040_Communication",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Communication: Version read existing",
                "id": "X050_Communication",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Read current version of preexisting Communication.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Communication: Previous version read existing",
                "id": "X055_Communication",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Read previous version of preexisting Communication.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Communication: Validate",
                "id": "X060_Communication",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Communication was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Communication"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Communication: Validate Existing",
                "id": "X065_Communication",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Existing Communication was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Communication"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Communication: Validate against a profile",
                "id": "X067_Communication",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Communication was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Communication"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Communication: Delete Existing",
                "id": "X070_Communication",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Existing Communication was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Communication: Get Deleted Resource",
                "id": "X075_Communication",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Deleted Communication was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Communication"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0464d4d3261a6170000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:39:21.263-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f079f4d4d3266f8ad0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:39:27.825-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "CommunicationRequest: Read Type",
                "id": "X000_CommunicationRequest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "CommunicationRequest: Create New",
                "id": "X010_CommunicationRequest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "New CommunicationRequest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "CommunicationRequest: Read Existing",
                "id": "X020_CommunicationRequest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Successfully read preexisting CommunicationRequest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "CommunicationRequest: Update Existing",
                "id": "X030_CommunicationRequest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Updated existing CommunicationRequest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "CommunicationRequest: Read History of existing",
                "id": "X040_CommunicationRequest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "CommunicationRequest: Version read existing",
                "id": "X050_CommunicationRequest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Read current version of preexisting CommunicationRequest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "CommunicationRequest: Previous version read existing",
                "id": "X055_CommunicationRequest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Read previous version of preexisting CommunicationRequest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "CommunicationRequest: Validate",
                "id": "X060_CommunicationRequest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "CommunicationRequest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "CommunicationRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "CommunicationRequest: Validate Existing",
                "id": "X065_CommunicationRequest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Existing CommunicationRequest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "CommunicationRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "CommunicationRequest: Validate against a profile",
                "id": "X067_CommunicationRequest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "CommunicationRequest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "CommunicationRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "CommunicationRequest: Delete Existing",
                "id": "X070_CommunicationRequest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Existing CommunicationRequest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "CommunicationRequest: Get Deleted Resource",
                "id": "X075_CommunicationRequest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Deleted CommunicationRequest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0464d4d3261a6180000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:39:27.825-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07a74d4d3266f8ae0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:39:35.563-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Composition: Read Type",
                "id": "X000_Composition",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Composition: Create New",
                "id": "X010_Composition",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "New Composition was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Composition: Read Existing",
                "id": "X020_Composition",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Successfully read preexisting Composition.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Composition: Update Existing",
                "id": "X030_Composition",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Updated existing Composition.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Composition: Read History of existing",
                "id": "X040_Composition",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Composition: Version read existing",
                "id": "X050_Composition",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Read current version of preexisting Composition.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Composition: Previous version read existing",
                "id": "X055_Composition",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Read previous version of preexisting Composition.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Composition: Validate",
                "id": "X060_Composition",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Composition was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Composition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Composition: Validate Existing",
                "id": "X065_Composition",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Existing Composition was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Composition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Composition: Validate against a profile",
                "id": "X067_Composition",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Composition was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Composition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Composition: Delete Existing",
                "id": "X070_Composition",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Existing Composition was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Composition: Get Deleted Resource",
                "id": "X075_Composition",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Deleted Composition was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Composition"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0464d4d3261a6190000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:39:35.563-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07b44d4d3266f8af0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:39:48.195-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ConceptMap: Read Type",
                "id": "X000_ConceptMap",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ConceptMap: Create New",
                "id": "X010_ConceptMap",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "New ConceptMap was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ConceptMap: Read Existing",
                "id": "X020_ConceptMap",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Successfully read preexisting ConceptMap.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ConceptMap: Update Existing",
                "id": "X030_ConceptMap",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Updated existing ConceptMap.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ConceptMap: Read History of existing",
                "id": "X040_ConceptMap",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ConceptMap: Version read existing",
                "id": "X050_ConceptMap",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Read current version of preexisting ConceptMap.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ConceptMap: Previous version read existing",
                "id": "X055_ConceptMap",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Read previous version of preexisting ConceptMap.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ConceptMap: Validate",
                "id": "X060_ConceptMap",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "ConceptMap was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ConceptMap"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ConceptMap: Validate Existing",
                "id": "X065_ConceptMap",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Existing ConceptMap was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ConceptMap"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ConceptMap: Validate against a profile",
                "id": "X067_ConceptMap",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "ConceptMap was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ConceptMap"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ConceptMap: Delete Existing",
                "id": "X070_ConceptMap",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Existing ConceptMap was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ConceptMap: Get Deleted Resource",
                "id": "X075_ConceptMap",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Deleted ConceptMap was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0464d4d3261a61a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:39:48.195-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07bd4d4d3266f8b00200"
        },
        "created_at": {
            "$date": "2015-10-02T18:39:57.680-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Condition: Read Type",
                "id": "X000_Condition",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Condition: Create New",
                "id": "X010_Condition",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "New Condition was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Condition: Read Existing",
                "id": "X020_Condition",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Successfully read preexisting Condition.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Condition: Update Existing",
                "id": "X030_Condition",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Updated existing Condition.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Condition: Read History of existing",
                "id": "X040_Condition",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Condition: Version read existing",
                "id": "X050_Condition",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Read current version of preexisting Condition.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Condition: Previous version read existing",
                "id": "X055_Condition",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Read previous version of preexisting Condition.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Condition: Validate",
                "id": "X060_Condition",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Condition was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Condition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Condition: Validate Existing",
                "id": "X065_Condition",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Existing Condition was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Condition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Condition: Validate against a profile",
                "id": "X067_Condition",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Condition was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Condition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Condition: Delete Existing",
                "id": "X070_Condition",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Existing Condition was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Condition: Get Deleted Resource",
                "id": "X075_Condition",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Deleted Condition was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Condition"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0464d4d3261a61b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:39:57.680-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07c54d4d3266f8b10200"
        },
        "created_at": {
            "$date": "2015-10-02T18:40:05.021-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Conformance: Read Type",
                "id": "X000_Conformance",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Conformance: Create New",
                "id": "X010_Conformance",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "New Conformance was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Conformance: Read Existing",
                "id": "X020_Conformance",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Successfully read preexisting Conformance.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Conformance: Update Existing",
                "id": "X030_Conformance",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Updated existing Conformance.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Conformance: Read History of existing",
                "id": "X040_Conformance",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Conformance: Version read existing",
                "id": "X050_Conformance",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Read current version of preexisting Conformance.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Conformance: Previous version read existing",
                "id": "X055_Conformance",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Read previous version of preexisting Conformance.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Conformance: Validate",
                "id": "X060_Conformance",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Conformance was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Conformance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Conformance: Validate Existing",
                "id": "X065_Conformance",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Existing Conformance was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Conformance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Conformance: Validate against a profile",
                "id": "X067_Conformance",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Conformance was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Conformance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Conformance: Delete Existing",
                "id": "X070_Conformance",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Existing Conformance was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Conformance: Get Deleted Resource",
                "id": "X075_Conformance",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Deleted Conformance was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Conformance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0474d4d3261a61c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:40:05.021-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07cd4d4d3266f8b20200"
        },
        "created_at": {
            "$date": "2015-10-02T18:40:13.403-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Contract: Read Type",
                "id": "X000_Contract",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Contract: Create New",
                "id": "X010_Contract",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "New Contract was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Contract: Read Existing",
                "id": "X020_Contract",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Successfully read preexisting Contract.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Contract: Update Existing",
                "id": "X030_Contract",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Updated existing Contract.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Contract: Read History of existing",
                "id": "X040_Contract",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Contract: Version read existing",
                "id": "X050_Contract",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Read current version of preexisting Contract.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Contract: Previous version read existing",
                "id": "X055_Contract",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Read previous version of preexisting Contract.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Contract: Validate",
                "id": "X060_Contract",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Contract was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Contract"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Contract: Validate Existing",
                "id": "X065_Contract",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Existing Contract was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Contract"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Contract: Validate against a profile",
                "id": "X067_Contract",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Contract was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Contract"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Contract: Delete Existing",
                "id": "X070_Contract",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Existing Contract was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Contract: Get Deleted Resource",
                "id": "X075_Contract",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Deleted Contract was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Contract"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0474d4d3261a61d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:40:13.403-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07d44d4d3266f8b30200"
        },
        "created_at": {
            "$date": "2015-10-02T18:40:20.823-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Coverage: Read Type",
                "id": "X000_Coverage",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Coverage: Create New",
                "id": "X010_Coverage",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "New Coverage was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Coverage: Read Existing",
                "id": "X020_Coverage",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Successfully read preexisting Coverage.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Coverage: Update Existing",
                "id": "X030_Coverage",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Updated existing Coverage.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Coverage: Read History of existing",
                "id": "X040_Coverage",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Coverage: Version read existing",
                "id": "X050_Coverage",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Read current version of preexisting Coverage.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Coverage: Previous version read existing",
                "id": "X055_Coverage",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Read previous version of preexisting Coverage.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Coverage: Validate",
                "id": "X060_Coverage",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Coverage was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Coverage"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Coverage: Validate Existing",
                "id": "X065_Coverage",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Existing Coverage was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Coverage"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Coverage: Validate against a profile",
                "id": "X067_Coverage",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Coverage was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Coverage"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Coverage: Delete Existing",
                "id": "X070_Coverage",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Existing Coverage was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Coverage: Get Deleted Resource",
                "id": "X075_Coverage",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Deleted Coverage was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Coverage"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0474d4d3261a61e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:40:20.823-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07dd4d4d3266f8b40200"
        },
        "created_at": {
            "$date": "2015-10-02T18:40:29.699-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DataElement: Read Type",
                "id": "X000_DataElement",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DataElement: Create New",
                "id": "X010_DataElement",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "New DataElement was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DataElement: Read Existing",
                "id": "X020_DataElement",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Successfully read preexisting DataElement.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DataElement: Update Existing",
                "id": "X030_DataElement",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Updated existing DataElement.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DataElement: Read History of existing",
                "id": "X040_DataElement",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DataElement: Version read existing",
                "id": "X050_DataElement",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Read current version of preexisting DataElement.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DataElement: Previous version read existing",
                "id": "X055_DataElement",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Read previous version of preexisting DataElement.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DataElement: Validate",
                "id": "X060_DataElement",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "DataElement was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DataElement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DataElement: Validate Existing",
                "id": "X065_DataElement",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Existing DataElement was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DataElement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DataElement: Validate against a profile",
                "id": "X067_DataElement",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "DataElement was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DataElement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DataElement: Delete Existing",
                "id": "X070_DataElement",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Existing DataElement was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DataElement: Get Deleted Resource",
                "id": "X075_DataElement",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Deleted DataElement was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DataElement"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0474d4d3261a61f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:40:29.699-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07e44d4d3266f8b50200"
        },
        "created_at": {
            "$date": "2015-10-02T18:40:36.127-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DetectedIssue: Read Type",
                "id": "X000_DetectedIssue",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DetectedIssue: Create New",
                "id": "X010_DetectedIssue",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "New DetectedIssue was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DetectedIssue: Read Existing",
                "id": "X020_DetectedIssue",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Successfully read preexisting DetectedIssue.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DetectedIssue: Update Existing",
                "id": "X030_DetectedIssue",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Updated existing DetectedIssue.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DetectedIssue: Read History of existing",
                "id": "X040_DetectedIssue",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DetectedIssue: Version read existing",
                "id": "X050_DetectedIssue",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Read current version of preexisting DetectedIssue.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DetectedIssue: Previous version read existing",
                "id": "X055_DetectedIssue",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Read previous version of preexisting DetectedIssue.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DetectedIssue: Validate",
                "id": "X060_DetectedIssue",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "DetectedIssue was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DetectedIssue"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DetectedIssue: Validate Existing",
                "id": "X065_DetectedIssue",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Existing DetectedIssue was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DetectedIssue"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DetectedIssue: Validate against a profile",
                "id": "X067_DetectedIssue",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "DetectedIssue was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DetectedIssue"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DetectedIssue: Delete Existing",
                "id": "X070_DetectedIssue",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Existing DetectedIssue was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DetectedIssue: Get Deleted Resource",
                "id": "X075_DetectedIssue",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Deleted DetectedIssue was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0474d4d3261a6200000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:40:36.127-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07eb4d4d3266f8b60200"
        },
        "created_at": {
            "$date": "2015-10-02T18:40:43.619-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Device: Read Type",
                "id": "X000_Device",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Device: Create New",
                "id": "X010_Device",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "New Device was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Device: Read Existing",
                "id": "X020_Device",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Successfully read preexisting Device.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Device: Update Existing",
                "id": "X030_Device",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Updated existing Device.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Device: Read History of existing",
                "id": "X040_Device",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Device: Version read existing",
                "id": "X050_Device",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Read current version of preexisting Device.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Device: Previous version read existing",
                "id": "X055_Device",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Read previous version of preexisting Device.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Device: Validate",
                "id": "X060_Device",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Device was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Device"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Device: Validate Existing",
                "id": "X065_Device",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Existing Device was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Device"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Device: Validate against a profile",
                "id": "X067_Device",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Device was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Device"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Device: Delete Existing",
                "id": "X070_Device",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Existing Device was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Device: Get Deleted Resource",
                "id": "X075_Device",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Deleted Device was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Device"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0474d4d3261a6210000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:40:43.619-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07f44d4d3266f8b70200"
        },
        "created_at": {
            "$date": "2015-10-02T18:40:52.176-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DeviceComponent: Read Type",
                "id": "X000_DeviceComponent",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DeviceComponent: Create New",
                "id": "X010_DeviceComponent",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "New DeviceComponent was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DeviceComponent: Read Existing",
                "id": "X020_DeviceComponent",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Successfully read preexisting DeviceComponent.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceComponent: Update Existing",
                "id": "X030_DeviceComponent",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Updated existing DeviceComponent.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceComponent: Read History of existing",
                "id": "X040_DeviceComponent",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceComponent: Version read existing",
                "id": "X050_DeviceComponent",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Read current version of preexisting DeviceComponent.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceComponent: Previous version read existing",
                "id": "X055_DeviceComponent",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Read previous version of preexisting DeviceComponent.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DeviceComponent: Validate",
                "id": "X060_DeviceComponent",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "DeviceComponent was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceComponent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceComponent: Validate Existing",
                "id": "X065_DeviceComponent",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Existing DeviceComponent was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceComponent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DeviceComponent: Validate against a profile",
                "id": "X067_DeviceComponent",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "DeviceComponent was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceComponent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceComponent: Delete Existing",
                "id": "X070_DeviceComponent",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Existing DeviceComponent was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceComponent: Get Deleted Resource",
                "id": "X075_DeviceComponent",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Deleted DeviceComponent was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0474d4d3261a6220000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:40:52.176-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07fc4d4d3266f8b80200"
        },
        "created_at": {
            "$date": "2015-10-02T18:41:00.021-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DeviceMetric: Read Type",
                "id": "X000_DeviceMetric",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DeviceMetric: Create New",
                "id": "X010_DeviceMetric",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "New DeviceMetric was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DeviceMetric: Read Existing",
                "id": "X020_DeviceMetric",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Successfully read preexisting DeviceMetric.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceMetric: Update Existing",
                "id": "X030_DeviceMetric",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Updated existing DeviceMetric.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceMetric: Read History of existing",
                "id": "X040_DeviceMetric",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceMetric: Version read existing",
                "id": "X050_DeviceMetric",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Read current version of preexisting DeviceMetric.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceMetric: Previous version read existing",
                "id": "X055_DeviceMetric",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Read previous version of preexisting DeviceMetric.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DeviceMetric: Validate",
                "id": "X060_DeviceMetric",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "DeviceMetric was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceMetric"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceMetric: Validate Existing",
                "id": "X065_DeviceMetric",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Existing DeviceMetric was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceMetric"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DeviceMetric: Validate against a profile",
                "id": "X067_DeviceMetric",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "DeviceMetric was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceMetric"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceMetric: Delete Existing",
                "id": "X070_DeviceMetric",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Existing DeviceMetric was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceMetric: Get Deleted Resource",
                "id": "X075_DeviceMetric",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Deleted DeviceMetric was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0474d4d3261a6230000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:41:00.021-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08044d4d3266f8b90200"
        },
        "created_at": {
            "$date": "2015-10-02T18:41:08.683-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DeviceUseRequest: Read Type",
                "id": "X000_DeviceUseRequest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DeviceUseRequest: Create New",
                "id": "X010_DeviceUseRequest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "New DeviceUseRequest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DeviceUseRequest: Read Existing",
                "id": "X020_DeviceUseRequest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Successfully read preexisting DeviceUseRequest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceUseRequest: Update Existing",
                "id": "X030_DeviceUseRequest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Updated existing DeviceUseRequest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceUseRequest: Read History of existing",
                "id": "X040_DeviceUseRequest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceUseRequest: Version read existing",
                "id": "X050_DeviceUseRequest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Read current version of preexisting DeviceUseRequest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceUseRequest: Previous version read existing",
                "id": "X055_DeviceUseRequest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Read previous version of preexisting DeviceUseRequest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DeviceUseRequest: Validate",
                "id": "X060_DeviceUseRequest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "DeviceUseRequest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceUseRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceUseRequest: Validate Existing",
                "id": "X065_DeviceUseRequest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Existing DeviceUseRequest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceUseRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DeviceUseRequest: Validate against a profile",
                "id": "X067_DeviceUseRequest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "DeviceUseRequest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceUseRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceUseRequest: Delete Existing",
                "id": "X070_DeviceUseRequest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Existing DeviceUseRequest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceUseRequest: Get Deleted Resource",
                "id": "X075_DeviceUseRequest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Deleted DeviceUseRequest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0484d4d3261a6240000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:41:08.683-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f080c4d4d3266f8ba0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:41:16.938-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DeviceUseStatement: Read Type",
                "id": "X000_DeviceUseStatement",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DeviceUseStatement: Create New",
                "id": "X010_DeviceUseStatement",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "New DeviceUseStatement was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DeviceUseStatement: Read Existing",
                "id": "X020_DeviceUseStatement",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Successfully read preexisting DeviceUseStatement.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceUseStatement: Update Existing",
                "id": "X030_DeviceUseStatement",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Updated existing DeviceUseStatement.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceUseStatement: Read History of existing",
                "id": "X040_DeviceUseStatement",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceUseStatement: Version read existing",
                "id": "X050_DeviceUseStatement",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Read current version of preexisting DeviceUseStatement.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DeviceUseStatement: Previous version read existing",
                "id": "X055_DeviceUseStatement",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Read previous version of preexisting DeviceUseStatement.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DeviceUseStatement: Validate",
                "id": "X060_DeviceUseStatement",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "DeviceUseStatement was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceUseStatement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceUseStatement: Validate Existing",
                "id": "X065_DeviceUseStatement",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Existing DeviceUseStatement was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceUseStatement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DeviceUseStatement: Validate against a profile",
                "id": "X067_DeviceUseStatement",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "DeviceUseStatement was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DeviceUseStatement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceUseStatement: Delete Existing",
                "id": "X070_DeviceUseStatement",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Existing DeviceUseStatement was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DeviceUseStatement: Get Deleted Resource",
                "id": "X075_DeviceUseStatement",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Deleted DeviceUseStatement was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0484d4d3261a6250000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:41:16.938-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08144d4d3266f8bb0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:41:24.969-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DiagnosticOrder: Read Type",
                "id": "X000_DiagnosticOrder",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DiagnosticOrder: Create New",
                "id": "X010_DiagnosticOrder",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "New DiagnosticOrder was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DiagnosticOrder: Read Existing",
                "id": "X020_DiagnosticOrder",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Successfully read preexisting DiagnosticOrder.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DiagnosticOrder: Update Existing",
                "id": "X030_DiagnosticOrder",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Updated existing DiagnosticOrder.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DiagnosticOrder: Read History of existing",
                "id": "X040_DiagnosticOrder",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DiagnosticOrder: Version read existing",
                "id": "X050_DiagnosticOrder",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Read current version of preexisting DiagnosticOrder.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DiagnosticOrder: Previous version read existing",
                "id": "X055_DiagnosticOrder",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Read previous version of preexisting DiagnosticOrder.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DiagnosticOrder: Validate",
                "id": "X060_DiagnosticOrder",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "DiagnosticOrder was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DiagnosticOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DiagnosticOrder: Validate Existing",
                "id": "X065_DiagnosticOrder",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Existing DiagnosticOrder was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DiagnosticOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DiagnosticOrder: Validate against a profile",
                "id": "X067_DiagnosticOrder",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "DiagnosticOrder was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DiagnosticOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DiagnosticOrder: Delete Existing",
                "id": "X070_DiagnosticOrder",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Existing DiagnosticOrder was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DiagnosticOrder: Get Deleted Resource",
                "id": "X075_DiagnosticOrder",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Deleted DiagnosticOrder was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0484d4d3261a6260000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:41:24.969-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f081e4d4d3266f8bc0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:41:34.282-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DiagnosticReport: Read Type",
                "id": "X000_DiagnosticReport",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DiagnosticReport: Create New",
                "id": "X010_DiagnosticReport",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "New DiagnosticReport was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DiagnosticReport: Read Existing",
                "id": "X020_DiagnosticReport",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Successfully read preexisting DiagnosticReport.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DiagnosticReport: Update Existing",
                "id": "X030_DiagnosticReport",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Updated existing DiagnosticReport.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DiagnosticReport: Read History of existing",
                "id": "X040_DiagnosticReport",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DiagnosticReport: Version read existing",
                "id": "X050_DiagnosticReport",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Read current version of preexisting DiagnosticReport.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DiagnosticReport: Previous version read existing",
                "id": "X055_DiagnosticReport",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Read previous version of preexisting DiagnosticReport.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DiagnosticReport: Validate",
                "id": "X060_DiagnosticReport",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "DiagnosticReport was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DiagnosticReport"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DiagnosticReport: Validate Existing",
                "id": "X065_DiagnosticReport",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Existing DiagnosticReport was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DiagnosticReport"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DiagnosticReport: Validate against a profile",
                "id": "X067_DiagnosticReport",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "DiagnosticReport was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DiagnosticReport"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DiagnosticReport: Delete Existing",
                "id": "X070_DiagnosticReport",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Existing DiagnosticReport was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DiagnosticReport: Get Deleted Resource",
                "id": "X075_DiagnosticReport",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Deleted DiagnosticReport was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0484d4d3261a6270000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:41:34.282-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08254d4d3266f8bd0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:41:41.459-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DocumentManifest: Read Type",
                "id": "X000_DocumentManifest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DocumentManifest: Create New",
                "id": "X010_DocumentManifest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "New DocumentManifest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DocumentManifest: Read Existing",
                "id": "X020_DocumentManifest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Successfully read preexisting DocumentManifest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DocumentManifest: Update Existing",
                "id": "X030_DocumentManifest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Updated existing DocumentManifest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DocumentManifest: Read History of existing",
                "id": "X040_DocumentManifest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DocumentManifest: Version read existing",
                "id": "X050_DocumentManifest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Read current version of preexisting DocumentManifest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DocumentManifest: Previous version read existing",
                "id": "X055_DocumentManifest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Read previous version of preexisting DocumentManifest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DocumentManifest: Validate",
                "id": "X060_DocumentManifest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "DocumentManifest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DocumentManifest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DocumentManifest: Validate Existing",
                "id": "X065_DocumentManifest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Existing DocumentManifest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DocumentManifest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DocumentManifest: Validate against a profile",
                "id": "X067_DocumentManifest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "DocumentManifest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DocumentManifest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DocumentManifest: Delete Existing",
                "id": "X070_DocumentManifest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Existing DocumentManifest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DocumentManifest: Get Deleted Resource",
                "id": "X075_DocumentManifest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Deleted DocumentManifest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0484d4d3261a6280000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:41:41.459-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f082f4d4d3266f8be0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:41:51.028-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "DocumentReference: Read Type",
                "id": "X000_DocumentReference",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "DocumentReference: Create New",
                "id": "X010_DocumentReference",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "New DocumentReference was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "DocumentReference: Read Existing",
                "id": "X020_DocumentReference",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Successfully read preexisting DocumentReference.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DocumentReference: Update Existing",
                "id": "X030_DocumentReference",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Updated existing DocumentReference.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "DocumentReference: Read History of existing",
                "id": "X040_DocumentReference",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DocumentReference: Version read existing",
                "id": "X050_DocumentReference",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Read current version of preexisting DocumentReference.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "DocumentReference: Previous version read existing",
                "id": "X055_DocumentReference",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Read previous version of preexisting DocumentReference.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DocumentReference: Validate",
                "id": "X060_DocumentReference",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "DocumentReference was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DocumentReference"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DocumentReference: Validate Existing",
                "id": "X065_DocumentReference",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Existing DocumentReference was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DocumentReference"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "DocumentReference: Validate against a profile",
                "id": "X067_DocumentReference",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "DocumentReference was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "DocumentReference"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DocumentReference: Delete Existing",
                "id": "X070_DocumentReference",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Existing DocumentReference was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "DocumentReference: Get Deleted Resource",
                "id": "X075_DocumentReference",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Deleted DocumentReference was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0484d4d3261a6290000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:41:51.028-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08374d4d3266f8bf0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:41:59.822-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "EligibilityRequest: Read Type",
                "id": "X000_EligibilityRequest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "EligibilityRequest: Create New",
                "id": "X010_EligibilityRequest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "New EligibilityRequest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "EligibilityRequest: Read Existing",
                "id": "X020_EligibilityRequest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Successfully read preexisting EligibilityRequest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EligibilityRequest: Update Existing",
                "id": "X030_EligibilityRequest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Updated existing EligibilityRequest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "EligibilityRequest: Read History of existing",
                "id": "X040_EligibilityRequest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EligibilityRequest: Version read existing",
                "id": "X050_EligibilityRequest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Read current version of preexisting EligibilityRequest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EligibilityRequest: Previous version read existing",
                "id": "X055_EligibilityRequest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Read previous version of preexisting EligibilityRequest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EligibilityRequest: Validate",
                "id": "X060_EligibilityRequest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "EligibilityRequest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EligibilityRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EligibilityRequest: Validate Existing",
                "id": "X065_EligibilityRequest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Existing EligibilityRequest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EligibilityRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EligibilityRequest: Validate against a profile",
                "id": "X067_EligibilityRequest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "EligibilityRequest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EligibilityRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EligibilityRequest: Delete Existing",
                "id": "X070_EligibilityRequest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Existing EligibilityRequest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EligibilityRequest: Get Deleted Resource",
                "id": "X075_EligibilityRequest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Deleted EligibilityRequest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0484d4d3261a62a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:41:59.822-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f083f4d4d3266f8c00200"
        },
        "created_at": {
            "$date": "2015-10-02T18:42:07.595-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "EligibilityResponse: Read Type",
                "id": "X000_EligibilityResponse",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "EligibilityResponse: Create New",
                "id": "X010_EligibilityResponse",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "New EligibilityResponse was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "EligibilityResponse: Read Existing",
                "id": "X020_EligibilityResponse",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Successfully read preexisting EligibilityResponse.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EligibilityResponse: Update Existing",
                "id": "X030_EligibilityResponse",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Updated existing EligibilityResponse.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "EligibilityResponse: Read History of existing",
                "id": "X040_EligibilityResponse",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EligibilityResponse: Version read existing",
                "id": "X050_EligibilityResponse",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Read current version of preexisting EligibilityResponse.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EligibilityResponse: Previous version read existing",
                "id": "X055_EligibilityResponse",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Read previous version of preexisting EligibilityResponse.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EligibilityResponse: Validate",
                "id": "X060_EligibilityResponse",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "EligibilityResponse was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EligibilityResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EligibilityResponse: Validate Existing",
                "id": "X065_EligibilityResponse",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Existing EligibilityResponse was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EligibilityResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EligibilityResponse: Validate against a profile",
                "id": "X067_EligibilityResponse",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "EligibilityResponse was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EligibilityResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EligibilityResponse: Delete Existing",
                "id": "X070_EligibilityResponse",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Existing EligibilityResponse was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EligibilityResponse: Get Deleted Resource",
                "id": "X075_EligibilityResponse",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Deleted EligibilityResponse was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0494d4d3261a62b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:42:07.595-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08474d4d3266f8c10200"
        },
        "created_at": {
            "$date": "2015-10-02T18:42:15.939-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Encounter: Read Type",
                "id": "X000_Encounter",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Encounter: Create New",
                "id": "X010_Encounter",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "New Encounter was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Encounter: Read Existing",
                "id": "X020_Encounter",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Successfully read preexisting Encounter.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Encounter: Update Existing",
                "id": "X030_Encounter",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Updated existing Encounter.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Encounter: Read History of existing",
                "id": "X040_Encounter",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Encounter: Version read existing",
                "id": "X050_Encounter",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Read current version of preexisting Encounter.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Encounter: Previous version read existing",
                "id": "X055_Encounter",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Read previous version of preexisting Encounter.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Encounter: Validate",
                "id": "X060_Encounter",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Encounter was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Encounter"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Encounter: Validate Existing",
                "id": "X065_Encounter",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Existing Encounter was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Encounter"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Encounter: Validate against a profile",
                "id": "X067_Encounter",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Encounter was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Encounter"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Encounter: Delete Existing",
                "id": "X070_Encounter",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Existing Encounter was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Encounter: Get Deleted Resource",
                "id": "X075_Encounter",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Deleted Encounter was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Encounter"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0494d4d3261a62c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:42:15.939-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f084f4d4d3266f8c20200"
        },
        "created_at": {
            "$date": "2015-10-02T18:42:23.157-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "EnrollmentRequest: Read Type",
                "id": "X000_EnrollmentRequest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "EnrollmentRequest: Create New",
                "id": "X010_EnrollmentRequest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "New EnrollmentRequest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "EnrollmentRequest: Read Existing",
                "id": "X020_EnrollmentRequest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Successfully read preexisting EnrollmentRequest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EnrollmentRequest: Update Existing",
                "id": "X030_EnrollmentRequest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Updated existing EnrollmentRequest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "EnrollmentRequest: Read History of existing",
                "id": "X040_EnrollmentRequest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EnrollmentRequest: Version read existing",
                "id": "X050_EnrollmentRequest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Read current version of preexisting EnrollmentRequest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EnrollmentRequest: Previous version read existing",
                "id": "X055_EnrollmentRequest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Read previous version of preexisting EnrollmentRequest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EnrollmentRequest: Validate",
                "id": "X060_EnrollmentRequest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "EnrollmentRequest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EnrollmentRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EnrollmentRequest: Validate Existing",
                "id": "X065_EnrollmentRequest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Existing EnrollmentRequest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EnrollmentRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EnrollmentRequest: Validate against a profile",
                "id": "X067_EnrollmentRequest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "EnrollmentRequest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EnrollmentRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EnrollmentRequest: Delete Existing",
                "id": "X070_EnrollmentRequest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Existing EnrollmentRequest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EnrollmentRequest: Get Deleted Resource",
                "id": "X075_EnrollmentRequest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Deleted EnrollmentRequest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0494d4d3261a62d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:42:23.157-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08564d4d3266f8c30200"
        },
        "created_at": {
            "$date": "2015-10-02T18:42:30.437-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "EnrollmentResponse: Read Type",
                "id": "X000_EnrollmentResponse",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "EnrollmentResponse: Create New",
                "id": "X010_EnrollmentResponse",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "New EnrollmentResponse was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "EnrollmentResponse: Read Existing",
                "id": "X020_EnrollmentResponse",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Successfully read preexisting EnrollmentResponse.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EnrollmentResponse: Update Existing",
                "id": "X030_EnrollmentResponse",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Updated existing EnrollmentResponse.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "EnrollmentResponse: Read History of existing",
                "id": "X040_EnrollmentResponse",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EnrollmentResponse: Version read existing",
                "id": "X050_EnrollmentResponse",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Read current version of preexisting EnrollmentResponse.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EnrollmentResponse: Previous version read existing",
                "id": "X055_EnrollmentResponse",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Read previous version of preexisting EnrollmentResponse.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EnrollmentResponse: Validate",
                "id": "X060_EnrollmentResponse",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "EnrollmentResponse was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EnrollmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EnrollmentResponse: Validate Existing",
                "id": "X065_EnrollmentResponse",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Existing EnrollmentResponse was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EnrollmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EnrollmentResponse: Validate against a profile",
                "id": "X067_EnrollmentResponse",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "EnrollmentResponse was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EnrollmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EnrollmentResponse: Delete Existing",
                "id": "X070_EnrollmentResponse",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Existing EnrollmentResponse was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EnrollmentResponse: Get Deleted Resource",
                "id": "X075_EnrollmentResponse",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Deleted EnrollmentResponse was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0494d4d3261a62e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:42:30.437-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f085d4d4d3266f8c40200"
        },
        "created_at": {
            "$date": "2015-10-02T18:42:37.467-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "EpisodeOfCare: Read Type",
                "id": "X000_EpisodeOfCare",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "EpisodeOfCare: Create New",
                "id": "X010_EpisodeOfCare",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "New EpisodeOfCare was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "EpisodeOfCare: Read Existing",
                "id": "X020_EpisodeOfCare",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Successfully read preexisting EpisodeOfCare.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EpisodeOfCare: Update Existing",
                "id": "X030_EpisodeOfCare",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Updated existing EpisodeOfCare.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "EpisodeOfCare: Read History of existing",
                "id": "X040_EpisodeOfCare",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EpisodeOfCare: Version read existing",
                "id": "X050_EpisodeOfCare",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Read current version of preexisting EpisodeOfCare.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "EpisodeOfCare: Previous version read existing",
                "id": "X055_EpisodeOfCare",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Read previous version of preexisting EpisodeOfCare.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EpisodeOfCare: Validate",
                "id": "X060_EpisodeOfCare",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "EpisodeOfCare was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EpisodeOfCare"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EpisodeOfCare: Validate Existing",
                "id": "X065_EpisodeOfCare",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Existing EpisodeOfCare was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EpisodeOfCare"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "EpisodeOfCare: Validate against a profile",
                "id": "X067_EpisodeOfCare",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "EpisodeOfCare was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "EpisodeOfCare"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EpisodeOfCare: Delete Existing",
                "id": "X070_EpisodeOfCare",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Existing EpisodeOfCare was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "EpisodeOfCare: Get Deleted Resource",
                "id": "X075_EpisodeOfCare",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Deleted EpisodeOfCare was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0494d4d3261a62f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:42:37.467-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08644d4d3266f8c50200"
        },
        "created_at": {
            "$date": "2015-10-02T18:42:44.162-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ExplanationOfBenefit: Read Type",
                "id": "X000_ExplanationOfBenefit",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Create New",
                "id": "X010_ExplanationOfBenefit",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "New ExplanationOfBenefit was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Read Existing",
                "id": "X020_ExplanationOfBenefit",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Successfully read preexisting ExplanationOfBenefit.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Update Existing",
                "id": "X030_ExplanationOfBenefit",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Updated existing ExplanationOfBenefit.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Read History of existing",
                "id": "X040_ExplanationOfBenefit",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Version read existing",
                "id": "X050_ExplanationOfBenefit",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Read current version of preexisting ExplanationOfBenefit.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Previous version read existing",
                "id": "X055_ExplanationOfBenefit",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Read previous version of preexisting ExplanationOfBenefit.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Validate",
                "id": "X060_ExplanationOfBenefit",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "ExplanationOfBenefit was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ExplanationOfBenefit"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Validate Existing",
                "id": "X065_ExplanationOfBenefit",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Existing ExplanationOfBenefit was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ExplanationOfBenefit"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Validate against a profile",
                "id": "X067_ExplanationOfBenefit",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "ExplanationOfBenefit was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ExplanationOfBenefit"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Delete Existing",
                "id": "X070_ExplanationOfBenefit",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Existing ExplanationOfBenefit was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ExplanationOfBenefit: Get Deleted Resource",
                "id": "X075_ExplanationOfBenefit",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Deleted ExplanationOfBenefit was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0494d4d3261a6300000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:42:44.162-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f086b4d4d3266f8c60200"
        },
        "created_at": {
            "$date": "2015-10-02T18:42:51.625-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "FamilyMemberHistory: Read Type",
                "id": "X000_FamilyMemberHistory",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "FamilyMemberHistory: Create New",
                "id": "X010_FamilyMemberHistory",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "New FamilyMemberHistory was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "FamilyMemberHistory: Read Existing",
                "id": "X020_FamilyMemberHistory",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Successfully read preexisting FamilyMemberHistory.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "FamilyMemberHistory: Update Existing",
                "id": "X030_FamilyMemberHistory",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Updated existing FamilyMemberHistory.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "FamilyMemberHistory: Read History of existing",
                "id": "X040_FamilyMemberHistory",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "FamilyMemberHistory: Version read existing",
                "id": "X050_FamilyMemberHistory",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Read current version of preexisting FamilyMemberHistory.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "FamilyMemberHistory: Previous version read existing",
                "id": "X055_FamilyMemberHistory",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Read previous version of preexisting FamilyMemberHistory.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "FamilyMemberHistory: Validate",
                "id": "X060_FamilyMemberHistory",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "FamilyMemberHistory was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "FamilyMemberHistory"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "FamilyMemberHistory: Validate Existing",
                "id": "X065_FamilyMemberHistory",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Existing FamilyMemberHistory was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "FamilyMemberHistory"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "FamilyMemberHistory: Validate against a profile",
                "id": "X067_FamilyMemberHistory",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "FamilyMemberHistory was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "FamilyMemberHistory"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "FamilyMemberHistory: Delete Existing",
                "id": "X070_FamilyMemberHistory",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Existing FamilyMemberHistory was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "FamilyMemberHistory: Get Deleted Resource",
                "id": "X075_FamilyMemberHistory",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Deleted FamilyMemberHistory was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0494d4d3261a6310000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:42:51.625-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08734d4d3266f8c70200"
        },
        "created_at": {
            "$date": "2015-10-02T18:42:59.243-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Flag: Read Type",
                "id": "X000_Flag",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Flag: Create New",
                "id": "X010_Flag",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "New Flag was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Flag: Read Existing",
                "id": "X020_Flag",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Successfully read preexisting Flag.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Flag: Update Existing",
                "id": "X030_Flag",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Updated existing Flag.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Flag: Read History of existing",
                "id": "X040_Flag",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Flag: Version read existing",
                "id": "X050_Flag",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Read current version of preexisting Flag.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Flag: Previous version read existing",
                "id": "X055_Flag",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Read previous version of preexisting Flag.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Flag: Validate",
                "id": "X060_Flag",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Flag was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Flag"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Flag: Validate Existing",
                "id": "X065_Flag",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Existing Flag was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Flag"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Flag: Validate against a profile",
                "id": "X067_Flag",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Flag was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Flag"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Flag: Delete Existing",
                "id": "X070_Flag",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Existing Flag was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Flag: Get Deleted Resource",
                "id": "X075_Flag",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Deleted Flag was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Flag"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04a4d4d3261a6320000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:42:59.243-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f087a4d4d3266f8c80200"
        },
        "created_at": {
            "$date": "2015-10-02T18:43:06.889-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Goal: Read Type",
                "id": "X000_Goal",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Goal: Create New",
                "id": "X010_Goal",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "New Goal was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Goal: Read Existing",
                "id": "X020_Goal",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Successfully read preexisting Goal.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Goal: Update Existing",
                "id": "X030_Goal",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Updated existing Goal.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Goal: Read History of existing",
                "id": "X040_Goal",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Goal: Version read existing",
                "id": "X050_Goal",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Read current version of preexisting Goal.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Goal: Previous version read existing",
                "id": "X055_Goal",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Read previous version of preexisting Goal.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Goal: Validate",
                "id": "X060_Goal",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Goal was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Goal"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Goal: Validate Existing",
                "id": "X065_Goal",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Existing Goal was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Goal"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Goal: Validate against a profile",
                "id": "X067_Goal",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Goal was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Goal"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Goal: Delete Existing",
                "id": "X070_Goal",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Existing Goal was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Goal: Get Deleted Resource",
                "id": "X075_Goal",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Deleted Goal was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Goal"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04a4d4d3261a6330000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:43:06.889-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08834d4d3266f8c90200"
        },
        "created_at": {
            "$date": "2015-10-02T18:43:15.214-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Group: Read Type",
                "id": "X000_Group",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Group: Create New",
                "id": "X010_Group",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "New Group was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Group: Read Existing",
                "id": "X020_Group",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Successfully read preexisting Group.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Group: Update Existing",
                "id": "X030_Group",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Updated existing Group.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Group: Read History of existing",
                "id": "X040_Group",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Group: Version read existing",
                "id": "X050_Group",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Read current version of preexisting Group.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Group: Previous version read existing",
                "id": "X055_Group",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Read previous version of preexisting Group.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Group: Validate",
                "id": "X060_Group",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Group was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Group"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Group: Validate Existing",
                "id": "X065_Group",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Existing Group was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Group"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Group: Validate against a profile",
                "id": "X067_Group",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Group was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Group"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Group: Delete Existing",
                "id": "X070_Group",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Existing Group was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Group: Get Deleted Resource",
                "id": "X075_Group",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Deleted Group was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Group"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04a4d4d3261a6340000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:43:15.214-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f088d4d4d3266f8ca0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:43:25.625-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "HealthcareService: Read Type",
                "id": "X000_HealthcareService",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "HealthcareService: Create New",
                "id": "X010_HealthcareService",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "New HealthcareService was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "HealthcareService: Read Existing",
                "id": "X020_HealthcareService",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Successfully read preexisting HealthcareService.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "HealthcareService: Update Existing",
                "id": "X030_HealthcareService",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Updated existing HealthcareService.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "HealthcareService: Read History of existing",
                "id": "X040_HealthcareService",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "HealthcareService: Version read existing",
                "id": "X050_HealthcareService",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Read current version of preexisting HealthcareService.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "HealthcareService: Previous version read existing",
                "id": "X055_HealthcareService",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Read previous version of preexisting HealthcareService.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "HealthcareService: Validate",
                "id": "X060_HealthcareService",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "HealthcareService was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "HealthcareService"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "HealthcareService: Validate Existing",
                "id": "X065_HealthcareService",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Existing HealthcareService was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "HealthcareService"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "HealthcareService: Validate against a profile",
                "id": "X067_HealthcareService",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "HealthcareService was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "HealthcareService"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "HealthcareService: Delete Existing",
                "id": "X070_HealthcareService",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Existing HealthcareService was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "HealthcareService: Get Deleted Resource",
                "id": "X075_HealthcareService",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Deleted HealthcareService was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04a4d4d3261a6350000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:43:25.625-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08954d4d3266f8cb0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:43:33.742-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'identifier'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>",
                "description": "ImagingObjectSelection: Read Type",
                "id": "X000_ImagingObjectSelection",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Expected FHIR Bundle but found: OperationOutcome",
                "status": "fail",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.&lt;GetElementFunction&gt;b__1[TResult](IEnumerable`1 sequence)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.ExecuteSingle[TResult](IEnumerable`1 query, Expression queryRoot)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.System.Linq.IQueryProvider.Execute[TResult](Expression expression)&#xD;&#xA;   at System.Data.Entity.Internal.Linq.DbQueryProvider.Execute[TResult](Expression expression)&#xD;&#xA;   at System.Linq.Queryable.FirstOrDefault[TSource](IQueryable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1888&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'identifier'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>",
                "description": "ImagingObjectSelection: Create New",
                "id": "X010_ImagingObjectSelection",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": [
                    "error: : EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.",
                    "information: :    at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\r\n   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<>c__DisplayClass7.<GetResults>b__6()\r\n   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<>c__DisplayClass7.<GetResults>b__5()\r\n   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<System.Collections.Generic.IEnumerable<T>.GetEnumerator>b__0()\r\n   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()\r\n   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.<GetElementFunction>b__1[TResult](IEnumerable`1 sequence)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.ExecuteSingle[TResult](IEnumerable`1 query, Expression queryRoot)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.System.Linq.IQueryProvider.Execute[TResult](Expression expression)\r\n   at System.Data.Entity.Internal.Linq.DbQueryProvider.Execute[TResult](Expression expression)\r\n   at System.Linq.Queryable.FirstOrDefault[TSource](IQueryable`1 source)\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1888\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806\r\n   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672\r\n   at lambda_method(Closure , Object , Object[] )\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.<>c__DisplayClass10.<GetExecutor>b__9(Object instance, Object[] methodParameters)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.<InvokeActionAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.<ExecuteAsync>d__2.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ExceptionFilterResult.<ExecuteAsync>d__0.MoveNext()",
                    "error: : SqlException: Invalid column name 'identifier'.",
                    "information: :    at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\r\n   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\r\n   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)\r\n   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean& dataReady)\r\n   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()\r\n   at System.Data.SqlClient.SqlDataReader.get_MetaData()\r\n   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task& task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task& task, Boolean asyncWrite)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)\r\n   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)\r\n   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)\r\n   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)\r\n   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.<Reader>b__c(DbCommand t, DbCommandInterceptionContext`1 c)\r\n   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)\r\n   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)\r\n   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)\r\n   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)\r\n   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)"
                ],
                "status": "fail",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "data": null,
                "description": "ImagingObjectSelection: Read Existing",
                "id": "X020_ImagingObjectSelection",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Preexisting ImagingObjectSelection unknown.",
                "status": "fail",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": null,
                "description": "ImagingObjectSelection: Update Existing",
                "id": "X030_ImagingObjectSelection",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Unable to update -- existing ImagingObjectSelection is not available or was not valid.",
                "status": "skip",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "data": null,
                "description": "ImagingObjectSelection: Read History of existing",
                "id": "X040_ImagingObjectSelection",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Preexisting ImagingObjectSelection unknown.",
                "status": "skip",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "data": null,
                "description": "ImagingObjectSelection: Version read existing",
                "id": "X050_ImagingObjectSelection",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Preexisting ImagingObjectSelection unknown.",
                "status": "skip",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "data": null,
                "description": "ImagingObjectSelection: Previous version read existing",
                "id": "X055_ImagingObjectSelection",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Previous version of ImagingObjectSelection unavailable.",
                "status": "skip",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ImagingObjectSelection: Validate",
                "id": "X060_ImagingObjectSelection",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "ImagingObjectSelection was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImagingObjectSelection"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImagingObjectSelection: Validate Existing",
                "id": "X065_ImagingObjectSelection",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Existing ImagingObjectSelection was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImagingObjectSelection"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ImagingObjectSelection: Validate against a profile",
                "id": "X067_ImagingObjectSelection",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "ImagingObjectSelection was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImagingObjectSelection"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": null,
                "description": "ImagingObjectSelection: Delete Existing",
                "id": "X070_ImagingObjectSelection",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Preexisting ImagingObjectSelection unknown.",
                "status": "skip",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": null,
                "description": "ImagingObjectSelection: Get Deleted Resource",
                "id": "X075_ImagingObjectSelection",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Skipped: x075_get_deleted_resource_test",
                "status": "skip",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04a4d4d3261a6360000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:43:33.742-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f089c4d4d3266f8cc0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:43:40.721-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'study'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>",
                "description": "ImagingStudy: Read Type",
                "id": "X000_ImagingStudy",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Expected FHIR Bundle but found: OperationOutcome",
                "status": "fail",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.&lt;GetElementFunction&gt;b__1[TResult](IEnumerable`1 sequence)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.ExecuteSingle[TResult](IEnumerable`1 query, Expression queryRoot)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.System.Linq.IQueryProvider.Execute[TResult](Expression expression)&#xD;&#xA;   at System.Data.Entity.Internal.Linq.DbQueryProvider.Execute[TResult](Expression expression)&#xD;&#xA;   at System.Linq.Queryable.FirstOrDefault[TSource](IQueryable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1888&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'study'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>",
                "description": "ImagingStudy: Create New",
                "id": "X010_ImagingStudy",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": [
                    "error: : EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.",
                    "information: :    at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\r\n   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<>c__DisplayClass7.<GetResults>b__6()\r\n   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<>c__DisplayClass7.<GetResults>b__5()\r\n   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<System.Collections.Generic.IEnumerable<T>.GetEnumerator>b__0()\r\n   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()\r\n   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.<GetElementFunction>b__1[TResult](IEnumerable`1 sequence)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.ExecuteSingle[TResult](IEnumerable`1 query, Expression queryRoot)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.System.Linq.IQueryProvider.Execute[TResult](Expression expression)\r\n   at System.Data.Entity.Internal.Linq.DbQueryProvider.Execute[TResult](Expression expression)\r\n   at System.Linq.Queryable.FirstOrDefault[TSource](IQueryable`1 source)\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1888\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806\r\n   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672\r\n   at lambda_method(Closure , Object , Object[] )\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.<>c__DisplayClass10.<GetExecutor>b__9(Object instance, Object[] methodParameters)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.<InvokeActionAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.<ExecuteAsync>d__2.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ExceptionFilterResult.<ExecuteAsync>d__0.MoveNext()",
                    "error: : SqlException: Invalid column name 'study'.",
                    "information: :    at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\r\n   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\r\n   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)\r\n   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean& dataReady)\r\n   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()\r\n   at System.Data.SqlClient.SqlDataReader.get_MetaData()\r\n   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task& task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task& task, Boolean asyncWrite)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)\r\n   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)\r\n   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)\r\n   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)\r\n   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.<Reader>b__c(DbCommand t, DbCommandInterceptionContext`1 c)\r\n   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)\r\n   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)\r\n   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)\r\n   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)\r\n   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)"
                ],
                "status": "fail",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "data": null,
                "description": "ImagingStudy: Read Existing",
                "id": "X020_ImagingStudy",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Preexisting ImagingStudy unknown.",
                "status": "fail",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": null,
                "description": "ImagingStudy: Update Existing",
                "id": "X030_ImagingStudy",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Unable to update -- existing ImagingStudy is not available or was not valid.",
                "status": "skip",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "data": null,
                "description": "ImagingStudy: Read History of existing",
                "id": "X040_ImagingStudy",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Preexisting ImagingStudy unknown.",
                "status": "skip",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "data": null,
                "description": "ImagingStudy: Version read existing",
                "id": "X050_ImagingStudy",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Preexisting ImagingStudy unknown.",
                "status": "skip",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "data": null,
                "description": "ImagingStudy: Previous version read existing",
                "id": "X055_ImagingStudy",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Previous version of ImagingStudy unavailable.",
                "status": "skip",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ImagingStudy: Validate",
                "id": "X060_ImagingStudy",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "ImagingStudy was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImagingStudy"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImagingStudy: Validate Existing",
                "id": "X065_ImagingStudy",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Existing ImagingStudy was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImagingStudy"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ImagingStudy: Validate against a profile",
                "id": "X067_ImagingStudy",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "ImagingStudy was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImagingStudy"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": null,
                "description": "ImagingStudy: Delete Existing",
                "id": "X070_ImagingStudy",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Preexisting ImagingStudy unknown.",
                "status": "skip",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": null,
                "description": "ImagingStudy: Get Deleted Resource",
                "id": "X075_ImagingStudy",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Skipped: x075_get_deleted_resource_test",
                "status": "skip",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04a4d4d3261a6370000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:43:40.721-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08a44d4d3266f8cd0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:43:48.020-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Immunization: Read Type",
                "id": "X000_Immunization",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Immunization: Create New",
                "id": "X010_Immunization",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "New Immunization was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Immunization: Read Existing",
                "id": "X020_Immunization",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Successfully read preexisting Immunization.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Immunization: Update Existing",
                "id": "X030_Immunization",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Updated existing Immunization.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Immunization: Read History of existing",
                "id": "X040_Immunization",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Immunization: Version read existing",
                "id": "X050_Immunization",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Read current version of preexisting Immunization.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Immunization: Previous version read existing",
                "id": "X055_Immunization",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Read previous version of preexisting Immunization.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Immunization: Validate",
                "id": "X060_Immunization",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Immunization was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Immunization"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Immunization: Validate Existing",
                "id": "X065_Immunization",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Existing Immunization was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Immunization"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Immunization: Validate against a profile",
                "id": "X067_Immunization",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Immunization was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Immunization"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Immunization: Delete Existing",
                "id": "X070_Immunization",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Existing Immunization was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Immunization: Get Deleted Resource",
                "id": "X075_Immunization",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Deleted Immunization was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Immunization"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04a4d4d3261a6380000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:43:48.020-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08ab4d4d3266f8ce0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:43:55.184-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ImmunizationRecommendation: Read Type",
                "id": "X000_ImmunizationRecommendation",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Create New",
                "id": "X010_ImmunizationRecommendation",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "New ImmunizationRecommendation was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Read Existing",
                "id": "X020_ImmunizationRecommendation",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Successfully read preexisting ImmunizationRecommendation.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Update Existing",
                "id": "X030_ImmunizationRecommendation",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Updated existing ImmunizationRecommendation.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Read History of existing",
                "id": "X040_ImmunizationRecommendation",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Version read existing",
                "id": "X050_ImmunizationRecommendation",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Read current version of preexisting ImmunizationRecommendation.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Previous version read existing",
                "id": "X055_ImmunizationRecommendation",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Read previous version of preexisting ImmunizationRecommendation.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Validate",
                "id": "X060_ImmunizationRecommendation",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "ImmunizationRecommendation was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImmunizationRecommendation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Validate Existing",
                "id": "X065_ImmunizationRecommendation",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Existing ImmunizationRecommendation was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImmunizationRecommendation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Validate against a profile",
                "id": "X067_ImmunizationRecommendation",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "ImmunizationRecommendation was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImmunizationRecommendation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Delete Existing",
                "id": "X070_ImmunizationRecommendation",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Existing ImmunizationRecommendation was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImmunizationRecommendation: Get Deleted Resource",
                "id": "X075_ImmunizationRecommendation",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Deleted ImmunizationRecommendation was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04a4d4d3261a6390000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:43:55.184-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08b14d4d3266f8cf0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:44:01.604-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ImplementationGuide: Read Type",
                "id": "X000_ImplementationGuide",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ImplementationGuide: Create New",
                "id": "X010_ImplementationGuide",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "New ImplementationGuide was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ImplementationGuide: Read Existing",
                "id": "X020_ImplementationGuide",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Successfully read preexisting ImplementationGuide.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImplementationGuide: Update Existing",
                "id": "X030_ImplementationGuide",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Updated existing ImplementationGuide.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ImplementationGuide: Read History of existing",
                "id": "X040_ImplementationGuide",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ImplementationGuide: Version read existing",
                "id": "X050_ImplementationGuide",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Read current version of preexisting ImplementationGuide.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ImplementationGuide: Previous version read existing",
                "id": "X055_ImplementationGuide",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Read previous version of preexisting ImplementationGuide.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ImplementationGuide: Validate",
                "id": "X060_ImplementationGuide",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "ImplementationGuide was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImplementationGuide"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImplementationGuide: Validate Existing",
                "id": "X065_ImplementationGuide",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Existing ImplementationGuide was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImplementationGuide"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ImplementationGuide: Validate against a profile",
                "id": "X067_ImplementationGuide",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "ImplementationGuide was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ImplementationGuide"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImplementationGuide: Delete Existing",
                "id": "X070_ImplementationGuide",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Existing ImplementationGuide was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ImplementationGuide: Get Deleted Resource",
                "id": "X075_ImplementationGuide",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Deleted ImplementationGuide was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04b4d4d3261a63a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:44:01.604-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08be4d4d3266f8d00200"
        },
        "created_at": {
            "$date": "2015-10-02T18:44:14.224-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "List: Read Type",
                "id": "X000_List",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "List: Create New",
                "id": "X010_List",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "New List was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "List: Read Existing",
                "id": "X020_List",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Successfully read preexisting List.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "List: Update Existing",
                "id": "X030_List",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Updated existing List.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "List: Read History of existing",
                "id": "X040_List",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "List: Version read existing",
                "id": "X050_List",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Read current version of preexisting List.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "List: Previous version read existing",
                "id": "X055_List",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Read previous version of preexisting List.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "List: Validate",
                "id": "X060_List",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "List was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "List"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "List: Validate Existing",
                "id": "X065_List",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Existing List was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "List"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "List: Validate against a profile",
                "id": "X067_List",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "List was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "List"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "List: Delete Existing",
                "id": "X070_List",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Existing List was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "List: Get Deleted Resource",
                "id": "X075_List",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Deleted List was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "List"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04b4d4d3261a63b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:44:14.224-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08c64d4d3266f8d10200"
        },
        "created_at": {
            "$date": "2015-10-02T18:44:22.948-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Location: Read Type",
                "id": "X000_Location",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Location: Create New",
                "id": "X010_Location",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "New Location was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Location: Read Existing",
                "id": "X020_Location",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Successfully read preexisting Location.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Location: Update Existing",
                "id": "X030_Location",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Updated existing Location.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Location: Read History of existing",
                "id": "X040_Location",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Location: Version read existing",
                "id": "X050_Location",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Read current version of preexisting Location.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Location: Previous version read existing",
                "id": "X055_Location",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Read previous version of preexisting Location.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Location: Validate",
                "id": "X060_Location",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Location was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Location"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Location: Validate Existing",
                "id": "X065_Location",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Existing Location was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Location"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Location: Validate against a profile",
                "id": "X067_Location",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Location was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Location"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Location: Delete Existing",
                "id": "X070_Location",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Existing Location was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Location: Get Deleted Resource",
                "id": "X075_Location",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Deleted Location was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Location"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04b4d4d3261a63c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:44:22.948-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08cf4d4d3266f8d20200"
        },
        "created_at": {
            "$date": "2015-10-02T18:44:31.050-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Media: Read Type",
                "id": "X000_Media",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Media: Create New",
                "id": "X010_Media",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "New Media was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Media: Read Existing",
                "id": "X020_Media",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Successfully read preexisting Media.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Media: Update Existing",
                "id": "X030_Media",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Updated existing Media.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Media: Read History of existing",
                "id": "X040_Media",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Media: Version read existing",
                "id": "X050_Media",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Read current version of preexisting Media.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Media: Previous version read existing",
                "id": "X055_Media",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Read previous version of preexisting Media.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Media: Validate",
                "id": "X060_Media",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Media was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Media"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Media: Validate Existing",
                "id": "X065_Media",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Existing Media was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Media"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Media: Validate against a profile",
                "id": "X067_Media",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Media was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Media"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Media: Delete Existing",
                "id": "X070_Media",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Existing Media was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Media: Get Deleted Resource",
                "id": "X075_Media",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Deleted Media was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Media"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04b4d4d3261a63d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:44:31.050-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08d74d4d3266f8d30200"
        },
        "created_at": {
            "$date": "2015-10-02T18:44:39.622-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Medication: Read Type",
                "id": "X000_Medication",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Medication: Create New",
                "id": "X010_Medication",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "New Medication was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Medication: Read Existing",
                "id": "X020_Medication",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Successfully read preexisting Medication.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Medication: Update Existing",
                "id": "X030_Medication",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Updated existing Medication.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Medication: Read History of existing",
                "id": "X040_Medication",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Medication: Version read existing",
                "id": "X050_Medication",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Read current version of preexisting Medication.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Medication: Previous version read existing",
                "id": "X055_Medication",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Read previous version of preexisting Medication.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Medication: Validate",
                "id": "X060_Medication",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Medication was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Medication"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Medication: Validate Existing",
                "id": "X065_Medication",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Existing Medication was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Medication"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Medication: Validate against a profile",
                "id": "X067_Medication",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Medication was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Medication"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Medication: Delete Existing",
                "id": "X070_Medication",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Existing Medication was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Medication: Get Deleted Resource",
                "id": "X075_Medication",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Deleted Medication was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Medication"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04b4d4d3261a63e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:44:39.622-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08de4d4d3266f8d40200"
        },
        "created_at": {
            "$date": "2015-10-02T18:44:46.985-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "MedicationAdministration: Read Type",
                "id": "X000_MedicationAdministration",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "MedicationAdministration: Create New",
                "id": "X010_MedicationAdministration",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "New MedicationAdministration was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "MedicationAdministration: Read Existing",
                "id": "X020_MedicationAdministration",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Successfully read preexisting MedicationAdministration.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationAdministration: Update Existing",
                "id": "X030_MedicationAdministration",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Updated existing MedicationAdministration.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationAdministration: Read History of existing",
                "id": "X040_MedicationAdministration",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationAdministration: Version read existing",
                "id": "X050_MedicationAdministration",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Read current version of preexisting MedicationAdministration.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationAdministration: Previous version read existing",
                "id": "X055_MedicationAdministration",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Read previous version of preexisting MedicationAdministration.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MedicationAdministration: Validate",
                "id": "X060_MedicationAdministration",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "MedicationAdministration was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationAdministration"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationAdministration: Validate Existing",
                "id": "X065_MedicationAdministration",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Existing MedicationAdministration was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationAdministration"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MedicationAdministration: Validate against a profile",
                "id": "X067_MedicationAdministration",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "MedicationAdministration was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationAdministration"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationAdministration: Delete Existing",
                "id": "X070_MedicationAdministration",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Existing MedicationAdministration was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationAdministration: Get Deleted Resource",
                "id": "X075_MedicationAdministration",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Deleted MedicationAdministration was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04b4d4d3261a63f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:44:46.985-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08e94d4d3266f8d50200"
        },
        "created_at": {
            "$date": "2015-10-02T18:44:57.533-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "MedicationDispense: Read Type",
                "id": "X000_MedicationDispense",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "MedicationDispense: Create New",
                "id": "X010_MedicationDispense",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "New MedicationDispense was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "MedicationDispense: Read Existing",
                "id": "X020_MedicationDispense",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Successfully read preexisting MedicationDispense.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationDispense: Update Existing",
                "id": "X030_MedicationDispense",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Updated existing MedicationDispense.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationDispense: Read History of existing",
                "id": "X040_MedicationDispense",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationDispense: Version read existing",
                "id": "X050_MedicationDispense",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Read current version of preexisting MedicationDispense.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationDispense: Previous version read existing",
                "id": "X055_MedicationDispense",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Read previous version of preexisting MedicationDispense.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MedicationDispense: Validate",
                "id": "X060_MedicationDispense",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "MedicationDispense was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationDispense"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationDispense: Validate Existing",
                "id": "X065_MedicationDispense",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Existing MedicationDispense was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationDispense"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MedicationDispense: Validate against a profile",
                "id": "X067_MedicationDispense",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "MedicationDispense was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationDispense"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationDispense: Delete Existing",
                "id": "X070_MedicationDispense",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Existing MedicationDispense was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationDispense: Get Deleted Resource",
                "id": "X075_MedicationDispense",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Deleted MedicationDispense was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04b4d4d3261a6400000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:44:57.533-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08f24d4d3266f8d60200"
        },
        "created_at": {
            "$date": "2015-10-02T18:45:06.796-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "MedicationOrder: Read Type",
                "id": "X000_MedicationOrder",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "MedicationOrder: Create New",
                "id": "X010_MedicationOrder",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "New MedicationOrder was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "MedicationOrder: Read Existing",
                "id": "X020_MedicationOrder",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Successfully read preexisting MedicationOrder.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationOrder: Update Existing",
                "id": "X030_MedicationOrder",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Updated existing MedicationOrder.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationOrder: Read History of existing",
                "id": "X040_MedicationOrder",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationOrder: Version read existing",
                "id": "X050_MedicationOrder",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Read current version of preexisting MedicationOrder.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationOrder: Previous version read existing",
                "id": "X055_MedicationOrder",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Read previous version of preexisting MedicationOrder.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MedicationOrder: Validate",
                "id": "X060_MedicationOrder",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "MedicationOrder was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationOrder: Validate Existing",
                "id": "X065_MedicationOrder",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Existing MedicationOrder was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MedicationOrder: Validate against a profile",
                "id": "X067_MedicationOrder",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "MedicationOrder was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationOrder: Delete Existing",
                "id": "X070_MedicationOrder",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Existing MedicationOrder was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationOrder: Get Deleted Resource",
                "id": "X075_MedicationOrder",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Deleted MedicationOrder was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04c4d4d3261a6410000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:45:06.796-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f08fc4d4d3266f8d70200"
        },
        "created_at": {
            "$date": "2015-10-02T18:45:16.467-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "MedicationStatement: Read Type",
                "id": "X000_MedicationStatement",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "MedicationStatement: Create New",
                "id": "X010_MedicationStatement",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "New MedicationStatement was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "MedicationStatement: Read Existing",
                "id": "X020_MedicationStatement",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Successfully read preexisting MedicationStatement.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationStatement: Update Existing",
                "id": "X030_MedicationStatement",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Updated existing MedicationStatement.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationStatement: Read History of existing",
                "id": "X040_MedicationStatement",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationStatement: Version read existing",
                "id": "X050_MedicationStatement",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Read current version of preexisting MedicationStatement.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MedicationStatement: Previous version read existing",
                "id": "X055_MedicationStatement",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Read previous version of preexisting MedicationStatement.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MedicationStatement: Validate",
                "id": "X060_MedicationStatement",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "MedicationStatement was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationStatement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationStatement: Validate Existing",
                "id": "X065_MedicationStatement",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Existing MedicationStatement was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationStatement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MedicationStatement: Validate against a profile",
                "id": "X067_MedicationStatement",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "MedicationStatement was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MedicationStatement"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationStatement: Delete Existing",
                "id": "X070_MedicationStatement",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Existing MedicationStatement was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MedicationStatement: Get Deleted Resource",
                "id": "X075_MedicationStatement",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Deleted MedicationStatement was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04c4d4d3261a6420000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:45:16.467-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09054d4d3266f8d80200"
        },
        "created_at": {
            "$date": "2015-10-02T18:45:25.429-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "MessageHeader: Read Type",
                "id": "X000_MessageHeader",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "MessageHeader: Create New",
                "id": "X010_MessageHeader",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "New MessageHeader was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "MessageHeader: Read Existing",
                "id": "X020_MessageHeader",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Successfully read preexisting MessageHeader.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MessageHeader: Update Existing",
                "id": "X030_MessageHeader",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Updated existing MessageHeader.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "MessageHeader: Read History of existing",
                "id": "X040_MessageHeader",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MessageHeader: Version read existing",
                "id": "X050_MessageHeader",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Read current version of preexisting MessageHeader.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "MessageHeader: Previous version read existing",
                "id": "X055_MessageHeader",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Read previous version of preexisting MessageHeader.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MessageHeader: Validate",
                "id": "X060_MessageHeader",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "MessageHeader was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MessageHeader"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MessageHeader: Validate Existing",
                "id": "X065_MessageHeader",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Existing MessageHeader was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MessageHeader"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "MessageHeader: Validate against a profile",
                "id": "X067_MessageHeader",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "MessageHeader was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "MessageHeader"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MessageHeader: Delete Existing",
                "id": "X070_MessageHeader",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Existing MessageHeader was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "MessageHeader: Get Deleted Resource",
                "id": "X075_MessageHeader",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Deleted MessageHeader was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04c4d4d3261a6430000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:45:25.429-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f090d4d4d3266f8d90200"
        },
        "created_at": {
            "$date": "2015-10-02T18:45:33.162-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "NamingSystem: Read Type",
                "id": "X000_NamingSystem",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "NamingSystem: Create New",
                "id": "X010_NamingSystem",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "New NamingSystem was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "NamingSystem: Read Existing",
                "id": "X020_NamingSystem",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Successfully read preexisting NamingSystem.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "NamingSystem: Update Existing",
                "id": "X030_NamingSystem",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Updated existing NamingSystem.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "NamingSystem: Read History of existing",
                "id": "X040_NamingSystem",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "NamingSystem: Version read existing",
                "id": "X050_NamingSystem",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Read current version of preexisting NamingSystem.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "NamingSystem: Previous version read existing",
                "id": "X055_NamingSystem",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Read previous version of preexisting NamingSystem.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "NamingSystem: Validate",
                "id": "X060_NamingSystem",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "NamingSystem was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "NamingSystem"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "NamingSystem: Validate Existing",
                "id": "X065_NamingSystem",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Existing NamingSystem was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "NamingSystem"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "NamingSystem: Validate against a profile",
                "id": "X067_NamingSystem",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "NamingSystem was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "NamingSystem"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "NamingSystem: Delete Existing",
                "id": "X070_NamingSystem",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Existing NamingSystem was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "NamingSystem: Get Deleted Resource",
                "id": "X075_NamingSystem",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Deleted NamingSystem was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04c4d4d3261a6440000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:45:33.162-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09174d4d3266f8da0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:45:43.294-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "NutritionOrder: Read Type",
                "id": "X000_NutritionOrder",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "NutritionOrder: Create New",
                "id": "X010_NutritionOrder",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "New NutritionOrder was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "NutritionOrder: Read Existing",
                "id": "X020_NutritionOrder",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Successfully read preexisting NutritionOrder.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "NutritionOrder: Update Existing",
                "id": "X030_NutritionOrder",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Updated existing NutritionOrder.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "NutritionOrder: Read History of existing",
                "id": "X040_NutritionOrder",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "NutritionOrder: Version read existing",
                "id": "X050_NutritionOrder",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Read current version of preexisting NutritionOrder.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "NutritionOrder: Previous version read existing",
                "id": "X055_NutritionOrder",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Read previous version of preexisting NutritionOrder.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "NutritionOrder: Validate",
                "id": "X060_NutritionOrder",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "NutritionOrder was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "NutritionOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "NutritionOrder: Validate Existing",
                "id": "X065_NutritionOrder",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Existing NutritionOrder was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "NutritionOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "NutritionOrder: Validate against a profile",
                "id": "X067_NutritionOrder",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "NutritionOrder was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "NutritionOrder"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "NutritionOrder: Delete Existing",
                "id": "X070_NutritionOrder",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Existing NutritionOrder was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "NutritionOrder: Get Deleted Resource",
                "id": "X075_NutritionOrder",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Deleted NutritionOrder was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04c4d4d3261a6450000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:45:43.294-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09214d4d3266f8db0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:45:53.120-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Observation: Read Type",
                "id": "X000_Observation",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Observation: Create New",
                "id": "X010_Observation",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "New Observation was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Observation: Read Existing",
                "id": "X020_Observation",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Successfully read preexisting Observation.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Observation: Update Existing",
                "id": "X030_Observation",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Updated existing Observation.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Observation: Read History of existing",
                "id": "X040_Observation",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Observation: Version read existing",
                "id": "X050_Observation",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Read current version of preexisting Observation.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Observation: Previous version read existing",
                "id": "X055_Observation",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Read previous version of preexisting Observation.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Observation: Validate",
                "id": "X060_Observation",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Observation was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Observation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Observation: Validate Existing",
                "id": "X065_Observation",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Existing Observation was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Observation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Observation: Validate against a profile",
                "id": "X067_Observation",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Observation was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Observation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Observation: Delete Existing",
                "id": "X070_Observation",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Existing Observation was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Observation: Get Deleted Resource",
                "id": "X075_Observation",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Deleted Observation was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Observation"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04c4d4d3261a6460000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:45:53.120-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09294d4d3266f8dc0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:46:01.484-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "OperationDefinition: Read Type",
                "id": "X000_OperationDefinition",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "OperationDefinition: Create New",
                "id": "X010_OperationDefinition",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "New OperationDefinition was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "OperationDefinition: Read Existing",
                "id": "X020_OperationDefinition",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Successfully read preexisting OperationDefinition.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OperationDefinition: Update Existing",
                "id": "X030_OperationDefinition",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Updated existing OperationDefinition.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "OperationDefinition: Read History of existing",
                "id": "X040_OperationDefinition",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "OperationDefinition: Version read existing",
                "id": "X050_OperationDefinition",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Read current version of preexisting OperationDefinition.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "OperationDefinition: Previous version read existing",
                "id": "X055_OperationDefinition",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Read previous version of preexisting OperationDefinition.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "OperationDefinition: Validate",
                "id": "X060_OperationDefinition",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "OperationDefinition was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OperationDefinition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OperationDefinition: Validate Existing",
                "id": "X065_OperationDefinition",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Existing OperationDefinition was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OperationDefinition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "OperationDefinition: Validate against a profile",
                "id": "X067_OperationDefinition",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "OperationDefinition was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OperationDefinition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OperationDefinition: Delete Existing",
                "id": "X070_OperationDefinition",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Existing OperationDefinition was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OperationDefinition: Get Deleted Resource",
                "id": "X075_OperationDefinition",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Deleted OperationDefinition was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04c4d4d3261a6470000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:46:01.484-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09314d4d3266f8dd0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:46:09.487-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "OperationOutcome: Read Type",
                "id": "X000_OperationOutcome",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "OperationOutcome: Create New",
                "id": "X010_OperationOutcome",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "New OperationOutcome was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "OperationOutcome: Read Existing",
                "id": "X020_OperationOutcome",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Successfully read preexisting OperationOutcome.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OperationOutcome: Update Existing",
                "id": "X030_OperationOutcome",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Updated existing OperationOutcome.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "OperationOutcome: Read History of existing",
                "id": "X040_OperationOutcome",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "OperationOutcome: Version read existing",
                "id": "X050_OperationOutcome",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Read current version of preexisting OperationOutcome.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "OperationOutcome: Previous version read existing",
                "id": "X055_OperationOutcome",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Read previous version of preexisting OperationOutcome.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "OperationOutcome: Validate",
                "id": "X060_OperationOutcome",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "OperationOutcome was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OperationOutcome"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OperationOutcome: Validate Existing",
                "id": "X065_OperationOutcome",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Existing OperationOutcome was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OperationOutcome"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "OperationOutcome: Validate against a profile",
                "id": "X067_OperationOutcome",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "OperationOutcome was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OperationOutcome"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OperationOutcome: Delete Existing",
                "id": "X070_OperationOutcome",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Existing OperationOutcome was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OperationOutcome: Get Deleted Resource",
                "id": "X075_OperationOutcome",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Deleted OperationOutcome was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04d4d4d3261a6480000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:46:09.487-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f093a4d4d3266f8de0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:46:18.185-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Order: Read Type",
                "id": "X000_Order",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Order: Create New",
                "id": "X010_Order",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "New Order was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Order: Read Existing",
                "id": "X020_Order",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Successfully read preexisting Order.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Order: Update Existing",
                "id": "X030_Order",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Updated existing Order.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Order: Read History of existing",
                "id": "X040_Order",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Order: Version read existing",
                "id": "X050_Order",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Read current version of preexisting Order.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Order: Previous version read existing",
                "id": "X055_Order",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Read previous version of preexisting Order.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Order: Validate",
                "id": "X060_Order",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Order was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Order"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Order: Validate Existing",
                "id": "X065_Order",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Existing Order was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Order"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Order: Validate against a profile",
                "id": "X067_Order",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Order was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Order"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Order: Delete Existing",
                "id": "X070_Order",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Existing Order was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Order: Get Deleted Resource",
                "id": "X075_Order",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Deleted Order was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Order"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04d4d4d3261a6490000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:46:18.185-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09404d4d3266f8df0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:46:24.922-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "OrderResponse: Read Type",
                "id": "X000_OrderResponse",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "OrderResponse: Create New",
                "id": "X010_OrderResponse",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "New OrderResponse was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "OrderResponse: Read Existing",
                "id": "X020_OrderResponse",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Successfully read preexisting OrderResponse.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OrderResponse: Update Existing",
                "id": "X030_OrderResponse",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Updated existing OrderResponse.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "OrderResponse: Read History of existing",
                "id": "X040_OrderResponse",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "OrderResponse: Version read existing",
                "id": "X050_OrderResponse",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Read current version of preexisting OrderResponse.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "OrderResponse: Previous version read existing",
                "id": "X055_OrderResponse",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Read previous version of preexisting OrderResponse.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "OrderResponse: Validate",
                "id": "X060_OrderResponse",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "OrderResponse was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OrderResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OrderResponse: Validate Existing",
                "id": "X065_OrderResponse",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Existing OrderResponse was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OrderResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "OrderResponse: Validate against a profile",
                "id": "X067_OrderResponse",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "OrderResponse was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "OrderResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OrderResponse: Delete Existing",
                "id": "X070_OrderResponse",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Existing OrderResponse was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "OrderResponse: Get Deleted Resource",
                "id": "X075_OrderResponse",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Deleted OrderResponse was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04d4d4d3261a64a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:46:24.922-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09484d4d3266f8e00200"
        },
        "created_at": {
            "$date": "2015-10-02T18:46:32.531-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Organization: Read Type",
                "id": "X000_Organization",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Organization: Create New",
                "id": "X010_Organization",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "New Organization was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Organization: Read Existing",
                "id": "X020_Organization",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Successfully read preexisting Organization.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Organization: Update Existing",
                "id": "X030_Organization",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Updated existing Organization.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Organization: Read History of existing",
                "id": "X040_Organization",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Organization: Version read existing",
                "id": "X050_Organization",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Read current version of preexisting Organization.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Organization: Previous version read existing",
                "id": "X055_Organization",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Read previous version of preexisting Organization.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Organization: Validate",
                "id": "X060_Organization",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Organization was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Organization"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Organization: Validate Existing",
                "id": "X065_Organization",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Existing Organization was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Organization"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Organization: Validate against a profile",
                "id": "X067_Organization",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Organization was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Organization"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Organization: Delete Existing",
                "id": "X070_Organization",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Existing Organization was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Organization: Get Deleted Resource",
                "id": "X075_Organization",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Deleted Organization was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Organization"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04d4d4d3261a64b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:46:32.531-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09514d4d3266f8e10200"
        },
        "created_at": {
            "$date": "2015-10-02T18:46:41.037-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Patient: Read Type",
                "id": "X000_Patient",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Patient: Create New",
                "id": "X010_Patient",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "New Patient was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Patient: Read Existing",
                "id": "X020_Patient",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Successfully read preexisting Patient.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Patient: Update Existing",
                "id": "X030_Patient",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Updated existing Patient.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Patient: Read History of existing",
                "id": "X040_Patient",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Patient: Version read existing",
                "id": "X050_Patient",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Read current version of preexisting Patient.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Patient: Previous version read existing",
                "id": "X055_Patient",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Read previous version of preexisting Patient.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Patient: Validate",
                "id": "X060_Patient",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Patient was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Patient: Validate Existing",
                "id": "X065_Patient",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Existing Patient was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Patient: Validate against a profile",
                "id": "X067_Patient",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Patient was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Patient: Delete Existing",
                "id": "X070_Patient",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Existing Patient was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Patient: Get Deleted Resource",
                "id": "X075_Patient",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Deleted Patient was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04d4d4d3261a64c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:46:41.037-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09594d4d3266f8e20200"
        },
        "created_at": {
            "$date": "2015-10-02T18:46:49.427-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "PaymentNotice: Read Type",
                "id": "X000_PaymentNotice",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "PaymentNotice: Create New",
                "id": "X010_PaymentNotice",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "New PaymentNotice was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "PaymentNotice: Read Existing",
                "id": "X020_PaymentNotice",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Successfully read preexisting PaymentNotice.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "PaymentNotice: Update Existing",
                "id": "X030_PaymentNotice",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Updated existing PaymentNotice.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "PaymentNotice: Read History of existing",
                "id": "X040_PaymentNotice",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "PaymentNotice: Version read existing",
                "id": "X050_PaymentNotice",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Read current version of preexisting PaymentNotice.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "PaymentNotice: Previous version read existing",
                "id": "X055_PaymentNotice",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Read previous version of preexisting PaymentNotice.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "PaymentNotice: Validate",
                "id": "X060_PaymentNotice",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "PaymentNotice was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "PaymentNotice"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "PaymentNotice: Validate Existing",
                "id": "X065_PaymentNotice",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Existing PaymentNotice was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "PaymentNotice"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "PaymentNotice: Validate against a profile",
                "id": "X067_PaymentNotice",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "PaymentNotice was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "PaymentNotice"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "PaymentNotice: Delete Existing",
                "id": "X070_PaymentNotice",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Existing PaymentNotice was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "PaymentNotice: Get Deleted Resource",
                "id": "X075_PaymentNotice",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Deleted PaymentNotice was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04d4d4d3261a64d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:46:49.427-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09604d4d3266f8e30200"
        },
        "created_at": {
            "$date": "2015-10-02T18:46:56.507-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "PaymentReconciliation: Read Type",
                "id": "X000_PaymentReconciliation",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "PaymentReconciliation: Create New",
                "id": "X010_PaymentReconciliation",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "New PaymentReconciliation was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "PaymentReconciliation: Read Existing",
                "id": "X020_PaymentReconciliation",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Successfully read preexisting PaymentReconciliation.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "PaymentReconciliation: Update Existing",
                "id": "X030_PaymentReconciliation",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Updated existing PaymentReconciliation.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "PaymentReconciliation: Read History of existing",
                "id": "X040_PaymentReconciliation",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "PaymentReconciliation: Version read existing",
                "id": "X050_PaymentReconciliation",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Read current version of preexisting PaymentReconciliation.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "PaymentReconciliation: Previous version read existing",
                "id": "X055_PaymentReconciliation",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Read previous version of preexisting PaymentReconciliation.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "PaymentReconciliation: Validate",
                "id": "X060_PaymentReconciliation",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "PaymentReconciliation was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "PaymentReconciliation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "PaymentReconciliation: Validate Existing",
                "id": "X065_PaymentReconciliation",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Existing PaymentReconciliation was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "PaymentReconciliation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "PaymentReconciliation: Validate against a profile",
                "id": "X067_PaymentReconciliation",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "PaymentReconciliation was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "PaymentReconciliation"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "PaymentReconciliation: Delete Existing",
                "id": "X070_PaymentReconciliation",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Existing PaymentReconciliation was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "PaymentReconciliation: Get Deleted Resource",
                "id": "X075_PaymentReconciliation",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Deleted PaymentReconciliation was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04d4d4d3261a64e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:46:56.507-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09684d4d3266f8e40200"
        },
        "created_at": {
            "$date": "2015-10-02T18:47:04.888-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Person: Read Type",
                "id": "X000_Person",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Person: Create New",
                "id": "X010_Person",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "New Person was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Person: Read Existing",
                "id": "X020_Person",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Successfully read preexisting Person.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Person: Update Existing",
                "id": "X030_Person",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Updated existing Person.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Person: Read History of existing",
                "id": "X040_Person",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Person: Version read existing",
                "id": "X050_Person",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Read current version of preexisting Person.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Person: Previous version read existing",
                "id": "X055_Person",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Read previous version of preexisting Person.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Person: Validate",
                "id": "X060_Person",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Person was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Person"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Person: Validate Existing",
                "id": "X065_Person",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Existing Person was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Person"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Person: Validate against a profile",
                "id": "X067_Person",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Person was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Person"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Person: Delete Existing",
                "id": "X070_Person",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Existing Person was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Person: Get Deleted Resource",
                "id": "X075_Person",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Deleted Person was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Person"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04d4d4d3261a64f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:47:04.888-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09734d4d3266f8e50200"
        },
        "created_at": {
            "$date": "2015-10-02T18:47:15.479-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Practitioner: Read Type",
                "id": "X000_Practitioner",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"ArgumentNullException: Value cannot be null.&#xD;&#xA;Parameter name: uriString\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Uri..ctor(String uriString, UriKind uriKind)&#xD;&#xA;   at Hl7.Fhir.Rest.ResourceIdentity..ctor(String uri) in C:\\src\\FHIR\\fhir-net-api-DSTU2\\src\\Hl7.Fhir.Core\\Rest\\ResourceIdentity.cs:line 53&#xD;&#xA;   at HealthConnex.Fhir.Models.PractitionerModel.UpdateResource(fhirstore store, Practitioner resource, PractitionerResource head, PractitionerResourceHistory ver) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\PractitionerModel.cs:line 67&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1947&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue></OperationOutcome>",
                "description": "Practitioner: Create New",
                "id": "X010_Practitioner",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": [
                    "error: : ArgumentNullException: Value cannot be null.\r\nParameter name: uriString",
                    "information: :    at System.Uri..ctor(String uriString, UriKind uriKind)\r\n   at Hl7.Fhir.Rest.ResourceIdentity..ctor(String uri) in C:\\src\\FHIR\\fhir-net-api-DSTU2\\src\\Hl7.Fhir.Core\\Rest\\ResourceIdentity.cs:line 53\r\n   at HealthConnex.Fhir.Models.PractitionerModel.UpdateResource(fhirstore store, Practitioner resource, PractitionerResource head, PractitionerResourceHistory ver) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\PractitionerModel.cs:line 67\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1947\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806\r\n   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672\r\n   at lambda_method(Closure , Object , Object[] )\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.<>c__DisplayClass10.<GetExecutor>b__9(Object instance, Object[] methodParameters)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.<InvokeActionAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.<ExecuteAsync>d__2.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ExceptionFilterResult.<ExecuteAsync>d__0.MoveNext()"
                ],
                "status": "fail",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Practitioner: Read Existing",
                "id": "X020_Practitioner",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Successfully read preexisting Practitioner.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Practitioner: Update Existing",
                "id": "X030_Practitioner",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Updated existing Practitioner.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Practitioner: Read History of existing",
                "id": "X040_Practitioner",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Practitioner: Version read existing",
                "id": "X050_Practitioner",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Read current version of preexisting Practitioner.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Practitioner: Previous version read existing",
                "id": "X055_Practitioner",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Read previous version of preexisting Practitioner.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Practitioner: Validate",
                "id": "X060_Practitioner",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Practitioner was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Practitioner"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Practitioner: Validate Existing",
                "id": "X065_Practitioner",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Existing Practitioner was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Practitioner"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Practitioner: Validate against a profile",
                "id": "X067_Practitioner",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Practitioner was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Practitioner"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Practitioner: Delete Existing",
                "id": "X070_Practitioner",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Existing Practitioner was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Practitioner: Get Deleted Resource",
                "id": "X075_Practitioner",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Deleted Practitioner was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04e4d4d3261a6500000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:47:15.479-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f097c4d4d3266f8e60200"
        },
        "created_at": {
            "$date": "2015-10-02T18:47:24.380-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Procedure: Read Type",
                "id": "X000_Procedure",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Procedure: Create New",
                "id": "X010_Procedure",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "New Procedure was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Procedure: Read Existing",
                "id": "X020_Procedure",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Successfully read preexisting Procedure.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Procedure: Update Existing",
                "id": "X030_Procedure",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Updated existing Procedure.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Procedure: Read History of existing",
                "id": "X040_Procedure",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Procedure: Version read existing",
                "id": "X050_Procedure",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Read current version of preexisting Procedure.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Procedure: Previous version read existing",
                "id": "X055_Procedure",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Read previous version of preexisting Procedure.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Procedure: Validate",
                "id": "X060_Procedure",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Procedure was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Procedure"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Procedure: Validate Existing",
                "id": "X065_Procedure",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Existing Procedure was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Procedure"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Procedure: Validate against a profile",
                "id": "X067_Procedure",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Procedure was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Procedure"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Procedure: Delete Existing",
                "id": "X070_Procedure",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Existing Procedure was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Procedure: Get Deleted Resource",
                "id": "X075_Procedure",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Deleted Procedure was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Procedure"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04e4d4d3261a6510000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:47:24.380-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09834d4d3266f8e70200"
        },
        "created_at": {
            "$date": "2015-10-02T18:47:31.149-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ProcedureRequest: Read Type",
                "id": "X000_ProcedureRequest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ProcedureRequest: Create New",
                "id": "X010_ProcedureRequest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "New ProcedureRequest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ProcedureRequest: Read Existing",
                "id": "X020_ProcedureRequest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Successfully read preexisting ProcedureRequest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcedureRequest: Update Existing",
                "id": "X030_ProcedureRequest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Updated existing ProcedureRequest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ProcedureRequest: Read History of existing",
                "id": "X040_ProcedureRequest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ProcedureRequest: Version read existing",
                "id": "X050_ProcedureRequest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Read current version of preexisting ProcedureRequest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ProcedureRequest: Previous version read existing",
                "id": "X055_ProcedureRequest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Read previous version of preexisting ProcedureRequest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ProcedureRequest: Validate",
                "id": "X060_ProcedureRequest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "ProcedureRequest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcedureRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcedureRequest: Validate Existing",
                "id": "X065_ProcedureRequest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Existing ProcedureRequest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcedureRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ProcedureRequest: Validate against a profile",
                "id": "X067_ProcedureRequest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "ProcedureRequest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcedureRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcedureRequest: Delete Existing",
                "id": "X070_ProcedureRequest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Existing ProcedureRequest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcedureRequest: Get Deleted Resource",
                "id": "X075_ProcedureRequest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Deleted ProcedureRequest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04e4d4d3261a6520000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:47:31.149-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f098a4d4d3266f8e80200"
        },
        "created_at": {
            "$date": "2015-10-02T18:47:38.104-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ProcessRequest: Read Type",
                "id": "X000_ProcessRequest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ProcessRequest: Create New",
                "id": "X010_ProcessRequest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "New ProcessRequest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ProcessRequest: Read Existing",
                "id": "X020_ProcessRequest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Successfully read preexisting ProcessRequest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcessRequest: Update Existing",
                "id": "X030_ProcessRequest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Updated existing ProcessRequest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ProcessRequest: Read History of existing",
                "id": "X040_ProcessRequest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ProcessRequest: Version read existing",
                "id": "X050_ProcessRequest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Read current version of preexisting ProcessRequest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ProcessRequest: Previous version read existing",
                "id": "X055_ProcessRequest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Read previous version of preexisting ProcessRequest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ProcessRequest: Validate",
                "id": "X060_ProcessRequest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "ProcessRequest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcessRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcessRequest: Validate Existing",
                "id": "X065_ProcessRequest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Existing ProcessRequest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcessRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ProcessRequest: Validate against a profile",
                "id": "X067_ProcessRequest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "ProcessRequest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcessRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcessRequest: Delete Existing",
                "id": "X070_ProcessRequest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Existing ProcessRequest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcessRequest: Get Deleted Resource",
                "id": "X075_ProcessRequest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Deleted ProcessRequest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04e4d4d3261a6530000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:47:38.104-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09914d4d3266f8e90200"
        },
        "created_at": {
            "$date": "2015-10-02T18:47:45.019-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ProcessResponse: Read Type",
                "id": "X000_ProcessResponse",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ProcessResponse: Create New",
                "id": "X010_ProcessResponse",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "New ProcessResponse was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ProcessResponse: Read Existing",
                "id": "X020_ProcessResponse",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Successfully read preexisting ProcessResponse.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcessResponse: Update Existing",
                "id": "X030_ProcessResponse",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Updated existing ProcessResponse.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ProcessResponse: Read History of existing",
                "id": "X040_ProcessResponse",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ProcessResponse: Version read existing",
                "id": "X050_ProcessResponse",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Read current version of preexisting ProcessResponse.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ProcessResponse: Previous version read existing",
                "id": "X055_ProcessResponse",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Read previous version of preexisting ProcessResponse.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ProcessResponse: Validate",
                "id": "X060_ProcessResponse",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "ProcessResponse was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcessResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcessResponse: Validate Existing",
                "id": "X065_ProcessResponse",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Existing ProcessResponse was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcessResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ProcessResponse: Validate against a profile",
                "id": "X067_ProcessResponse",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "ProcessResponse was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ProcessResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcessResponse: Delete Existing",
                "id": "X070_ProcessResponse",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Existing ProcessResponse was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ProcessResponse: Get Deleted Resource",
                "id": "X075_ProcessResponse",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Deleted ProcessResponse was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04e4d4d3261a6540000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:47:45.019-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09994d4d3266f8ea0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:47:53.350-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Provenance: Read Type",
                "id": "X000_Provenance",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Provenance: Create New",
                "id": "X010_Provenance",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "New Provenance was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Provenance: Read Existing",
                "id": "X020_Provenance",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Successfully read preexisting Provenance.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Provenance: Update Existing",
                "id": "X030_Provenance",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Updated existing Provenance.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Provenance: Read History of existing",
                "id": "X040_Provenance",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Provenance: Version read existing",
                "id": "X050_Provenance",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Read current version of preexisting Provenance.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Provenance: Previous version read existing",
                "id": "X055_Provenance",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Read previous version of preexisting Provenance.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Provenance: Validate",
                "id": "X060_Provenance",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Provenance was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Provenance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Provenance: Validate Existing",
                "id": "X065_Provenance",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Existing Provenance was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Provenance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Provenance: Validate against a profile",
                "id": "X067_Provenance",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Provenance was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Provenance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Provenance: Delete Existing",
                "id": "X070_Provenance",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Existing Provenance was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Provenance: Get Deleted Resource",
                "id": "X075_Provenance",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Deleted Provenance was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Provenance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04e4d4d3261a6550000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:47:53.350-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09b14d4d3266f8eb0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:48:17.478-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Questionnaire: Read Type",
                "id": "X000_Questionnaire",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Questionnaire: Create New",
                "id": "X010_Questionnaire",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "New Questionnaire was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Questionnaire: Read Existing",
                "id": "X020_Questionnaire",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Successfully read preexisting Questionnaire.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Questionnaire: Update Existing",
                "id": "X030_Questionnaire",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Updated existing Questionnaire.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Questionnaire: Read History of existing",
                "id": "X040_Questionnaire",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Questionnaire: Version read existing",
                "id": "X050_Questionnaire",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Read current version of preexisting Questionnaire.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Questionnaire: Previous version read existing",
                "id": "X055_Questionnaire",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Read previous version of preexisting Questionnaire.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Questionnaire: Validate",
                "id": "X060_Questionnaire",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Questionnaire was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Questionnaire"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Questionnaire: Validate Existing",
                "id": "X065_Questionnaire",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Existing Questionnaire was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Questionnaire"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Questionnaire: Validate against a profile",
                "id": "X067_Questionnaire",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Questionnaire was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Questionnaire"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Questionnaire: Delete Existing",
                "id": "X070_Questionnaire",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Existing Questionnaire was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Questionnaire: Get Deleted Resource",
                "id": "X075_Questionnaire",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Deleted Questionnaire was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04f4d4d3261a6560000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:48:17.478-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09cc4d4d3266f8ec0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:48:44.730-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "QuestionnaireResponse: Read Type",
                "id": "X000_QuestionnaireResponse",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "QuestionnaireResponse: Create New",
                "id": "X010_QuestionnaireResponse",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "New QuestionnaireResponse was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "QuestionnaireResponse: Read Existing",
                "id": "X020_QuestionnaireResponse",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Successfully read preexisting QuestionnaireResponse.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "QuestionnaireResponse: Update Existing",
                "id": "X030_QuestionnaireResponse",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Updated existing QuestionnaireResponse.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "QuestionnaireResponse: Read History of existing",
                "id": "X040_QuestionnaireResponse",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "QuestionnaireResponse: Version read existing",
                "id": "X050_QuestionnaireResponse",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Read current version of preexisting QuestionnaireResponse.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "QuestionnaireResponse: Previous version read existing",
                "id": "X055_QuestionnaireResponse",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Read previous version of preexisting QuestionnaireResponse.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "QuestionnaireResponse: Validate",
                "id": "X060_QuestionnaireResponse",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "QuestionnaireResponse was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "QuestionnaireResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "QuestionnaireResponse: Validate Existing",
                "id": "X065_QuestionnaireResponse",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Existing QuestionnaireResponse was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "QuestionnaireResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "QuestionnaireResponse: Validate against a profile",
                "id": "X067_QuestionnaireResponse",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "QuestionnaireResponse was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "QuestionnaireResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "QuestionnaireResponse: Delete Existing",
                "id": "X070_QuestionnaireResponse",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Existing QuestionnaireResponse was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "QuestionnaireResponse: Get Deleted Resource",
                "id": "X075_QuestionnaireResponse",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Deleted QuestionnaireResponse was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04f4d4d3261a6570000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:48:44.730-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09d44d4d3266f8ed0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:48:52.923-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ReferralRequest: Read Type",
                "id": "X000_ReferralRequest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ReferralRequest: Create New",
                "id": "X010_ReferralRequest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "New ReferralRequest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ReferralRequest: Read Existing",
                "id": "X020_ReferralRequest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Successfully read preexisting ReferralRequest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ReferralRequest: Update Existing",
                "id": "X030_ReferralRequest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Updated existing ReferralRequest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ReferralRequest: Read History of existing",
                "id": "X040_ReferralRequest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ReferralRequest: Version read existing",
                "id": "X050_ReferralRequest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Read current version of preexisting ReferralRequest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ReferralRequest: Previous version read existing",
                "id": "X055_ReferralRequest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Read previous version of preexisting ReferralRequest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ReferralRequest: Validate",
                "id": "X060_ReferralRequest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "ReferralRequest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ReferralRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ReferralRequest: Validate Existing",
                "id": "X065_ReferralRequest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Existing ReferralRequest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ReferralRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ReferralRequest: Validate against a profile",
                "id": "X067_ReferralRequest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "ReferralRequest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ReferralRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ReferralRequest: Delete Existing",
                "id": "X070_ReferralRequest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Existing ReferralRequest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ReferralRequest: Get Deleted Resource",
                "id": "X075_ReferralRequest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Deleted ReferralRequest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04f4d4d3261a6580000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:48:52.923-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09dc4d4d3266f8ee0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:49:00.918-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "RelatedPerson: Read Type",
                "id": "X000_RelatedPerson",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "RelatedPerson: Create New",
                "id": "X010_RelatedPerson",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "New RelatedPerson was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "RelatedPerson: Read Existing",
                "id": "X020_RelatedPerson",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Successfully read preexisting RelatedPerson.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "RelatedPerson: Update Existing",
                "id": "X030_RelatedPerson",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Updated existing RelatedPerson.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "RelatedPerson: Read History of existing",
                "id": "X040_RelatedPerson",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "RelatedPerson: Version read existing",
                "id": "X050_RelatedPerson",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Read current version of preexisting RelatedPerson.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "RelatedPerson: Previous version read existing",
                "id": "X055_RelatedPerson",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Read previous version of preexisting RelatedPerson.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "RelatedPerson: Validate",
                "id": "X060_RelatedPerson",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "RelatedPerson was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "RelatedPerson"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "RelatedPerson: Validate Existing",
                "id": "X065_RelatedPerson",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Existing RelatedPerson was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "RelatedPerson"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "RelatedPerson: Validate against a profile",
                "id": "X067_RelatedPerson",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "RelatedPerson was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "RelatedPerson"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "RelatedPerson: Delete Existing",
                "id": "X070_RelatedPerson",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Existing RelatedPerson was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "RelatedPerson: Get Deleted Resource",
                "id": "X075_RelatedPerson",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Deleted RelatedPerson was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04f4d4d3261a6590000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:49:00.918-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09e44d4d3266f8ef0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:49:08.385-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "RiskAssessment: Read Type",
                "id": "X000_RiskAssessment",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "RiskAssessment: Create New",
                "id": "X010_RiskAssessment",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "New RiskAssessment was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "RiskAssessment: Read Existing",
                "id": "X020_RiskAssessment",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Successfully read preexisting RiskAssessment.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "RiskAssessment: Update Existing",
                "id": "X030_RiskAssessment",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Updated existing RiskAssessment.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "RiskAssessment: Read History of existing",
                "id": "X040_RiskAssessment",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "RiskAssessment: Version read existing",
                "id": "X050_RiskAssessment",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Read current version of preexisting RiskAssessment.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "RiskAssessment: Previous version read existing",
                "id": "X055_RiskAssessment",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Read previous version of preexisting RiskAssessment.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "RiskAssessment: Validate",
                "id": "X060_RiskAssessment",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "RiskAssessment was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "RiskAssessment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "RiskAssessment: Validate Existing",
                "id": "X065_RiskAssessment",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Existing RiskAssessment was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "RiskAssessment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "RiskAssessment: Validate against a profile",
                "id": "X067_RiskAssessment",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "RiskAssessment was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "RiskAssessment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "RiskAssessment: Delete Existing",
                "id": "X070_RiskAssessment",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Existing RiskAssessment was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "RiskAssessment: Get Deleted Resource",
                "id": "X075_RiskAssessment",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Deleted RiskAssessment was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04f4d4d3261a65a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:49:08.385-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09ec4d4d3266f8f00200"
        },
        "created_at": {
            "$date": "2015-10-02T18:49:16.172-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Schedule: Read Type",
                "id": "X000_Schedule",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Schedule: Create New",
                "id": "X010_Schedule",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "New Schedule was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Schedule: Read Existing",
                "id": "X020_Schedule",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Successfully read preexisting Schedule.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Schedule: Update Existing",
                "id": "X030_Schedule",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Updated existing Schedule.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Schedule: Read History of existing",
                "id": "X040_Schedule",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Schedule: Version read existing",
                "id": "X050_Schedule",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Read current version of preexisting Schedule.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Schedule: Previous version read existing",
                "id": "X055_Schedule",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Read previous version of preexisting Schedule.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Schedule: Validate",
                "id": "X060_Schedule",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Schedule was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Schedule"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Schedule: Validate Existing",
                "id": "X065_Schedule",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Existing Schedule was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Schedule"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Schedule: Validate against a profile",
                "id": "X067_Schedule",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Schedule was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Schedule"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Schedule: Delete Existing",
                "id": "X070_Schedule",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Existing Schedule was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Schedule: Get Deleted Resource",
                "id": "X075_Schedule",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Deleted Schedule was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Schedule"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04f4d4d3261a65b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:49:16.172-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09f54d4d3266f8f10200"
        },
        "created_at": {
            "$date": "2015-10-02T18:49:25.588-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "SearchParameter: Read Type",
                "id": "X000_SearchParameter",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "SearchParameter: Create New",
                "id": "X010_SearchParameter",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "New SearchParameter was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "SearchParameter: Read Existing",
                "id": "X020_SearchParameter",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Successfully read preexisting SearchParameter.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SearchParameter: Update Existing",
                "id": "X030_SearchParameter",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Updated existing SearchParameter.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "SearchParameter: Read History of existing",
                "id": "X040_SearchParameter",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "SearchParameter: Version read existing",
                "id": "X050_SearchParameter",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Read current version of preexisting SearchParameter.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "SearchParameter: Previous version read existing",
                "id": "X055_SearchParameter",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Read previous version of preexisting SearchParameter.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "SearchParameter: Validate",
                "id": "X060_SearchParameter",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "SearchParameter was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SearchParameter"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SearchParameter: Validate Existing",
                "id": "X065_SearchParameter",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Existing SearchParameter was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SearchParameter"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "SearchParameter: Validate against a profile",
                "id": "X067_SearchParameter",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "SearchParameter was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SearchParameter"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SearchParameter: Delete Existing",
                "id": "X070_SearchParameter",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Existing SearchParameter was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SearchParameter: Get Deleted Resource",
                "id": "X075_SearchParameter",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Deleted SearchParameter was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef04f4d4d3261a65c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:49:25.588-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f09fd4d4d3266f8f20200"
        },
        "created_at": {
            "$date": "2015-10-02T18:49:33.064-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Slot: Read Type",
                "id": "X000_Slot",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Slot: Create New",
                "id": "X010_Slot",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "New Slot was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Slot: Read Existing",
                "id": "X020_Slot",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Successfully read preexisting Slot.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Slot: Update Existing",
                "id": "X030_Slot",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Updated existing Slot.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Slot: Read History of existing",
                "id": "X040_Slot",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Slot: Version read existing",
                "id": "X050_Slot",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Read current version of preexisting Slot.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Slot: Previous version read existing",
                "id": "X055_Slot",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Read previous version of preexisting Slot.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Slot: Validate",
                "id": "X060_Slot",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Slot was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Slot"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Slot: Validate Existing",
                "id": "X065_Slot",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Existing Slot was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Slot"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Slot: Validate against a profile",
                "id": "X067_Slot",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Slot was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Slot"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Slot: Delete Existing",
                "id": "X070_Slot",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Existing Slot was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Slot: Get Deleted Resource",
                "id": "X075_Slot",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Deleted Slot was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Slot"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0504d4d3261a65d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:49:33.064-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a044d4d3266f8f30200"
        },
        "created_at": {
            "$date": "2015-10-02T18:49:40.899-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Specimen: Read Type",
                "id": "X000_Specimen",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Specimen: Create New",
                "id": "X010_Specimen",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "New Specimen was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Specimen: Read Existing",
                "id": "X020_Specimen",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Successfully read preexisting Specimen.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Specimen: Update Existing",
                "id": "X030_Specimen",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Updated existing Specimen.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Specimen: Read History of existing",
                "id": "X040_Specimen",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Specimen: Version read existing",
                "id": "X050_Specimen",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Read current version of preexisting Specimen.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Specimen: Previous version read existing",
                "id": "X055_Specimen",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Read previous version of preexisting Specimen.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Specimen: Validate",
                "id": "X060_Specimen",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Specimen was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Specimen"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Specimen: Validate Existing",
                "id": "X065_Specimen",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Existing Specimen was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Specimen"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Specimen: Validate against a profile",
                "id": "X067_Specimen",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Specimen was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Specimen"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Specimen: Delete Existing",
                "id": "X070_Specimen",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Existing Specimen was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Specimen: Get Deleted Resource",
                "id": "X075_Specimen",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Deleted Specimen was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Specimen"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0504d4d3261a65e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:49:40.899-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a3f4d4d3266f8f40200"
        },
        "created_at": {
            "$date": "2015-10-02T18:50:39.111-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "StructureDefinition: Read Type",
                "id": "X000_StructureDefinition",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "StructureDefinition: Create New",
                "id": "X010_StructureDefinition",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "New StructureDefinition was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "StructureDefinition: Read Existing",
                "id": "X020_StructureDefinition",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Successfully read preexisting StructureDefinition.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "StructureDefinition: Update Existing",
                "id": "X030_StructureDefinition",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Updated existing StructureDefinition.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "StructureDefinition: Read History of existing",
                "id": "X040_StructureDefinition",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "StructureDefinition: Version read existing",
                "id": "X050_StructureDefinition",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Read current version of preexisting StructureDefinition.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "StructureDefinition: Previous version read existing",
                "id": "X055_StructureDefinition",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Read previous version of preexisting StructureDefinition.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "StructureDefinition: Validate",
                "id": "X060_StructureDefinition",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "StructureDefinition was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "StructureDefinition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "StructureDefinition: Validate Existing",
                "id": "X065_StructureDefinition",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Existing StructureDefinition was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "StructureDefinition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "StructureDefinition: Validate against a profile",
                "id": "X067_StructureDefinition",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "StructureDefinition was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "StructureDefinition"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "StructureDefinition: Delete Existing",
                "id": "X070_StructureDefinition",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Existing StructureDefinition was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "StructureDefinition: Get Deleted Resource",
                "id": "X075_StructureDefinition",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Deleted StructureDefinition was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0504d4d3261a65f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:50:39.111-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a444d4d3266f8f50200"
        },
        "created_at": {
            "$date": "2015-10-02T18:50:44.846-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Subscription: Read Type",
                "id": "X000_Subscription",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Subscription: Create New",
                "id": "X010_Subscription",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "New Subscription was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Subscription: Read Existing",
                "id": "X020_Subscription",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Successfully read preexisting Subscription.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Subscription: Update Existing",
                "id": "X030_Subscription",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Updated existing Subscription.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Subscription: Read History of existing",
                "id": "X040_Subscription",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Subscription: Version read existing",
                "id": "X050_Subscription",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Read current version of preexisting Subscription.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Subscription: Previous version read existing",
                "id": "X055_Subscription",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Read previous version of preexisting Subscription.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Subscription: Validate",
                "id": "X060_Subscription",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Subscription was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Subscription"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Subscription: Validate Existing",
                "id": "X065_Subscription",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Existing Subscription was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Subscription"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Subscription: Validate against a profile",
                "id": "X067_Subscription",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Subscription was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Subscription"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Subscription: Delete Existing",
                "id": "X070_Subscription",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Existing Subscription was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Subscription: Get Deleted Resource",
                "id": "X075_Subscription",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Deleted Subscription was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Subscription"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0504d4d3261a6600000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:50:44.846-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a4b4d4d3266f8f60200"
        },
        "created_at": {
            "$date": "2015-10-02T18:50:51.061-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Substance: Read Type",
                "id": "X000_Substance",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Substance: Create New",
                "id": "X010_Substance",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "New Substance was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Substance: Read Existing",
                "id": "X020_Substance",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Successfully read preexisting Substance.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Substance: Update Existing",
                "id": "X030_Substance",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Updated existing Substance.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Substance: Read History of existing",
                "id": "X040_Substance",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Substance: Version read existing",
                "id": "X050_Substance",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Read current version of preexisting Substance.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Substance: Previous version read existing",
                "id": "X055_Substance",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Read previous version of preexisting Substance.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Substance: Validate",
                "id": "X060_Substance",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Substance was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Substance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Substance: Validate Existing",
                "id": "X065_Substance",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Existing Substance was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Substance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Substance: Validate against a profile",
                "id": "X067_Substance",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Substance was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Substance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Substance: Delete Existing",
                "id": "X070_Substance",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Existing Substance was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Substance: Get Deleted Resource",
                "id": "X075_Substance",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Deleted Substance was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Substance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0504d4d3261a6610000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:50:51.061-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a514d4d3266f8f70200"
        },
        "created_at": {
            "$date": "2015-10-02T18:50:57.646-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "SupplyDelivery: Read Type",
                "id": "X000_SupplyDelivery",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "SupplyDelivery: Create New",
                "id": "X010_SupplyDelivery",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "New SupplyDelivery was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "SupplyDelivery: Read Existing",
                "id": "X020_SupplyDelivery",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Successfully read preexisting SupplyDelivery.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SupplyDelivery: Update Existing",
                "id": "X030_SupplyDelivery",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Updated existing SupplyDelivery.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "SupplyDelivery: Read History of existing",
                "id": "X040_SupplyDelivery",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "SupplyDelivery: Version read existing",
                "id": "X050_SupplyDelivery",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Read current version of preexisting SupplyDelivery.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "SupplyDelivery: Previous version read existing",
                "id": "X055_SupplyDelivery",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Read previous version of preexisting SupplyDelivery.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "SupplyDelivery: Validate",
                "id": "X060_SupplyDelivery",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "SupplyDelivery was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SupplyDelivery"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SupplyDelivery: Validate Existing",
                "id": "X065_SupplyDelivery",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Existing SupplyDelivery was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SupplyDelivery"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "SupplyDelivery: Validate against a profile",
                "id": "X067_SupplyDelivery",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "SupplyDelivery was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SupplyDelivery"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SupplyDelivery: Delete Existing",
                "id": "X070_SupplyDelivery",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Existing SupplyDelivery was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SupplyDelivery: Get Deleted Resource",
                "id": "X075_SupplyDelivery",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Deleted SupplyDelivery was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0504d4d3261a6620000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:50:57.646-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a594d4d3266f8f80200"
        },
        "created_at": {
            "$date": "2015-10-02T18:51:05.940-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "SupplyRequest: Read Type",
                "id": "X000_SupplyRequest",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "SupplyRequest: Create New",
                "id": "X010_SupplyRequest",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "New SupplyRequest was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "SupplyRequest: Read Existing",
                "id": "X020_SupplyRequest",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Successfully read preexisting SupplyRequest.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SupplyRequest: Update Existing",
                "id": "X030_SupplyRequest",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Updated existing SupplyRequest.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "SupplyRequest: Read History of existing",
                "id": "X040_SupplyRequest",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "SupplyRequest: Version read existing",
                "id": "X050_SupplyRequest",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Read current version of preexisting SupplyRequest.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "SupplyRequest: Previous version read existing",
                "id": "X055_SupplyRequest",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Read previous version of preexisting SupplyRequest.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "SupplyRequest: Validate",
                "id": "X060_SupplyRequest",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "SupplyRequest was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SupplyRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SupplyRequest: Validate Existing",
                "id": "X065_SupplyRequest",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Existing SupplyRequest was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SupplyRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "SupplyRequest: Validate against a profile",
                "id": "X067_SupplyRequest",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "SupplyRequest was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "SupplyRequest"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SupplyRequest: Delete Existing",
                "id": "X070_SupplyRequest",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Existing SupplyRequest was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "SupplyRequest: Get Deleted Resource",
                "id": "X075_SupplyRequest",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Deleted SupplyRequest was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0504d4d3261a6630000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:51:05.940-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a654d4d3266f8f90200"
        },
        "created_at": {
            "$date": "2015-10-02T18:51:17.907-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "TestScript: Read Type",
                "id": "X000_TestScript",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "TestScript: Create New",
                "id": "X010_TestScript",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "New TestScript was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "TestScript: Read Existing",
                "id": "X020_TestScript",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Successfully read preexisting TestScript.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "TestScript: Update Existing",
                "id": "X030_TestScript",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Updated existing TestScript.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "TestScript: Read History of existing",
                "id": "X040_TestScript",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "TestScript: Version read existing",
                "id": "X050_TestScript",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Read current version of preexisting TestScript.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "TestScript: Previous version read existing",
                "id": "X055_TestScript",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Read previous version of preexisting TestScript.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "TestScript: Validate",
                "id": "X060_TestScript",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "TestScript was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "TestScript"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "TestScript: Validate Existing",
                "id": "X065_TestScript",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Existing TestScript was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "TestScript"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "TestScript: Validate against a profile",
                "id": "X067_TestScript",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "TestScript was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "TestScript"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "TestScript: Delete Existing",
                "id": "X070_TestScript",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Existing TestScript was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "TestScript: Get Deleted Resource",
                "id": "X075_TestScript",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Deleted TestScript was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "TestScript"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6640000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:51:17.907-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a734d4d3266f8fa0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:51:31.238-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "ValueSet: Read Type",
                "id": "X000_ValueSet",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "ValueSet: Create New",
                "id": "X010_ValueSet",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "New ValueSet was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "ValueSet: Read Existing",
                "id": "X020_ValueSet",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Successfully read preexisting ValueSet.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ValueSet: Update Existing",
                "id": "X030_ValueSet",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Updated existing ValueSet.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "ValueSet: Read History of existing",
                "id": "X040_ValueSet",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ValueSet: Version read existing",
                "id": "X050_ValueSet",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Read current version of preexisting ValueSet.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "ValueSet: Previous version read existing",
                "id": "X055_ValueSet",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Read previous version of preexisting ValueSet.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ValueSet: Validate",
                "id": "X060_ValueSet",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "ValueSet was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ValueSet"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ValueSet: Validate Existing",
                "id": "X065_ValueSet",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Existing ValueSet was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ValueSet"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "ValueSet: Validate against a profile",
                "id": "X067_ValueSet",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "ValueSet was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "ValueSet"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ValueSet: Delete Existing",
                "id": "X070_ValueSet",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Existing ValueSet was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "ValueSet: Get Deleted Resource",
                "id": "X075_ValueSet",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Deleted ValueSet was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6650000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:51:31.238-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a7b4d4d3266f8fb0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:51:39.730-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "VisionPrescription: Read Type",
                "id": "X000_VisionPrescription",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "VisionPrescription: Create New",
                "id": "X010_VisionPrescription",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "New VisionPrescription was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "VisionPrescription: Read Existing",
                "id": "X020_VisionPrescription",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Successfully read preexisting VisionPrescription.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "VisionPrescription: Update Existing",
                "id": "X030_VisionPrescription",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Updated existing VisionPrescription.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "VisionPrescription: Read History of existing",
                "id": "X040_VisionPrescription",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "VisionPrescription: Version read existing",
                "id": "X050_VisionPrescription",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Read current version of preexisting VisionPrescription.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "VisionPrescription: Previous version read existing",
                "id": "X055_VisionPrescription",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Read previous version of preexisting VisionPrescription.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "VisionPrescription: Validate",
                "id": "X060_VisionPrescription",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "VisionPrescription was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "VisionPrescription"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "VisionPrescription: Validate Existing",
                "id": "X065_VisionPrescription",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Existing VisionPrescription was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "VisionPrescription"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "VisionPrescription: Validate against a profile",
                "id": "X067_VisionPrescription",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "VisionPrescription was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "VisionPrescription"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "VisionPrescription: Delete Existing",
                "id": "X070_VisionPrescription",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Existing VisionPrescription was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "VisionPrescription: Get Deleted Resource",
                "id": "X075_VisionPrescription",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Deleted VisionPrescription was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6660000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:51:39.730-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0a984d4d3266f8fe0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:08.973-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test \"SR01#{action[0]}\",\"Patient Matching using an MPI (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient.html#match\"\n          validates resource: 'Patient', methods: ['search']\n          validates extensions: ['extensions']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_query' => 'mpi',\n              'given' => @patient.name[0].given[0]\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)        \n \n        has_mpi_data = true\n        has_score = true\n        reply.resource.entry.each do |entry|\n          has_score = has_score && entry.try(:search).try(:score)\n          entry_has_mpi_data = false\n          if entry.search\n            entry.search.extension.each do |e|\n              if (e.url=='http://hl7.org/fhir/StructureDefinition/patient-mpi-match' && e.value && e.value.type=='code' && ['certain','probable','possible','certainly-not'].include?(e.value.value))\n                entry_has_mpi_data = true\n              end\n            end\n          end\n          has_mpi_data = has_mpi_data && entry_has_mpi_data\n        end\n        assert( has_score && has_mpi_data, \"Every Patient Matching result requires a score and 'patient-mpi-match' extension.\", reply.body)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Patient Matching using an MPI (POST)",
                "id": "SR01P",
                "key": "SR01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient.html#match"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "sr01p_patient_matching_using_an_mpi_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "extensions": [
                            "extensions"
                        ]
                    }
                ]
            },
            {
                "code": "      test \"SR01#{action[0]}\",\"Patient Matching using an MPI (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient.html#match\"\n          validates resource: 'Patient', methods: ['search']\n          validates extensions: ['extensions']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_query' => 'mpi',\n              'given' => @patient.name[0].given[0]\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)        \n \n        has_mpi_data = true\n        has_score = true\n        reply.resource.entry.each do |entry|\n          has_score = has_score && entry.try(:search).try(:score)\n          entry_has_mpi_data = false\n          if entry.search\n            entry.search.extension.each do |e|\n              if (e.url=='http://hl7.org/fhir/StructureDefinition/patient-mpi-match' && e.value && e.value.type=='code' && ['certain','probable','possible','certainly-not'].include?(e.value.value))\n                entry_has_mpi_data = true\n              end\n            end\n          end\n          has_mpi_data = has_mpi_data && entry_has_mpi_data\n        end\n        assert( has_score && has_mpi_data, \"Every Patient Matching result requires a score and 'patient-mpi-match' extension.\", reply.body)\n      end\n",
                "description": "Patient Matching using an MPI (GET)",
                "id": "SR01G",
                "key": "SR01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient.html#match"
                ],
                "message": null,
                "status": "pass",
                "test_method": "sr01g_patient_matching_using_an_mpi_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    },
                    {
                        "extensions": [
                            "extensions"
                        ]
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0554d4d3261a6c40000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:08.973-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0aa14d4d3266f8ff0200"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:17.776-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Account",
                "id": "S000_Account",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Account",
                "id": "S001P_Account",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Account",
                "id": "S003P_Account",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Account",
                "id": "SE01P_Account",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/account.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Account",
                "id": "S001G_Account",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Account",
                "id": "S003G_Account",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Account",
                "id": "SE01G_Account",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/account.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Account"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6670000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:17.776-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0aa54d4d3266f8000300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:21.321-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification AllergyIntolerance",
                "id": "S000_AllergyIntolerance",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) AllergyIntolerance",
                "id": "S001P_AllergyIntolerance",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) AllergyIntolerance",
                "id": "S003P_AllergyIntolerance",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) AllergyIntolerance",
                "id": "SE01P_AllergyIntolerance",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) AllergyIntolerance",
                "id": "S001G_AllergyIntolerance",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) AllergyIntolerance",
                "id": "S003G_AllergyIntolerance",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) AllergyIntolerance",
                "id": "SE01G_AllergyIntolerance",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6680000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:21.321-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0aa84d4d3266f8010300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:24.255-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Appointment",
                "id": "S000_Appointment",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Appointment",
                "id": "S001P_Appointment",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Appointment",
                "id": "S003P_Appointment",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Appointment",
                "id": "SE01P_Appointment",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/appointment.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Appointment",
                "id": "S001G_Appointment",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Appointment",
                "id": "S003G_Appointment",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Appointment",
                "id": "SE01G_Appointment",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/appointment.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Appointment"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6690000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:24.255-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0aaa4d4d3266f8020300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:26.911-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification AppointmentResponse",
                "id": "S000_AppointmentResponse",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) AppointmentResponse",
                "id": "S001P_AppointmentResponse",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) AppointmentResponse",
                "id": "S003P_AppointmentResponse",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) AppointmentResponse",
                "id": "SE01P_AppointmentResponse",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) AppointmentResponse",
                "id": "S001G_AppointmentResponse",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) AppointmentResponse",
                "id": "S003G_AppointmentResponse",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) AppointmentResponse",
                "id": "SE01G_AppointmentResponse",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a66a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:26.911-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ab14d4d3266f8030300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:33.833-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification AuditEvent",
                "id": "S000_AuditEvent",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) AuditEvent",
                "id": "S001P_AuditEvent",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) AuditEvent",
                "id": "S003P_AuditEvent",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) AuditEvent",
                "id": "SE01P_AuditEvent",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/auditevent.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) AuditEvent",
                "id": "S001G_AuditEvent",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) AuditEvent",
                "id": "S003G_AuditEvent",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": null,
                "description": "Search without criteria (GET) AuditEvent",
                "id": "SE01G_AuditEvent",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/auditevent.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Searching without criteria did not return all the results. Expected: 5831, but found: 5830.",
                "status": "fail",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a66b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:33.833-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ab74d4d3266f8040300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:39.459-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Basic",
                "id": "S000_Basic",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Basic",
                "id": "S001P_Basic",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Basic",
                "id": "S003P_Basic",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Basic",
                "id": "SE01P_Basic",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/basic.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Basic",
                "id": "S001G_Basic",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Basic",
                "id": "S003G_Basic",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Basic",
                "id": "SE01G_Basic",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/basic.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Basic"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a66c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:39.459-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ab94d4d3266f8050300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:41.993-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Binary",
                "id": "S000_Binary",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Binary",
                "id": "S001P_Binary",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Binary",
                "id": "S003P_Binary",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Binary",
                "id": "SE01P_Binary",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/binary.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>",
                "description": "Search by ID (GET) Binary",
                "id": "S001G_Binary",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "status": "fail",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>",
                "description": "Search limit by _count (GET) Binary",
                "id": "S003G_Binary",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "status": "fail",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>",
                "description": "Search without criteria (GET) Binary",
                "id": "SE01G_Binary",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/binary.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 400. ",
                "status": "fail",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Binary"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a66d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:41.993-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0abd4d4d3266f8060300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:45.662-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification BodySite",
                "id": "S000_BodySite",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) BodySite",
                "id": "S001P_BodySite",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) BodySite",
                "id": "S003P_BodySite",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) BodySite",
                "id": "SE01P_BodySite",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/bodysite.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) BodySite",
                "id": "S001G_BodySite",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) BodySite",
                "id": "S003G_BodySite",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bodysite.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "BodySite"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) BodySite",
                "id": "SE01G_BodySite",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/bodysite.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "BodySite"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a66e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:45.662-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ac04d4d3266f8070300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:48.513-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Bundle",
                "id": "S000_Bundle",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Bundle",
                "id": "S001P_Bundle",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Bundle",
                "id": "S003P_Bundle",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Bundle",
                "id": "SE01P_Bundle",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/bundle.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Bundle",
                "id": "S001G_Bundle",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Bundle",
                "id": "S003G_Bundle",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/bundle.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Bundle"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Bundle",
                "id": "SE01G_Bundle",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/bundle.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Bundle"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a66f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:48.513-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ac84d4d3266f8080300"
        },
        "created_at": {
            "$date": "2015-10-02T18:52:56.512-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification CarePlan",
                "id": "S000_CarePlan",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) CarePlan",
                "id": "S001P_CarePlan",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) CarePlan",
                "id": "S003P_CarePlan",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) CarePlan",
                "id": "SE01P_CarePlan",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/careplan.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) CarePlan",
                "id": "S001G_CarePlan",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) CarePlan",
                "id": "S003G_CarePlan",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/careplan.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) CarePlan",
                "id": "SE01G_CarePlan",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/careplan.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "CarePlan"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6700000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:52:56.512-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ace4d4d3266f8090300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:02.518-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Claim",
                "id": "S000_Claim",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Claim",
                "id": "S001P_Claim",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Claim",
                "id": "S003P_Claim",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Claim",
                "id": "SE01P_Claim",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/claim.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Claim",
                "id": "S001G_Claim",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Claim",
                "id": "S003G_Claim",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claim.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Claim"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Claim",
                "id": "SE01G_Claim",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/claim.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Claim"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6710000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:02.518-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ad14d4d3266f80a0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:05.455-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ClaimResponse",
                "id": "S000_ClaimResponse",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ClaimResponse",
                "id": "S001P_ClaimResponse",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ClaimResponse",
                "id": "S003P_ClaimResponse",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ClaimResponse",
                "id": "SE01P_ClaimResponse",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/claimresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ClaimResponse",
                "id": "S001G_ClaimResponse",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ClaimResponse",
                "id": "S003G_ClaimResponse",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/claimresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ClaimResponse",
                "id": "SE01G_ClaimResponse",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/claimresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ClaimResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6720000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:05.455-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ad44d4d3266f80b0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:08.932-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ClinicalImpression",
                "id": "S000_ClinicalImpression",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ClinicalImpression",
                "id": "S001P_ClinicalImpression",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ClinicalImpression",
                "id": "S003P_ClinicalImpression",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ClinicalImpression",
                "id": "SE01P_ClinicalImpression",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ClinicalImpression",
                "id": "S001G_ClinicalImpression",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ClinicalImpression",
                "id": "S003G_ClinicalImpression",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ClinicalImpression",
                "id": "SE01G_ClinicalImpression",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/clinicalimpression.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ClinicalImpression"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6730000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:08.932-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ad84d4d3266f80c0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:12.143-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Communication",
                "id": "S000_Communication",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Communication",
                "id": "S001P_Communication",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Communication",
                "id": "S003P_Communication",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Communication",
                "id": "SE01P_Communication",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/communication.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Communication",
                "id": "S001G_Communication",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Communication",
                "id": "S003G_Communication",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communication.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Communication"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Communication",
                "id": "SE01G_Communication",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/communication.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Communication"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6740000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:12.143-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0adb4d4d3266f80d0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:15.403-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification CommunicationRequest",
                "id": "S000_CommunicationRequest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) CommunicationRequest",
                "id": "S001P_CommunicationRequest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) CommunicationRequest",
                "id": "S003P_CommunicationRequest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) CommunicationRequest",
                "id": "SE01P_CommunicationRequest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) CommunicationRequest",
                "id": "S001G_CommunicationRequest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) CommunicationRequest",
                "id": "S003G_CommunicationRequest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) CommunicationRequest",
                "id": "SE01G_CommunicationRequest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/communicationrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "CommunicationRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0514d4d3261a6750000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:15.403-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ade4d4d3266f80e0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:18.317-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Composition",
                "id": "S000_Composition",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Composition",
                "id": "S001P_Composition",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Composition",
                "id": "S003P_Composition",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Composition",
                "id": "SE01P_Composition",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/composition.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Composition",
                "id": "S001G_Composition",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Composition",
                "id": "S003G_Composition",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/composition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Composition"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Composition",
                "id": "SE01G_Composition",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/composition.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Composition"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6760000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:18.317-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ae94d4d3266f80f0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:29.936-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ConceptMap",
                "id": "S000_ConceptMap",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ConceptMap",
                "id": "S001P_ConceptMap",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ConceptMap",
                "id": "S003P_ConceptMap",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ConceptMap",
                "id": "SE01P_ConceptMap",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/conceptmap.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ConceptMap",
                "id": "S001G_ConceptMap",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ConceptMap",
                "id": "S003G_ConceptMap",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conceptmap.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ConceptMap",
                "id": "SE01G_ConceptMap",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/conceptmap.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ConceptMap"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6770000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:29.936-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0aee4d4d3266f8100300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:34.868-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Condition",
                "id": "S000_Condition",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Condition",
                "id": "S001P_Condition",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Condition",
                "id": "S003P_Condition",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Condition",
                "id": "SE01P_Condition",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/condition.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Condition",
                "id": "S001G_Condition",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Condition",
                "id": "S003G_Condition",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/condition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Condition",
                "id": "SE01G_Condition",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/condition.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6780000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:34.868-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0af14d4d3266f8110300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:37.698-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Conformance",
                "id": "S000_Conformance",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Conformance",
                "id": "S001P_Conformance",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Conformance",
                "id": "S003P_Conformance",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Conformance",
                "id": "SE01P_Conformance",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/conformance.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Conformance",
                "id": "S001G_Conformance",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Conformance",
                "id": "S003G_Conformance",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/conformance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Conformance"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Conformance",
                "id": "SE01G_Conformance",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/conformance.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Conformance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6790000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:37.698-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0af44d4d3266f8120300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:40.772-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Contract",
                "id": "S000_Contract",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Contract",
                "id": "S001P_Contract",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Contract",
                "id": "S003P_Contract",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Contract",
                "id": "SE01P_Contract",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/contract.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Contract",
                "id": "S001G_Contract",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Contract",
                "id": "S003G_Contract",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/contract.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Contract"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Contract",
                "id": "SE01G_Contract",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/contract.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Contract"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a67a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:40.772-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0af84d4d3266f8130300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:44.061-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Coverage",
                "id": "S000_Coverage",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Coverage",
                "id": "S001P_Coverage",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Coverage",
                "id": "S003P_Coverage",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Coverage",
                "id": "SE01P_Coverage",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/coverage.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Coverage",
                "id": "S001G_Coverage",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Coverage",
                "id": "S003G_Coverage",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/coverage.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Coverage"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Coverage",
                "id": "SE01G_Coverage",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/coverage.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Coverage"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a67b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:44.061-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0afd4d4d3266f8140300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:49.856-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification DataElement",
                "id": "S000_DataElement",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DataElement",
                "id": "S001P_DataElement",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DataElement",
                "id": "S003P_DataElement",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DataElement",
                "id": "SE01P_DataElement",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/dataelement.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DataElement",
                "id": "S001G_DataElement",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DataElement",
                "id": "S003G_DataElement",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/dataelement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DataElement"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DataElement",
                "id": "SE01G_DataElement",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/dataelement.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DataElement"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a67c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:49.856-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b014d4d3266f8150300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:53.414-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification DetectedIssue",
                "id": "S000_DetectedIssue",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DetectedIssue",
                "id": "S001P_DetectedIssue",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DetectedIssue",
                "id": "S003P_DetectedIssue",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DetectedIssue",
                "id": "SE01P_DetectedIssue",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/detectedissue.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DetectedIssue",
                "id": "S001G_DetectedIssue",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DetectedIssue",
                "id": "S003G_DetectedIssue",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/detectedissue.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DetectedIssue",
                "id": "SE01G_DetectedIssue",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/detectedissue.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DetectedIssue"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a67d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:53.414-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b044d4d3266f8160300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:56.604-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Device",
                "id": "S000_Device",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Device",
                "id": "S001P_Device",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Device",
                "id": "S003P_Device",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Device",
                "id": "SE01P_Device",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/device.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Device",
                "id": "S001G_Device",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Device",
                "id": "S003G_Device",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/device.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Device"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Device",
                "id": "SE01G_Device",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/device.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Device"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a67e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:56.604-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b074d4d3266f8170300"
        },
        "created_at": {
            "$date": "2015-10-02T18:53:59.906-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification DeviceComponent",
                "id": "S000_DeviceComponent",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DeviceComponent",
                "id": "S001P_DeviceComponent",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DeviceComponent",
                "id": "S003P_DeviceComponent",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DeviceComponent",
                "id": "SE01P_DeviceComponent",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DeviceComponent",
                "id": "S001G_DeviceComponent",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DeviceComponent",
                "id": "S003G_DeviceComponent",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DeviceComponent",
                "id": "SE01G_DeviceComponent",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/devicecomponent.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DeviceComponent"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a67f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:53:59.906-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b0b4d4d3266f8180300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:03.100-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification DeviceMetric",
                "id": "S000_DeviceMetric",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DeviceMetric",
                "id": "S001P_DeviceMetric",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DeviceMetric",
                "id": "S003P_DeviceMetric",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DeviceMetric",
                "id": "SE01P_DeviceMetric",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/devicemetric.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DeviceMetric",
                "id": "S001G_DeviceMetric",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DeviceMetric",
                "id": "S003G_DeviceMetric",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/devicemetric.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DeviceMetric",
                "id": "SE01G_DeviceMetric",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/devicemetric.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DeviceMetric"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6800000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:03.100-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b0e4d4d3266f8190300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:06.175-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification DeviceUseRequest",
                "id": "S000_DeviceUseRequest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DeviceUseRequest",
                "id": "S001P_DeviceUseRequest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DeviceUseRequest",
                "id": "S003P_DeviceUseRequest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DeviceUseRequest",
                "id": "SE01P_DeviceUseRequest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DeviceUseRequest",
                "id": "S001G_DeviceUseRequest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DeviceUseRequest",
                "id": "S003G_DeviceUseRequest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DeviceUseRequest",
                "id": "SE01G_DeviceUseRequest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/deviceuserequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DeviceUseRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6810000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:06.175-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b114d4d3266f81a0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:09.652-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification DeviceUseStatement",
                "id": "S000_DeviceUseStatement",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DeviceUseStatement",
                "id": "S001P_DeviceUseStatement",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DeviceUseStatement",
                "id": "S003P_DeviceUseStatement",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DeviceUseStatement",
                "id": "SE01P_DeviceUseStatement",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DeviceUseStatement",
                "id": "S001G_DeviceUseStatement",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DeviceUseStatement",
                "id": "S003G_DeviceUseStatement",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DeviceUseStatement",
                "id": "SE01G_DeviceUseStatement",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/deviceusestatement.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DeviceUseStatement"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6820000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:09.652-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b154d4d3266f81b0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:13.798-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification DiagnosticOrder",
                "id": "S000_DiagnosticOrder",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DiagnosticOrder",
                "id": "S001P_DiagnosticOrder",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DiagnosticOrder",
                "id": "S003P_DiagnosticOrder",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DiagnosticOrder",
                "id": "SE01P_DiagnosticOrder",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DiagnosticOrder",
                "id": "S001G_DiagnosticOrder",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DiagnosticOrder",
                "id": "S003G_DiagnosticOrder",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DiagnosticOrder",
                "id": "SE01G_DiagnosticOrder",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/diagnosticorder.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DiagnosticOrder"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6830000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:13.798-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b1f4d4d3266f81c0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:23.091-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification DiagnosticReport",
                "id": "S000_DiagnosticReport",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DiagnosticReport",
                "id": "S001P_DiagnosticReport",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DiagnosticReport",
                "id": "S003P_DiagnosticReport",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DiagnosticReport",
                "id": "SE01P_DiagnosticReport",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DiagnosticReport",
                "id": "S001G_DiagnosticReport",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DiagnosticReport",
                "id": "S003G_DiagnosticReport",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DiagnosticReport",
                "id": "SE01G_DiagnosticReport",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/diagnosticreport.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DiagnosticReport"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6840000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:23.091-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b224d4d3266f81d0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:26.353-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification DocumentManifest",
                "id": "S000_DocumentManifest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DocumentManifest",
                "id": "S001P_DocumentManifest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DocumentManifest",
                "id": "S003P_DocumentManifest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DocumentManifest",
                "id": "SE01P_DocumentManifest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DocumentManifest",
                "id": "S001G_DocumentManifest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DocumentManifest",
                "id": "S003G_DocumentManifest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DocumentManifest",
                "id": "SE01G_DocumentManifest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/documentmanifest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DocumentManifest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6850000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:26.353-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b254d4d3266f81e0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:29.802-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification DocumentReference",
                "id": "S000_DocumentReference",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) DocumentReference",
                "id": "S001P_DocumentReference",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) DocumentReference",
                "id": "S003P_DocumentReference",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) DocumentReference",
                "id": "SE01P_DocumentReference",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/documentreference.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) DocumentReference",
                "id": "S001G_DocumentReference",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) DocumentReference",
                "id": "S003G_DocumentReference",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/documentreference.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) DocumentReference",
                "id": "SE01G_DocumentReference",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/documentreference.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "DocumentReference"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6860000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:29.802-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b284d4d3266f81f0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:32.692-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification EligibilityRequest",
                "id": "S000_EligibilityRequest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) EligibilityRequest",
                "id": "S001P_EligibilityRequest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) EligibilityRequest",
                "id": "S003P_EligibilityRequest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) EligibilityRequest",
                "id": "SE01P_EligibilityRequest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) EligibilityRequest",
                "id": "S001G_EligibilityRequest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) EligibilityRequest",
                "id": "S003G_EligibilityRequest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) EligibilityRequest",
                "id": "SE01G_EligibilityRequest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/eligibilityrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EligibilityRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6870000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:32.692-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b2c4d4d3266f8200300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:36.230-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification EligibilityResponse",
                "id": "S000_EligibilityResponse",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) EligibilityResponse",
                "id": "S001P_EligibilityResponse",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) EligibilityResponse",
                "id": "S003P_EligibilityResponse",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) EligibilityResponse",
                "id": "SE01P_EligibilityResponse",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) EligibilityResponse",
                "id": "S001G_EligibilityResponse",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) EligibilityResponse",
                "id": "S003G_EligibilityResponse",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) EligibilityResponse",
                "id": "SE01G_EligibilityResponse",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/eligibilityresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EligibilityResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6880000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:36.230-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b314d4d3266f8210300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:41.521-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Encounter",
                "id": "S000_Encounter",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Encounter",
                "id": "S001P_Encounter",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Encounter",
                "id": "S003P_Encounter",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Encounter",
                "id": "SE01P_Encounter",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/encounter.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Encounter",
                "id": "S001G_Encounter",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Encounter",
                "id": "S003G_Encounter",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/encounter.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Encounter"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Encounter",
                "id": "SE01G_Encounter",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/encounter.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Encounter"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a6890000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:41.521-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b344d4d3266f8220300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:44.455-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification EnrollmentRequest",
                "id": "S000_EnrollmentRequest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) EnrollmentRequest",
                "id": "S001P_EnrollmentRequest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) EnrollmentRequest",
                "id": "S003P_EnrollmentRequest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) EnrollmentRequest",
                "id": "SE01P_EnrollmentRequest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) EnrollmentRequest",
                "id": "S001G_EnrollmentRequest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) EnrollmentRequest",
                "id": "S003G_EnrollmentRequest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) EnrollmentRequest",
                "id": "SE01G_EnrollmentRequest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/enrollmentrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EnrollmentRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a68a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:44.455-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b374d4d3266f8230300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:47.246-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification EnrollmentResponse",
                "id": "S000_EnrollmentResponse",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) EnrollmentResponse",
                "id": "S001P_EnrollmentResponse",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) EnrollmentResponse",
                "id": "S003P_EnrollmentResponse",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) EnrollmentResponse",
                "id": "SE01P_EnrollmentResponse",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) EnrollmentResponse",
                "id": "S001G_EnrollmentResponse",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) EnrollmentResponse",
                "id": "S003G_EnrollmentResponse",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) EnrollmentResponse",
                "id": "SE01G_EnrollmentResponse",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/enrollmentresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EnrollmentResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a68b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:47.246-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b3a4d4d3266f8240300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:50.212-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification EpisodeOfCare",
                "id": "S000_EpisodeOfCare",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) EpisodeOfCare",
                "id": "S001P_EpisodeOfCare",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) EpisodeOfCare",
                "id": "S003P_EpisodeOfCare",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) EpisodeOfCare",
                "id": "SE01P_EpisodeOfCare",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) EpisodeOfCare",
                "id": "S001G_EpisodeOfCare",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) EpisodeOfCare",
                "id": "S003G_EpisodeOfCare",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) EpisodeOfCare",
                "id": "SE01G_EpisodeOfCare",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/episodeofcare.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "EpisodeOfCare"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0524d4d3261a68c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:50.212-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b3d4d4d3266f8250300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:53.173-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ExplanationOfBenefit",
                "id": "S000_ExplanationOfBenefit",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ExplanationOfBenefit",
                "id": "S001P_ExplanationOfBenefit",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ExplanationOfBenefit",
                "id": "S003P_ExplanationOfBenefit",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ExplanationOfBenefit",
                "id": "SE01P_ExplanationOfBenefit",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ExplanationOfBenefit",
                "id": "S001G_ExplanationOfBenefit",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ExplanationOfBenefit",
                "id": "S003G_ExplanationOfBenefit",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ExplanationOfBenefit",
                "id": "SE01G_ExplanationOfBenefit",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/explanationofbenefit.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ExplanationOfBenefit"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a68d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:53.173-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b404d4d3266f8260300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:56.413-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification FamilyMemberHistory",
                "id": "S000_FamilyMemberHistory",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) FamilyMemberHistory",
                "id": "S001P_FamilyMemberHistory",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) FamilyMemberHistory",
                "id": "S003P_FamilyMemberHistory",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) FamilyMemberHistory",
                "id": "SE01P_FamilyMemberHistory",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) FamilyMemberHistory",
                "id": "S001G_FamilyMemberHistory",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) FamilyMemberHistory",
                "id": "S003G_FamilyMemberHistory",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) FamilyMemberHistory",
                "id": "SE01G_FamilyMemberHistory",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/familymemberhistory.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "FamilyMemberHistory"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a68e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:56.413-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b434d4d3266f8270300"
        },
        "created_at": {
            "$date": "2015-10-02T18:54:59.743-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Flag",
                "id": "S000_Flag",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Flag",
                "id": "S001P_Flag",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Flag",
                "id": "S003P_Flag",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Flag",
                "id": "SE01P_Flag",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/flag.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Flag",
                "id": "S001G_Flag",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Flag",
                "id": "S003G_Flag",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/flag.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Flag"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Flag",
                "id": "SE01G_Flag",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/flag.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Flag"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a68f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:54:59.743-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b474d4d3266f8280300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:03.269-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Goal",
                "id": "S000_Goal",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Goal",
                "id": "S001P_Goal",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Goal",
                "id": "S003P_Goal",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Goal",
                "id": "SE01P_Goal",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/goal.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Goal",
                "id": "S001G_Goal",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Goal",
                "id": "S003G_Goal",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/goal.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Goal"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Goal",
                "id": "SE01G_Goal",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/goal.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Goal"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6900000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:03.269-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b4b4d4d3266f8290300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:07.025-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification Group",
                "id": "S000_Group",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Group",
                "id": "S001P_Group",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Group",
                "id": "S003P_Group",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Group",
                "id": "SE01P_Group",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/group.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Group",
                "id": "S001G_Group",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Group",
                "id": "S003G_Group",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/group.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Group"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Group",
                "id": "SE01G_Group",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/group.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Group"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6910000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:07.025-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b4e4d4d3266f82a0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:10.501-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification HealthcareService",
                "id": "S000_HealthcareService",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) HealthcareService",
                "id": "S001P_HealthcareService",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) HealthcareService",
                "id": "S003P_HealthcareService",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) HealthcareService",
                "id": "SE01P_HealthcareService",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) HealthcareService",
                "id": "S001G_HealthcareService",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) HealthcareService",
                "id": "S003G_HealthcareService",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) HealthcareService",
                "id": "SE01G_HealthcareService",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/healthcareservice.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "HealthcareService"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6920000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:10.501-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b564d4d3266f82b0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:18.107-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ImagingObjectSelection",
                "id": "S000_ImagingObjectSelection",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ImagingObjectSelection",
                "id": "S001P_ImagingObjectSelection",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ImagingObjectSelection",
                "id": "S003P_ImagingObjectSelection",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ImagingObjectSelection",
                "id": "SE01P_ImagingObjectSelection",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ImagingObjectSelection",
                "id": "S001G_ImagingObjectSelection",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'identifier'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>",
                "description": "Search limit by _count (GET) ImagingObjectSelection",
                "id": "S003G_ImagingObjectSelection",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 500. ",
                "status": "fail",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'identifier'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>",
                "description": "Search without criteria (GET) ImagingObjectSelection",
                "id": "SE01G_ImagingObjectSelection",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/imagingobjectselection.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 500. ",
                "status": "fail",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ImagingObjectSelection"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6930000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:18.107-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b5b4d4d3266f82c0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:23.942-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ImagingStudy",
                "id": "S000_ImagingStudy",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ImagingStudy",
                "id": "S001P_ImagingStudy",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ImagingStudy",
                "id": "S003P_ImagingStudy",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ImagingStudy",
                "id": "SE01P_ImagingStudy",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ImagingStudy",
                "id": "S001G_ImagingStudy",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'study'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>",
                "description": "Search limit by _count (GET) ImagingStudy",
                "id": "S003G_ImagingStudy",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 500. ",
                "status": "fail",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'study'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>",
                "description": "Search without criteria (GET) ImagingStudy",
                "id": "SE01G_ImagingStudy",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/imagingstudy.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 500. ",
                "status": "fail",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ImagingStudy"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6940000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:23.942-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b5e4d4d3266f82d0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:26.841-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Immunization",
                "id": "S000_Immunization",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Immunization",
                "id": "S001P_Immunization",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Immunization",
                "id": "S003P_Immunization",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Immunization",
                "id": "SE01P_Immunization",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/immunization.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Immunization",
                "id": "S001G_Immunization",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Immunization",
                "id": "S003G_Immunization",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunization.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Immunization"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Immunization",
                "id": "SE01G_Immunization",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/immunization.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Immunization"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6950000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:26.841-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b624d4d3266f82e0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:30.117-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ImmunizationRecommendation",
                "id": "S000_ImmunizationRecommendation",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ImmunizationRecommendation",
                "id": "S001P_ImmunizationRecommendation",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ImmunizationRecommendation",
                "id": "S003P_ImmunizationRecommendation",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ImmunizationRecommendation",
                "id": "SE01P_ImmunizationRecommendation",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ImmunizationRecommendation",
                "id": "S001G_ImmunizationRecommendation",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ImmunizationRecommendation",
                "id": "S003G_ImmunizationRecommendation",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ImmunizationRecommendation",
                "id": "SE01G_ImmunizationRecommendation",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ImmunizationRecommendation"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6960000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:30.117-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b644d4d3266f82f0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:32.599-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ImplementationGuide",
                "id": "S000_ImplementationGuide",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ImplementationGuide",
                "id": "S001P_ImplementationGuide",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ImplementationGuide",
                "id": "S003P_ImplementationGuide",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ImplementationGuide",
                "id": "SE01P_ImplementationGuide",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/implementationguide.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ImplementationGuide",
                "id": "S001G_ImplementationGuide",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ImplementationGuide",
                "id": "S003G_ImplementationGuide",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/implementationguide.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ImplementationGuide",
                "id": "SE01G_ImplementationGuide",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/implementationguide.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ImplementationGuide"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6970000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:32.599-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b6d4d4d3266f8300300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:41.953-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification List",
                "id": "S000_List",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) List",
                "id": "S001P_List",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) List",
                "id": "S003P_List",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) List",
                "id": "SE01P_List",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/list.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) List",
                "id": "S001G_List",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) List",
                "id": "S003G_List",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/list.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "List"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) List",
                "id": "SE01G_List",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/list.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "List"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6980000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:41.953-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b704d4d3266f8310300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:44.955-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Location",
                "id": "S000_Location",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Location",
                "id": "S001P_Location",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Location",
                "id": "S003P_Location",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Location",
                "id": "SE01P_Location",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/location.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Location",
                "id": "S001G_Location",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Location",
                "id": "S003G_Location",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/location.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Location"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Location",
                "id": "SE01G_Location",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/location.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Location"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6990000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:44.955-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b734d4d3266f8320300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:47.509-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Media",
                "id": "S000_Media",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Media",
                "id": "S001P_Media",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Media",
                "id": "S003P_Media",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Media",
                "id": "SE01P_Media",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/media.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Media",
                "id": "S001G_Media",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Media",
                "id": "S003G_Media",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/media.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Media"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Media",
                "id": "SE01G_Media",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/media.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Media"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a69a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:47.509-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b774d4d3266f8330300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:51.932-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Medication",
                "id": "S000_Medication",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Medication",
                "id": "S001P_Medication",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Medication",
                "id": "S003P_Medication",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Medication",
                "id": "SE01P_Medication",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medication.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Medication",
                "id": "S001G_Medication",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Medication",
                "id": "S003G_Medication",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medication.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Medication"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Medication",
                "id": "SE01G_Medication",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medication.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Medication"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a69b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:51.932-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b7b4d4d3266f8340300"
        },
        "created_at": {
            "$date": "2015-10-02T18:55:55.106-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification MedicationAdministration",
                "id": "S000_MedicationAdministration",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) MedicationAdministration",
                "id": "S001P_MedicationAdministration",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) MedicationAdministration",
                "id": "S003P_MedicationAdministration",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) MedicationAdministration",
                "id": "SE01P_MedicationAdministration",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) MedicationAdministration",
                "id": "S001G_MedicationAdministration",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) MedicationAdministration",
                "id": "S003G_MedicationAdministration",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) MedicationAdministration",
                "id": "SE01G_MedicationAdministration",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medicationadministration.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MedicationAdministration"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a69c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:55:55.106-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b804d4d3266f8350300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:00.217-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification MedicationDispense",
                "id": "S000_MedicationDispense",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) MedicationDispense",
                "id": "S001P_MedicationDispense",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) MedicationDispense",
                "id": "S003P_MedicationDispense",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) MedicationDispense",
                "id": "SE01P_MedicationDispense",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) MedicationDispense",
                "id": "S001G_MedicationDispense",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) MedicationDispense",
                "id": "S003G_MedicationDispense",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) MedicationDispense",
                "id": "SE01G_MedicationDispense",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medicationdispense.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MedicationDispense"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a69d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:00.217-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b874d4d3266f8360300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:07.116-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification MedicationOrder",
                "id": "S000_MedicationOrder",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) MedicationOrder",
                "id": "S001P_MedicationOrder",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) MedicationOrder",
                "id": "S003P_MedicationOrder",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) MedicationOrder",
                "id": "SE01P_MedicationOrder",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medicationorder.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) MedicationOrder",
                "id": "S001G_MedicationOrder",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) MedicationOrder",
                "id": "S003G_MedicationOrder",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) MedicationOrder",
                "id": "SE01G_MedicationOrder",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medicationorder.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MedicationOrder"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a69e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:07.116-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b8b4d4d3266f8370300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:11.456-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification MedicationStatement",
                "id": "S000_MedicationStatement",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) MedicationStatement",
                "id": "S001P_MedicationStatement",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) MedicationStatement",
                "id": "S003P_MedicationStatement",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) MedicationStatement",
                "id": "SE01P_MedicationStatement",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) MedicationStatement",
                "id": "S001G_MedicationStatement",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) MedicationStatement",
                "id": "S003G_MedicationStatement",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) MedicationStatement",
                "id": "SE01G_MedicationStatement",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/medicationstatement.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MedicationStatement"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a69f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:11.456-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b8e4d4d3266f8380300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:14.156-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification MessageHeader",
                "id": "S000_MessageHeader",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) MessageHeader",
                "id": "S001P_MessageHeader",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) MessageHeader",
                "id": "S003P_MessageHeader",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) MessageHeader",
                "id": "SE01P_MessageHeader",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/messageheader.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) MessageHeader",
                "id": "S001G_MessageHeader",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) MessageHeader",
                "id": "S003G_MessageHeader",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/messageheader.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) MessageHeader",
                "id": "SE01G_MessageHeader",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/messageheader.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "MessageHeader"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a00000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:14.156-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b934d4d3266f8390300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:19.352-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification NamingSystem",
                "id": "S000_NamingSystem",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) NamingSystem",
                "id": "S001P_NamingSystem",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) NamingSystem",
                "id": "S003P_NamingSystem",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) NamingSystem",
                "id": "SE01P_NamingSystem",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/namingsystem.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) NamingSystem",
                "id": "S001G_NamingSystem",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) NamingSystem",
                "id": "S003G_NamingSystem",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/namingsystem.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) NamingSystem",
                "id": "SE01G_NamingSystem",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/namingsystem.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "NamingSystem"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a10000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:19.352-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0b994d4d3266f83a0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:25.532-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification NutritionOrder",
                "id": "S000_NutritionOrder",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) NutritionOrder",
                "id": "S001P_NutritionOrder",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) NutritionOrder",
                "id": "S003P_NutritionOrder",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) NutritionOrder",
                "id": "SE01P_NutritionOrder",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) NutritionOrder",
                "id": "S001G_NutritionOrder",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) NutritionOrder",
                "id": "S003G_NutritionOrder",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) NutritionOrder",
                "id": "SE01G_NutritionOrder",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/nutritionorder.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "NutritionOrder"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a20000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:25.532-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ba04d4d3266f83b0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:32.396-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification Observation",
                "id": "S000_Observation",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Observation",
                "id": "S001P_Observation",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Observation",
                "id": "S003P_Observation",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Observation",
                "id": "SE01P_Observation",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/observation.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Observation",
                "id": "S001G_Observation",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Observation",
                "id": "S003G_Observation",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/observation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Observation",
                "id": "SE01G_Observation",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/observation.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a30000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:32.396-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ba34d4d3266f83c0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:35.628-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification OperationDefinition",
                "id": "S000_OperationDefinition",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) OperationDefinition",
                "id": "S001P_OperationDefinition",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) OperationDefinition",
                "id": "S003P_OperationDefinition",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) OperationDefinition",
                "id": "SE01P_OperationDefinition",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) OperationDefinition",
                "id": "S001G_OperationDefinition",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) OperationDefinition",
                "id": "S003G_OperationDefinition",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) OperationDefinition",
                "id": "SE01G_OperationDefinition",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operationdefinition.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "OperationDefinition"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a40000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:35.628-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ba64d4d3266f83d0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:38.442-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification OperationOutcome",
                "id": "S000_OperationOutcome",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) OperationOutcome",
                "id": "S001P_OperationOutcome",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) OperationOutcome",
                "id": "S003P_OperationOutcome",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) OperationOutcome",
                "id": "SE01P_OperationOutcome",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) OperationOutcome",
                "id": "S001G_OperationOutcome",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) OperationOutcome",
                "id": "S003G_OperationOutcome",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) OperationOutcome",
                "id": "SE01G_OperationOutcome",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/operationoutcome.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "OperationOutcome"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a50000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:38.442-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0ba94d4d3266f83e0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:41.518-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Order",
                "id": "S000_Order",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Order",
                "id": "S001P_Order",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Order",
                "id": "S003P_Order",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Order",
                "id": "SE01P_Order",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/order.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Order",
                "id": "S001G_Order",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Order",
                "id": "S003G_Order",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/order.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Order"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Order",
                "id": "SE01G_Order",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/order.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Order"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a60000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:41.518-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bac4d4d3266f83f0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:44.581-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification OrderResponse",
                "id": "S000_OrderResponse",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) OrderResponse",
                "id": "S001P_OrderResponse",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) OrderResponse",
                "id": "S003P_OrderResponse",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) OrderResponse",
                "id": "SE01P_OrderResponse",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/orderresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) OrderResponse",
                "id": "S001G_OrderResponse",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) OrderResponse",
                "id": "S003G_OrderResponse",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/orderresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) OrderResponse",
                "id": "SE01G_OrderResponse",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/orderresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "OrderResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a70000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:44.581-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bb14d4d3266f8400300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:49.288-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Organization",
                "id": "S000_Organization",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Organization",
                "id": "S001P_Organization",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Organization",
                "id": "S003P_Organization",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Organization",
                "id": "SE01P_Organization",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/organization.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Organization",
                "id": "S001G_Organization",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Organization",
                "id": "S003G_Organization",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/organization.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Organization"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Organization",
                "id": "SE01G_Organization",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/organization.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Organization"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a80000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:49.288-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bb64d4d3266f8410300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:54.003-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Patient",
                "id": "S000_Patient",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Patient",
                "id": "S001P_Patient",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Patient",
                "id": "S003P_Patient",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Patient",
                "id": "SE01P_Patient",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Patient",
                "id": "S001G_Patient",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Patient",
                "id": "S003G_Patient",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/patient.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Patient",
                "id": "SE01G_Patient",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/patient.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0534d4d3261a6a90000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:54.003-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bb84d4d3266f8420300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:56.816-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification PaymentNotice",
                "id": "S000_PaymentNotice",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) PaymentNotice",
                "id": "S001P_PaymentNotice",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) PaymentNotice",
                "id": "S003P_PaymentNotice",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) PaymentNotice",
                "id": "SE01P_PaymentNotice",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) PaymentNotice",
                "id": "S001G_PaymentNotice",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) PaymentNotice",
                "id": "S003G_PaymentNotice",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) PaymentNotice",
                "id": "SE01G_PaymentNotice",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/paymentnotice.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "PaymentNotice"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6aa0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:56.816-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bbb4d4d3266f8430300"
        },
        "created_at": {
            "$date": "2015-10-02T18:56:59.444-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification PaymentReconciliation",
                "id": "S000_PaymentReconciliation",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) PaymentReconciliation",
                "id": "S001P_PaymentReconciliation",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) PaymentReconciliation",
                "id": "S003P_PaymentReconciliation",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) PaymentReconciliation",
                "id": "SE01P_PaymentReconciliation",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) PaymentReconciliation",
                "id": "S001G_PaymentReconciliation",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) PaymentReconciliation",
                "id": "S003G_PaymentReconciliation",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) PaymentReconciliation",
                "id": "SE01G_PaymentReconciliation",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/paymentreconciliation.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "PaymentReconciliation"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6ab0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:56:59.444-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bbf4d4d3266f8440300"
        },
        "created_at": {
            "$date": "2015-10-02T18:57:03.329-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Person",
                "id": "S000_Person",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Person",
                "id": "S001P_Person",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Person",
                "id": "S003P_Person",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Person",
                "id": "SE01P_Person",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/person.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Person",
                "id": "S001G_Person",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Person",
                "id": "S003G_Person",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/person.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Person"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Person",
                "id": "SE01G_Person",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/person.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Person"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6ac0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:57:03.329-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bc44d4d3266f8450300"
        },
        "created_at": {
            "$date": "2015-10-02T18:57:08.853-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Practitioner",
                "id": "S000_Practitioner",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Practitioner",
                "id": "S001P_Practitioner",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Practitioner",
                "id": "S003P_Practitioner",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Practitioner",
                "id": "SE01P_Practitioner",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/practitioner.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Practitioner",
                "id": "S001G_Practitioner",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Practitioner",
                "id": "S003G_Practitioner",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/practitioner.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Practitioner",
                "id": "SE01G_Practitioner",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/practitioner.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Practitioner"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6ad0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:57:08.853-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bc94d4d3266f8460300"
        },
        "created_at": {
            "$date": "2015-10-02T18:57:13.500-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Procedure",
                "id": "S000_Procedure",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Procedure",
                "id": "S001P_Procedure",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Procedure",
                "id": "S003P_Procedure",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Procedure",
                "id": "SE01P_Procedure",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/procedure.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Procedure",
                "id": "S001G_Procedure",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Procedure",
                "id": "S003G_Procedure",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedure.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Procedure"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Procedure",
                "id": "SE01G_Procedure",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/procedure.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Procedure"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6ae0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:57:13.500-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bcc4d4d3266f8470300"
        },
        "created_at": {
            "$date": "2015-10-02T18:57:16.542-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ProcedureRequest",
                "id": "S000_ProcedureRequest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ProcedureRequest",
                "id": "S001P_ProcedureRequest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ProcedureRequest",
                "id": "S003P_ProcedureRequest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ProcedureRequest",
                "id": "SE01P_ProcedureRequest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ProcedureRequest",
                "id": "S001G_ProcedureRequest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ProcedureRequest",
                "id": "S003G_ProcedureRequest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ProcedureRequest",
                "id": "SE01G_ProcedureRequest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/procedurerequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ProcedureRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6af0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:57:16.542-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bcf4d4d3266f8480300"
        },
        "created_at": {
            "$date": "2015-10-02T18:57:19.703-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ProcessRequest",
                "id": "S000_ProcessRequest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ProcessRequest",
                "id": "S001P_ProcessRequest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ProcessRequest",
                "id": "S003P_ProcessRequest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ProcessRequest",
                "id": "SE01P_ProcessRequest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/processrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ProcessRequest",
                "id": "S001G_ProcessRequest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ProcessRequest",
                "id": "S003G_ProcessRequest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ProcessRequest",
                "id": "SE01G_ProcessRequest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/processrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ProcessRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b00000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:57:19.703-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bd34d4d3266f8490300"
        },
        "created_at": {
            "$date": "2015-10-02T18:57:23.124-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ProcessResponse",
                "id": "S000_ProcessResponse",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ProcessResponse",
                "id": "S001P_ProcessResponse",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ProcessResponse",
                "id": "S003P_ProcessResponse",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ProcessResponse",
                "id": "SE01P_ProcessResponse",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/processresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ProcessResponse",
                "id": "S001G_ProcessResponse",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ProcessResponse",
                "id": "S003G_ProcessResponse",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/processresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ProcessResponse",
                "id": "SE01G_ProcessResponse",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/processresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ProcessResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b10000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:57:23.124-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bd64d4d3266f84a0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:57:26.226-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Provenance",
                "id": "S000_Provenance",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Provenance",
                "id": "S001P_Provenance",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Provenance",
                "id": "S003P_Provenance",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Provenance",
                "id": "SE01P_Provenance",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/provenance.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Provenance",
                "id": "S001G_Provenance",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Provenance",
                "id": "S003G_Provenance",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/provenance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Provenance",
                "id": "SE01G_Provenance",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/provenance.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Provenance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b20000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:57:26.226-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bf04d4d3266f84b0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:57:52.808-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Questionnaire",
                "id": "S000_Questionnaire",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Questionnaire",
                "id": "S001P_Questionnaire",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Questionnaire",
                "id": "S003P_Questionnaire",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Questionnaire",
                "id": "SE01P_Questionnaire",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/questionnaire.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Questionnaire",
                "id": "S001G_Questionnaire",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Questionnaire",
                "id": "S003G_Questionnaire",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaire.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Questionnaire",
                "id": "SE01G_Questionnaire",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/questionnaire.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Questionnaire"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b30000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:57:52.808-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bfa4d4d3266f84c0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:02.623-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification QuestionnaireResponse",
                "id": "S000_QuestionnaireResponse",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) QuestionnaireResponse",
                "id": "S001P_QuestionnaireResponse",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) QuestionnaireResponse",
                "id": "S003P_QuestionnaireResponse",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) QuestionnaireResponse",
                "id": "SE01P_QuestionnaireResponse",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) QuestionnaireResponse",
                "id": "S001G_QuestionnaireResponse",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) QuestionnaireResponse",
                "id": "S003G_QuestionnaireResponse",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) QuestionnaireResponse",
                "id": "SE01G_QuestionnaireResponse",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/questionnaireresponse.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "QuestionnaireResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b40000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:02.623-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0bfd4d4d3266f84d0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:05.324-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ReferralRequest",
                "id": "S000_ReferralRequest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ReferralRequest",
                "id": "S001P_ReferralRequest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ReferralRequest",
                "id": "S003P_ReferralRequest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ReferralRequest",
                "id": "SE01P_ReferralRequest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/referralrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ReferralRequest",
                "id": "S001G_ReferralRequest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ReferralRequest",
                "id": "S003G_ReferralRequest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/referralrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ReferralRequest",
                "id": "SE01G_ReferralRequest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/referralrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ReferralRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b50000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:05.324-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c004d4d3266f84e0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:08.775-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification RelatedPerson",
                "id": "S000_RelatedPerson",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) RelatedPerson",
                "id": "S001P_RelatedPerson",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) RelatedPerson",
                "id": "S003P_RelatedPerson",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) RelatedPerson",
                "id": "SE01P_RelatedPerson",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/relatedperson.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) RelatedPerson",
                "id": "S001G_RelatedPerson",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) RelatedPerson",
                "id": "S003G_RelatedPerson",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/relatedperson.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) RelatedPerson",
                "id": "SE01G_RelatedPerson",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/relatedperson.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "RelatedPerson"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b60000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:08.775-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c034d4d3266f84f0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:11.765-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification RiskAssessment",
                "id": "S000_RiskAssessment",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) RiskAssessment",
                "id": "S001P_RiskAssessment",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) RiskAssessment",
                "id": "S003P_RiskAssessment",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) RiskAssessment",
                "id": "SE01P_RiskAssessment",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/riskassessment.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) RiskAssessment",
                "id": "S001G_RiskAssessment",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) RiskAssessment",
                "id": "S003G_RiskAssessment",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/riskassessment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) RiskAssessment",
                "id": "SE01G_RiskAssessment",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/riskassessment.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "RiskAssessment"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b70000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:11.765-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c064d4d3266f8500300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:14.391-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Schedule",
                "id": "S000_Schedule",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Schedule",
                "id": "S001P_Schedule",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Schedule",
                "id": "S003P_Schedule",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Schedule",
                "id": "SE01P_Schedule",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/schedule.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Schedule",
                "id": "S001G_Schedule",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Schedule",
                "id": "S003G_Schedule",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/schedule.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Schedule",
                "id": "SE01G_Schedule",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/schedule.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Schedule"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b80000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:14.391-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c0b4d4d3266f8510300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:19.265-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification SearchParameter",
                "id": "S000_SearchParameter",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) SearchParameter",
                "id": "S001P_SearchParameter",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) SearchParameter",
                "id": "S003P_SearchParameter",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) SearchParameter",
                "id": "SE01P_SearchParameter",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/searchparameter.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) SearchParameter",
                "id": "S001G_SearchParameter",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) SearchParameter",
                "id": "S003G_SearchParameter",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/searchparameter.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) SearchParameter",
                "id": "SE01G_SearchParameter",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/searchparameter.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "SearchParameter"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6b90000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:19.265-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c0e4d4d3266f8520300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:22.525-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Slot",
                "id": "S000_Slot",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Slot",
                "id": "S001P_Slot",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Slot",
                "id": "S003P_Slot",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Slot",
                "id": "SE01P_Slot",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/slot.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Slot",
                "id": "S001G_Slot",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Slot",
                "id": "S003G_Slot",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/slot.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Slot",
                "id": "SE01G_Slot",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/slot.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Slot"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6ba0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:22.525-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c124d4d3266f8530300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:26.541-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Specimen",
                "id": "S000_Specimen",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Specimen",
                "id": "S001P_Specimen",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Specimen",
                "id": "S003P_Specimen",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Specimen",
                "id": "SE01P_Specimen",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/specimen.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Specimen",
                "id": "S001G_Specimen",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Specimen",
                "id": "S003G_Specimen",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/specimen.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Specimen"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Specimen",
                "id": "SE01G_Specimen",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/specimen.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Specimen"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6bb0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:26.541-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c324d4d3266f8540300"
        },
        "created_at": {
            "$date": "2015-10-02T18:58:58.176-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "data": null,
                "description": "Compare supported search parameters with specification StructureDefinition",
                "id": "S000_StructureDefinition",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "The server does not support searching all the parameters specified by the specification.",
                "status": "fail",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) StructureDefinition",
                "id": "S001P_StructureDefinition",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) StructureDefinition",
                "id": "S003P_StructureDefinition",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) StructureDefinition",
                "id": "SE01P_StructureDefinition",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) StructureDefinition",
                "id": "S001G_StructureDefinition",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) StructureDefinition",
                "id": "S003G_StructureDefinition",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) StructureDefinition",
                "id": "SE01G_StructureDefinition",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/structuredefinition.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "StructureDefinition"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6bc0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:58:58.176-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c354d4d3266f8550300"
        },
        "created_at": {
            "$date": "2015-10-02T18:59:01.353-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Subscription",
                "id": "S000_Subscription",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Subscription",
                "id": "S001P_Subscription",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Subscription",
                "id": "S003P_Subscription",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Subscription",
                "id": "SE01P_Subscription",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/subscription.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Subscription",
                "id": "S001G_Subscription",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Subscription",
                "id": "S003G_Subscription",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/subscription.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Subscription"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Subscription",
                "id": "SE01G_Subscription",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/subscription.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Subscription"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6bd0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:59:01.353-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c384d4d3266f8560300"
        },
        "created_at": {
            "$date": "2015-10-02T18:59:04.369-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification Substance",
                "id": "S000_Substance",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) Substance",
                "id": "S001P_Substance",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) Substance",
                "id": "S003P_Substance",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) Substance",
                "id": "SE01P_Substance",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/substance.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) Substance",
                "id": "S001G_Substance",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) Substance",
                "id": "S003G_Substance",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/substance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Substance"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) Substance",
                "id": "SE01G_Substance",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/substance.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "Substance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6be0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:59:04.369-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c3b4d4d3266f8570300"
        },
        "created_at": {
            "$date": "2015-10-02T18:59:07.215-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification SupplyDelivery",
                "id": "S000_SupplyDelivery",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) SupplyDelivery",
                "id": "S001P_SupplyDelivery",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) SupplyDelivery",
                "id": "S003P_SupplyDelivery",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) SupplyDelivery",
                "id": "SE01P_SupplyDelivery",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) SupplyDelivery",
                "id": "S001G_SupplyDelivery",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) SupplyDelivery",
                "id": "S003G_SupplyDelivery",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) SupplyDelivery",
                "id": "SE01G_SupplyDelivery",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/supplydelivery.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "SupplyDelivery"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6bf0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:59:07.215-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c3d4d4d3266f8580300"
        },
        "created_at": {
            "$date": "2015-10-02T18:59:09.771-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification SupplyRequest",
                "id": "S000_SupplyRequest",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) SupplyRequest",
                "id": "S001P_SupplyRequest",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) SupplyRequest",
                "id": "S003P_SupplyRequest",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) SupplyRequest",
                "id": "SE01P_SupplyRequest",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) SupplyRequest",
                "id": "S001G_SupplyRequest",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) SupplyRequest",
                "id": "S003G_SupplyRequest",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) SupplyRequest",
                "id": "SE01G_SupplyRequest",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/supplyrequest.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "SupplyRequest"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6c00000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:59:09.771-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c434d4d3266f8590300"
        },
        "created_at": {
            "$date": "2015-10-02T18:59:15.382-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification TestScript",
                "id": "S000_TestScript",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) TestScript",
                "id": "S001P_TestScript",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) TestScript",
                "id": "S003P_TestScript",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) TestScript",
                "id": "SE01P_TestScript",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/testscript.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) TestScript",
                "id": "S001G_TestScript",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) TestScript",
                "id": "S003G_TestScript",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/testscript.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "TestScript"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) TestScript",
                "id": "SE01G_TestScript",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/testscript.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "TestScript"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6c10000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:59:15.382-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c504d4d3266f85a0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:59:28.518-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification ValueSet",
                "id": "S000_ValueSet",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) ValueSet",
                "id": "S001P_ValueSet",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) ValueSet",
                "id": "S003P_ValueSet",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) ValueSet",
                "id": "SE01P_ValueSet",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/valueset.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) ValueSet",
                "id": "S001G_ValueSet",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) ValueSet",
                "id": "S003G_ValueSet",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/valueset.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) ValueSet",
                "id": "SE01G_ValueSet",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/valueset.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "ValueSet"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0544d4d3261a6c20000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:59:28.518-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c534d4d3266f85b0300"
        },
        "created_at": {
            "$date": "2015-10-02T18:59:31.919-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n",
                "description": "Compare supported search parameters with specification VisionPrescription",
                "id": "S000_VisionPrescription",
                "key": "S000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s000_compare_supported_search_parameters_with_specification_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search by ID (POST) VisionPrescription",
                "id": "S001P_VisionPrescription",
                "key": "S001P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s001p_search_by_id_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search limit by _count (POST) VisionPrescription",
                "id": "S003P_VisionPrescription",
                "key": "S003P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "s003p_search_limit_by__count_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search without criteria (POST) VisionPrescription",
                "id": "SE01P_VisionPrescription",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/visionprescription.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_without_criteria_(post)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search by ID (GET) VisionPrescription",
                "id": "S001G_VisionPrescription",
                "key": "S001G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s001g_search_by_id_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n",
                "description": "Search limit by _count (GET) VisionPrescription",
                "id": "S003G_VisionPrescription",
                "key": "S003G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/visionprescription.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "s003g_search_limit_by__count_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n",
                "description": "Search without criteria (GET) VisionPrescription",
                "id": "SE01G_VisionPrescription",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/visionprescription.html",
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_without_criteria_(get)_test",
                "validates": [
                    {
                        "methods": [
                            "read",
                            "search"
                        ],
                        "resource": "VisionPrescription"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0554d4d3261a6c30000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T18:59:31.919-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f0c854d4d3266f85e0300"
        },
        "created_at": {
            "$date": "2015-10-02T19:00:21.757-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test \"SE01#{action[0]}\",'Search patients without criteria (except _count)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.entry.size, 'The server did not return the correct number of results.'\n        warning { assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.' }\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search patients without criteria (except _count)",
                "id": "SE01P",
                "key": "SE01P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se01p_search_patients_without_criteria_(except__count)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE02#{action[0]}\", 'Search on non-existing resource' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n        }\n        options = {\n          :resource => Crucible::Tests::SprinklerSearchTest,\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search_all(options)\n        assert( (reply.code >= 400 && reply.code < 600), 'If the search fails, the return value should be status code 4xx or 5xx.', reply)\n      end\n",
                "description": "Search on non-existing resource",
                "id": "SE02P",
                "key": "SE02P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se02p_search_on_non-existing_resource_test"
            },
            {
                "code": "      test \"SE03#{action[0]}\",'Search patient resource on partial family surname' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        search_string = @patient.name[0].family[0][0..2]\n        search_regex = Regexp.new(search_string)\n        # how many patients in the bundle have matching names?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          isMatch = false\n          if !patient.nil? && !patient.name.nil?\n            patient.name.each do |name|\n              if !name.family.nil?\n                name.family.each do |family|\n                  if !(family =~ search_regex).nil?\n                    isMatch = true\n                  end\n                end\n              end\n            end\n          end\n          expected += 1 if isMatch\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'family' => search_string\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search patient resource on partial family surname",
                "id": "SE03P",
                "key": "SE03P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se03p_search_patient_resource_on_partial_family_surname_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE04#{action[0]}\", 'Search patient resource on given name' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        search_string = @patient.name[0].given[0]\n        search_regex = Regexp.new(search_string)\n        # how many patients in the bundle have matching names?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          isMatch = false\n          if !patient.nil? && !patient.name.nil?\n            patient.name.each do |name|\n              if !name.given.nil?\n                name.given.each do |given|\n                  if !(given =~ search_regex).nil?\n                    isMatch = true\n                  end\n                end\n              end\n            end\n          end\n          expected += 1 if isMatch\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'given' => search_string\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search patient resource on given name",
                "id": "SE04P",
                "key": "SE04P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se04p_search_patient_resource_on_given_name_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE05.0#{action[0]}\", 'Search condition by patient reference url (partial)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.resource_url(options)\n        patient_url = patient_url[1..-1] if patient_url[0]=='/'\n        @client.use_format_param = temp\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition by patient reference url (partial)",
                "id": "SE05.0P",
                "key": "SE05.0P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se05.0p_search_condition_by_patient_reference_url_(partial)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.0F#{action[0]}\", 'Search condition by patient reference url (full)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.full_resource_url(options)\n        @client.use_format_param = temp\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition by patient reference url (full)",
                "id": "SE05.0FP",
                "key": "SE05.0FP",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se05.0fp_search_condition_by_patient_reference_url_(full)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.1#{action[0]}\", 'Search condition by patient reference id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition by patient reference id",
                "id": "SE05.1P",
                "key": "SE05.1P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se05.1p_search_condition_by_patient_reference_id_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.2#{action[0]}\", 'Search condition by patient:Patient reference url' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.resource_url(options)\n        patient_url = patient_url[1..-1] if patient_url[0]=='/'\n        @client.use_format_param = temp\n       \n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient:Patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition by patient:Patient reference url",
                "id": "SE05.2P",
                "key": "SE05.2P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se05.2p_search_condition_by_patient:patient_reference_url_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.3#{action[0]}\", 'Search condition by patient:Patient reference id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient = @entries[0].resource\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient:Patient' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition by patient:Patient reference id",
                "id": "SE05.3P",
                "key": "SE05.3P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se05.3p_search_condition_by_patient:patient_reference_id_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.4#{action[0]}\", 'Search condition by patient:_id reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient._id' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition by patient:_id reference",
                "id": "SE05.4P",
                "key": "SE05.4P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se05.4p_search_condition_by_patient:_id_reference_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.5#{action[0]}\", 'Search condition by patient:name reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_name = @patient.name[0].family[0]\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient.name' => patient_name\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition by patient:name reference",
                "id": "SE05.5P",
                "key": "SE05.5P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se05.5p_search_condition_by_patient:name_reference_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.6#{action[0]}\", 'Search condition by patient:identifier reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @patient_id\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_identifier = @patient.identifier[0].value\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient.identifier' => patient_identifier\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition by patient:identifier reference",
                "id": "SE05.6P",
                "key": "SE05.6P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se05.6p_search_condition_by_patient:identifier_reference_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE06#{action[0]}\", 'Search condition and _include' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @patient_id\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_identifier = @patient.identifier[0].value\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_include' => 'Condition:patient'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert reply.resource.total > 0, 'The server should have Conditions that _include=Condition:patient.'\n        has_patient = false\n        reply.resource.entry.each do |entry|\n          has_patient = true if (entry.resourceType == 'Patient')\n        end\n        assert(has_patient,'The server did not include the Patient referenced in the Condition.', reply.body)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search condition and _include",
                "id": "SE06P",
                "key": "SE06P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se06p_search_condition_and__include_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE21#{action[0]}\", 'Search for quantity (in observation) - precision tests' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html#quantity\"\n          links \"#{BASE_SPEC_LINK}/observation.html#search\"\n          validates resource: \"Observation\", methods: [\"search\"]\n        }\n        skip unless (@obs_a && @obs_b && @obs_c)\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'value-quantity' => '4.1234||mmol'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Observation, options)\n        has_obs_a = has_obs_b = has_obs_c = false\n        while reply != nil\n          assert_response_ok(reply)\n          assert_bundle_response(reply)\n          has_obs_a = true if reply.resource.get_by_id(@obs_a)\n          has_obs_b = true if reply.resource.get_by_id(@obs_b)\n          has_obs_c = true if reply.resource.get_by_id(@obs_c)\n          reply = @client.next_page(reply)\n        end\n\n        assert has_obs_a,  'Search on quantity value 4.1234 should return 4.12345'\n        assert !has_obs_b, 'Search on quantity value 4.1234 should not return 4.12346'\n        assert !has_obs_c, 'Search on quantity value 4.1234 should not return 4.12349'\n      end\n",
                "data": null,
                "description": "Search for quantity (in observation) - precision tests",
                "id": "SE21P",
                "key": "SE21P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html#quantity",
                    "http://hl7.org/fhir/DSTU2/observation.html#search"
                ],
                "message": "Skipped: se21p_search_for_quantity_(in_observation)_-_precision_tests_test",
                "status": "skip",
                "test_method": "se21p_search_for_quantity_(in_observation)_-_precision_tests_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"SE22#{action[0]}\", 'Search for quantity (in observation) - operators' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html#quantity\"\n          links \"#{BASE_SPEC_LINK}/observation.html#search\"\n          validates resource: \"Observation\", methods: [\"search\"]\n        }\n        skip unless (@obs_a && @obs_d && @obs_e)\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'value-quantity' => 'gt5||mmol'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Observation, options)\n        has_obs_a = has_obs_b = has_obs_c = false\n        while reply != nil\n          assert_response_ok(reply)\n          assert_bundle_response(reply)\n          has_obs_a = true if reply.resource.get_by_id(@obs_a)\n          has_obs_d = true if reply.resource.get_by_id(@obs_d)\n          has_obs_e = true if reply.resource.get_by_id(@obs_e)\n          reply = @client.next_page(reply)\n        end\n\n        assert !has_obs_a,  'Search greater than quantity should not return lesser value.'\n        assert has_obs_d, 'Search greater than quantity should return greater value.'\n        assert has_obs_e, 'Search greater than quantity should return greater value.'\n      end\n",
                "data": null,
                "description": "Search for quantity (in observation) - operators",
                "id": "SE22P",
                "key": "SE22P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html#quantity",
                    "http://hl7.org/fhir/DSTU2/observation.html#search"
                ],
                "message": "Skipped: se22p_search_for_quantity_(in_observation)_-_operators_test",
                "status": "skip",
                "test_method": "se22p_search_for_quantity_(in_observation)_-_operators_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"SE23#{action[0]}\", 'Search with quantifier :missing, on Patient.gender' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # how many patients in the bundle have no gender?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          expected += 1 if !patient.nil? && patient.gender.nil?\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'gender:missing' => true\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search with quantifier :missing, on Patient.gender",
                "id": "SE23P",
                "key": "SE23P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se23p_search_with_quantifier_:missing,_on_patient.gender_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE24#{action[0]}\", 'Search with non-existing parameter' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        # non-existing parameters should be ignored\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'bonkers' => 'foobar'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search with non-existing parameter",
                "id": "SE24P",
                "key": "SE24P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se24p_search_with_non-existing_parameter_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE25#{action[0]}\", 'Search with malformed parameters' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        # a malformed parameters are non-existing parameters, and they should be ignored\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '...' => 'foobar'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "data": "{\"Message\":\"The requested resource does not support http method 'POST'.\"}",
                "description": "Search with malformed parameters",
                "id": "SE25P",
                "key": "SE25P",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": "Bad response code: expected 200, 201, but found 405. ",
                "status": "fail",
                "test_method": "se25p_search_with_malformed_parameters_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE01#{action[0]}\",'Search patients without criteria (except _count)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.entry.size, 'The server did not return the correct number of results.'\n        warning { assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.' }\n      end\n",
                "description": "Search patients without criteria (except _count)",
                "id": "SE01G",
                "key": "SE01G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se01g_search_patients_without_criteria_(except__count)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "The server did not report the correct number of results. Expected: 1, but found: 311."
                ]
            },
            {
                "code": "      test \"SE02#{action[0]}\", 'Search on non-existing resource' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n        }\n        options = {\n          :resource => Crucible::Tests::SprinklerSearchTest,\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search_all(options)\n        assert( (reply.code >= 400 && reply.code < 600), 'If the search fails, the return value should be status code 4xx or 5xx.', reply)\n      end\n",
                "description": "Search on non-existing resource",
                "id": "SE02G",
                "key": "SE02G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se02g_search_on_non-existing_resource_test"
            },
            {
                "code": "      test \"SE03#{action[0]}\",'Search patient resource on partial family surname' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        search_string = @patient.name[0].family[0][0..2]\n        search_regex = Regexp.new(search_string)\n        # how many patients in the bundle have matching names?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          isMatch = false\n          if !patient.nil? && !patient.name.nil?\n            patient.name.each do |name|\n              if !name.family.nil?\n                name.family.each do |family|\n                  if !(family =~ search_regex).nil?\n                    isMatch = true\n                  end\n                end\n              end\n            end\n          end\n          expected += 1 if isMatch\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'family' => search_string\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search patient resource on partial family surname",
                "id": "SE03G",
                "key": "SE03G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 2, but found: 0.",
                "status": "fail",
                "test_method": "se03g_search_patient_resource_on_partial_family_surname_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE04#{action[0]}\", 'Search patient resource on given name' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        search_string = @patient.name[0].given[0]\n        search_regex = Regexp.new(search_string)\n        # how many patients in the bundle have matching names?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          isMatch = false\n          if !patient.nil? && !patient.name.nil?\n            patient.name.each do |name|\n              if !name.given.nil?\n                name.given.each do |given|\n                  if !(given =~ search_regex).nil?\n                    isMatch = true\n                  end\n                end\n              end\n            end\n          end\n          expected += 1 if isMatch\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'given' => search_string\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search patient resource on given name",
                "id": "SE04G",
                "key": "SE04G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 3, but found: 0.",
                "status": "fail",
                "test_method": "se04g_search_patient_resource_on_given_name_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE05.0#{action[0]}\", 'Search condition by patient reference url (partial)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.resource_url(options)\n        patient_url = patient_url[1..-1] if patient_url[0]=='/'\n        @client.use_format_param = temp\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search condition by patient reference url (partial)",
                "id": "SE05.0G",
                "key": "SE05.0G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 1, but found: 0.",
                "status": "fail",
                "test_method": "se05.0g_search_condition_by_patient_reference_url_(partial)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.0F#{action[0]}\", 'Search condition by patient reference url (full)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.full_resource_url(options)\n        @client.use_format_param = temp\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search condition by patient reference url (full)",
                "id": "SE05.0FG",
                "key": "SE05.0FG",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 1, but found: 0.",
                "status": "fail",
                "test_method": "se05.0fg_search_condition_by_patient_reference_url_(full)_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.1#{action[0]}\", 'Search condition by patient reference id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search condition by patient reference id",
                "id": "SE05.1G",
                "key": "SE05.1G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 1, but found: 0.",
                "status": "fail",
                "test_method": "se05.1g_search_condition_by_patient_reference_id_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.2#{action[0]}\", 'Search condition by patient:Patient reference url' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.resource_url(options)\n        patient_url = patient_url[1..-1] if patient_url[0]=='/'\n        @client.use_format_param = temp\n       \n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient:Patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search condition by patient:Patient reference url",
                "id": "SE05.2G",
                "key": "SE05.2G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 1, but found: 23.",
                "status": "fail",
                "test_method": "se05.2g_search_condition_by_patient:patient_reference_url_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.3#{action[0]}\", 'Search condition by patient:Patient reference id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient = @entries[0].resource\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient:Patient' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search condition by patient:Patient reference id",
                "id": "SE05.3G",
                "key": "SE05.3G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 1, but found: 23.",
                "status": "fail",
                "test_method": "se05.3g_search_condition_by_patient:patient_reference_id_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.4#{action[0]}\", 'Search condition by patient:_id reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient._id' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search condition by patient:_id reference",
                "id": "SE05.4G",
                "key": "SE05.4G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 1, but found: 23.",
                "status": "fail",
                "test_method": "se05.4g_search_condition_by_patient:_id_reference_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.5#{action[0]}\", 'Search condition by patient:name reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_name = @patient.name[0].family[0]\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient.name' => patient_name\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search condition by patient:name reference",
                "id": "SE05.5G",
                "key": "SE05.5G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 1, but found: 23.",
                "status": "fail",
                "test_method": "se05.5g_search_condition_by_patient:name_reference_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE05.6#{action[0]}\", 'Search condition by patient:identifier reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @patient_id\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_identifier = @patient.identifier[0].value\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient.identifier' => patient_identifier\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search condition by patient:identifier reference",
                "id": "SE05.6G",
                "key": "SE05.6G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 1, but found: 23.",
                "status": "fail",
                "test_method": "se05.6g_search_condition_by_patient:identifier_reference_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE06#{action[0]}\", 'Search condition and _include' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @patient_id\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_identifier = @patient.identifier[0].value\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_include' => 'Condition:patient'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert reply.resource.total > 0, 'The server should have Conditions that _include=Condition:patient.'\n        has_patient = false\n        reply.resource.entry.each do |entry|\n          has_patient = true if (entry.resourceType == 'Patient')\n        end\n        assert(has_patient,'The server did not include the Patient referenced in the Condition.', reply.body)\n      end\n",
                "data": "\ufeff<Bundle xmlns=\"http://hl7.org/fhir\"><id value=\"urn:uuid:14acf86fe150472f90ca7a78317353e5\" /><meta><lastUpdated value=\"2015-10-02T23:00:15.166+00:00\" /></meta><type value=\"searchset\" /><total value=\"23\" /><link><relation value=\"self\" /><url value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition?_format=application/xml+fhir&amp;_include=Condition:patient&amp;_snapshot=635794236151661956\" /></link><link><relation value=\"first\" /><url value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition?_format=application/xml+fhir&amp;_include=Condition:patient&amp;_snapshot=635794236151661956\" /></link><link><relation value=\"next\" /><url value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition?_format=application/xml+fhir&amp;_include=Condition:patient&amp;_snapshot=635794236151661956&amp;_page=1\" /></link><link><relation value=\"last\" /><url value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition?_format=application/xml+fhir&amp;_include=Condition:patient&amp;_snapshot=635794236151661956&amp;_page=1\" /></link><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/fb4fb6a6076e4d54814cafacb96191d3/_history/47\" /><resource><Condition><id value=\"fb4fb6a6076e4d54814cafacb96191d3\" /><meta><versionId value=\"47\" /><lastUpdated value=\"2015-10-02T22:39:52.307+00:00\" /></meta><implicitRules value=\"k7UL+e8vKOr7JNZlsMIDeg==\" /><language value=\"en-US\" /><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f002</p>\r\n  <p>\r\n    <b>patient</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Encounter/f002</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 03/06/2012</p>\r\n  <p>\r\n    <b>code</b>: NSCLC - Non-small cell lung cancer <span>(Details : {SNOMED CT code '254637007' = '254637007', given as 'NSCLC - Non-small cell lung cancer'})</span></p>\r\n  <p>\r\n    <b>category</b>: diagnosis <span>(Details : {SNOMED CT code '439401001' = '439401001', given as 'diagnosis'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Severe <span>(Details : {SNOMED CT code '24484000' = '24484000', given as 'Severe'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 05/05/2011</p>\r\n  <h3>Stages</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Summary</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>stage II <span>(Details : {SNOMED CT code '258219007' = '258219007', given as 'stage II'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Code</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>CT of thorax <span>(Details : {SNOMED CT code '169069000' = '169069000', given as 'CT of thorax'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Thorax <span>(Details : {SNOMED CT code '51185008' = '51185008', given as 'Thorax'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></patient><encounter><reference value=\"Encounter/f002\" /></encounter><asserter><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></asserter><dateRecorded value=\"2015-10-02\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"254637007\" /><display value=\"NSCLC - Non-small cell lung cancer\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"439401001\" /><display value=\"diagnosis\" /></coding></category><clinicalStatus value=\"resolved\" /><verificationStatus value=\"refuted\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"24484000\" /><display value=\"Severe\" /></coding></severity><onsetDateTime value=\"2011-05-05\" /><stage><summary><coding><system value=\"http://snomed.info/sct\" /><code value=\"258219007\" /><display value=\"stage II\" /></coding></summary></stage><evidence><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"169069000\" /><display value=\"CT of thorax\" /></coding></code></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"51185008\" /><display value=\"Thorax\" /></coding></bodySite><notes value=\"EeJy9bl69PMtbaoQ3GjyEQ==\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/fb4fb6a6076e4d54814cafacb96191d3/_history/47\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/f64b8c0a4f6941f6b0caf150e28c50d8/_history/22\" /><resource><Condition><id value=\"f64b8c0a4f6941f6b0caf150e28c50d8\" /><meta><versionId value=\"22\" /><lastUpdated value=\"2015-09-29T11:46:53.04+00:00\" /></meta><implicitRules value=\"2rV0CbZdr0jzlFLwtB6Rbg==\" /><language value=\"mJEmqoLoAzICvuIJ4lzM\" /><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: Apr 4, 2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/f05ce89900d74949a29b6c0e315b89ab\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/8eb06628d1864005be9c4669f91107c3\" /></asserter><dateRecorded value=\"2015-09-24\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"resolved\" /><verificationStatus value=\"differential\" /><notes value=\"0vJafgEq+WjKCKHdPJMnqg==\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/f64b8c0a4f6941f6b0caf150e28c50d8/_history/22\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/e538f73dc9d3438ca83bcd0476ee4cbd/_history/21\" /><resource><Condition><id value=\"e538f73dc9d3438ca83bcd0476ee4cbd\" /><meta><versionId value=\"21\" /><lastUpdated value=\"2015-09-29T11:46:52.953+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">Ischemic stroke, July 18, 2010</div></text><patient><reference value=\"Patient/example\" /></patient><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"422504002\" /><display value=\"Ischemic stroke (disorder)\" /></coding><text value=\"Stroke\" /></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /><display value=\"Diagnosis\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><onsetDateTime value=\"2010-07-18\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/e538f73dc9d3438ca83bcd0476ee4cbd/_history/21\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/e2744e5eda674fb79ac25f7c052bbcd1/_history/20\" /><resource><Condition><id value=\"e2744e5eda674fb79ac25f7c052bbcd1\" /><meta><versionId value=\"20\" /><lastUpdated value=\"2015-09-29T11:46:52.92+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f204</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Roel's encounter on March eleventh</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 11/03/2013</p>\r\n  <p>\r\n    <b>code</b>: Acute renal insufficiency specified as due to procedure <span>(Details : {SNOMED CT code '36225005' = '36225005', given as 'Acute renal insufficiency specified as due to procedure'})</span></p>\r\n  <p>\r\n    <b>category</b>: Problem <span>(Details : {SNOMED CT code '55607006' = '55607006', given as 'Problem'}; {http://hl7.org/fhir/condition-category code 'finding' = 'Finding)</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n  <p>\r\n    <b>severity</b>: Severe <span>(Details : {SNOMED CT code '24484000' = '24484000', given as 'Severe'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 11/03/2013</p>\r\n  <p>\r\n    <b>abatement</b>: 20/03/2013</p>\r\n  <h3>Stages</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Summary</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>Temporary <span>(Details : {SNOMED CT code '14803004' = '14803004', given as 'Temporary'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Kidney <span>(Details : {SNOMED CT code '181414000' = '181414000', given as 'Kidney'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><encounter><reference value=\"Encounter/f203\" /><display value=\"Roel's encounter on March eleventh\" /></encounter><asserter><reference value=\"Practitioner/f201\" /></asserter><dateRecorded value=\"2013-03-11\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"36225005\" /><display value=\"Acute renal insufficiency specified as due to procedure\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"55607006\" /><display value=\"Problem\" /></coding><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"finding\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"differential\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"24484000\" /><display value=\"Severe\" /></coding></severity><onsetDateTime value=\"2013-03-11\" /><abatementDateTime value=\"2013-03-20\" /><stage><summary><coding><system value=\"http://snomed.info/sct\" /><code value=\"14803004\" /><display value=\"Temporary\" /></coding></summary></stage><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"181414000\" /><display value=\"Kidney\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/e2744e5eda674fb79ac25f7c052bbcd1/_history/20\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/e1becf46200746f69811c853e0243def/_history/19\" /><resource><Condition><id value=\"e1becf46200746f69811c853e0243def\" /><meta><versionId value=\"19\" /><lastUpdated value=\"2015-09-29T11:46:52.89+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: cond-uslab-example1</p>\r\n  <p>\r\n    <b>patient</b>: <a>Todd Lerr</a></p>\r\n  <p>\r\n    <b>code</b>: Increased lead level <span>(Details : {SNOMED CT code '407152001' = '407152001', given as 'Increased blood lead level'})</span></p>\r\n  <p>\r\n    <b>category</b>: Diagnosis <span>(Details : {http://hl7.org/fhir/condition-category code 'diagnosis' = 'Diagnosis', given as 'Diagnosis'})</span></p>\r\n  <p>\r\n    <b>verificationStatus</b>: provisional</p>\r\n  <p>\r\n    <b>notes</b>: Elevated lead levels on screening</p>\r\n</div></text><patient><reference value=\"Patient/patient-uslab-example1\" /><display value=\"Todd Lerr\" /></patient><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"407152001\" /><display value=\"Increased blood lead level\" /></coding><text value=\"Increased lead level\" /></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /><display value=\"Diagnosis\" /></coding></category><verificationStatus value=\"provisional\" /><notes value=\"Elevated lead levels on screening\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/e1becf46200746f69811c853e0243def/_history/19\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/e1ad86a294234fc3887dfdb7e3041ece/_history/18\" /><resource><Condition><id value=\"e1ad86a294234fc3887dfdb7e3041ece\" /><meta><versionId value=\"18\" /><lastUpdated value=\"2015-09-29T11:46:52.843+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: Apr 4, 2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/3631114706dd425582ffcb9ce51d0445\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/88e335d1546743728f2581e12c29429f\" /></asserter><dateRecorded value=\"2013-04-04\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"active\" /><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/e1ad86a294234fc3887dfdb7e3041ece/_history/18\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/cfba157a60924338aefaeed951022307/_history/17\" /><resource><Condition><id value=\"cfba157a60924338aefaeed951022307\" /><meta><versionId value=\"17\" /><lastUpdated value=\"2015-09-29T11:46:52.813+00:00\" /></meta><implicitRules value=\"2rV0CbZdr0jzlFLwtB6Rbg==\" /><language value=\"mJEmqoLoAzICvuIJ4lzM\" /><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: Apr 4, 2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/f05ce89900d74949a29b6c0e315b89ab\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/8eb06628d1864005be9c4669f91107c3\" /></asserter><dateRecorded value=\"2015-09-24\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"resolved\" /><verificationStatus value=\"differential\" /><notes value=\"0vJafgEq+WjKCKHdPJMnqg==\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/cfba157a60924338aefaeed951022307/_history/17\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/cb34abce81a143808e58ac12a9ced226/_history/16\" /><resource><Condition><id value=\"cb34abce81a143808e58ac12a9ced226\" /><meta><versionId value=\"16\" /><lastUpdated value=\"2015-09-29T11:46:52.78+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f201</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Encounter/f201</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 04/04/2013</p>\r\n  <p>\r\n    <b>code</b>: Fever <span>(Details : {SNOMED CT code '386661006' = '386661006', given as 'Fever'})</span></p>\r\n  <p>\r\n    <b>category</b>: Problem <span>(Details : {SNOMED CT code '55607006' = '55607006', given as 'Problem'}; {http://hl7.org/fhir/condition-category code 'finding' = 'Finding)</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Mild <span>(Details : {SNOMED CT code '255604002' = '255604002', given as 'Mild'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 02/04/2013</p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Code</b>\r\n      </td>\r\n      <td>\r\n        <b>Detail</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>degrees C <span>(Details : {SNOMED CT code '258710007' = '258710007', given as 'degrees C'})</span></td>\r\n      <td>\r\n        <a>Temperature</a>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Entire body as a whole <span>(Details : {SNOMED CT code '38266002' = '38266002', given as 'Entire body as a whole'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><encounter><reference value=\"Encounter/f201\" /></encounter><asserter><reference value=\"Practitioner/f201\" /></asserter><dateRecorded value=\"2013-04-04\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"386661006\" /><display value=\"Fever\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"55607006\" /><display value=\"Problem\" /></coding><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"finding\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"255604002\" /><display value=\"Mild\" /></coding></severity><onsetDateTime value=\"2013-04-02\" /><evidence><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"258710007\" /><display value=\"degrees C\" /></coding></code><detail><reference value=\"Observation/f202\" /><display value=\"Temperature\" /></detail></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"38266002\" /><display value=\"Entire body as a whole\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/cb34abce81a143808e58ac12a9ced226/_history/16\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/be0ea600c75d4e1abebc9b3d3b3ee815/_history/15\" /><resource><Condition><id value=\"be0ea600c75d4e1abebc9b3d3b3ee815\" /><meta><versionId value=\"15\" /><lastUpdated value=\"2015-09-29T11:46:52.75+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <div>code:Posttraumatic stress disorder (disorder)</div>\r\n  <div>verificationStatus:confirmed</div>\r\n  <div>abatementDate:1975-04-14T00:00:00-04:00</div>\r\n  <div>onsetDate:1975-04-14T00:00:00-04:00</div>\r\n</div></text><patient><reference value=\"Patient/zachary-broussard\" /><display value=\"Zachary Broussard\" /></patient><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"47505003\" /><display value=\"Posttraumatic stress disorder (disorder)\" /></coding><text value=\"Posttraumatic stress disorder (disorder)\" /></code><verificationStatus value=\"confirmed\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/be0ea600c75d4e1abebc9b3d3b3ee815/_history/15\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/bb0bca2f094648918ce71feb486ec48f/_history/14\" /><resource><Condition><id value=\"bb0bca2f094648918ce71feb486ec48f\" /><meta><versionId value=\"14\" /><lastUpdated value=\"2015-09-29T11:46:52.717+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f001</p>\r\n  <p>\r\n    <b>patient</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Encounter/f001</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 05/10/2011</p>\r\n  <p>\r\n    <b>code</b>: Heart valve disorder <span>(Details : {SNOMED CT code '368009' = '368009', given as 'Heart valve disorder'})</span></p>\r\n  <p>\r\n    <b>category</b>: diagnosis <span>(Details : {SNOMED CT code '439401001' = '439401001', given as 'diagnosis'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Moderate <span>(Details : {SNOMED CT code '6736007' = '6736007', given as 'Moderate'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 05/08/2011</p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Code</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>Cardiac chest pain <span>(Details : {SNOMED CT code '426396005' = '426396005', given as 'Cardiac chest pain'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: heart structure <span>(Details : {SNOMED CT code '40768004' = '40768004', given as 'Left thorax'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></patient><encounter><reference value=\"Encounter/f001\" /></encounter><asserter><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></asserter><dateRecorded value=\"2011-10-05\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"368009\" /><display value=\"Heart valve disorder\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"439401001\" /><display value=\"diagnosis\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"6736007\" /><display value=\"Moderate\" /></coding></severity><onsetDateTime value=\"2011-08-05\" /><evidence><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"426396005\" /><display value=\"Cardiac chest pain\" /></coding></code></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"40768004\" /><display value=\"Left thorax\" /></coding><text value=\"heart structure\" /></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/bb0bca2f094648918ce71feb486ec48f/_history/14\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/a8b25a8b7ef34e74ba95c31fd140e6c4/_history/13\" /><resource><Condition><id value=\"a8b25a8b7ef34e74ba95c31fd140e6c4\" /><meta><versionId value=\"13\" /><lastUpdated value=\"2015-09-29T11:46:52.703+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f203</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Roel's encounter on March eleventh</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 11/03/2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial sepsis <span>(Details : {SNOMED CT code '10001005' = '10001005', given as 'Bacterial sepsis'})</span></p>\r\n  <p>\r\n    <b>category</b>: Problem <span>(Details : {SNOMED CT code '55607006' = '55607006', given as 'Problem'}; {http://hl7.org/fhir/condition-category code 'finding' = 'Finding)</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Moderate to severe <span>(Details : {SNOMED CT code '371924009' = '371924009', given as 'Moderate to severe'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 08/03/2013</p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Detail</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>\r\n        <a>Diagnostic report for Roel's sepsis</a>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Pulmonary vascular structure <span>(Details : {SNOMED CT code '281158006' = '281158006', given as 'Pulmonary vascular structure'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><encounter><reference value=\"Encounter/f203\" /><display value=\"Roel's encounter on March eleventh\" /></encounter><asserter><reference value=\"Practitioner/f201\" /></asserter><dateRecorded value=\"2013-03-11\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"10001005\" /><display value=\"Bacterial sepsis\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"55607006\" /><display value=\"Problem\" /></coding><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"finding\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"371924009\" /><display value=\"Moderate to severe\" /></coding></severity><onsetDateTime value=\"2013-03-08\" /><evidence><detail><reference value=\"DiagnosticReport/f202\" /><display value=\"Diagnostic report for Roel's sepsis\" /></detail></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"281158006\" /><display value=\"Pulmonary vascular structure\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/a8b25a8b7ef34e74ba95c31fd140e6c4/_history/13\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/9833268b2e5f491b98a1a5c0e535b813/_history/12\" /><resource><Condition><id value=\"9833268b2e5f491b98a1a5c0e535b813\" /><meta><versionId value=\"12\" /><lastUpdated value=\"2015-09-29T11:46:52.67+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">Severe burn of left ear (Date: 24-May 2012)</div></text><extension url=\"http://hl7.org/fhir/StructureDefinition/condition-criticality\"><valueCodeableConcept><coding><system value=\"http://hl7.org/fhir/ValueSet/condition-severity\" /><code value=\"399166001\" /><display value=\"Fatal\" /></coding></valueCodeableConcept></extension><patient><reference value=\"Patient/example\" /></patient><code><coding><system value=\"http://hl7.org/fhir/ValueSet/daf-problem\" /><code value=\"39065001\" /><display value=\"Burn of ear\" /></coding><text value=\"Burnt Ear\" /></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /><display value=\"Diagnosis\" /></coding><coding><system value=\"http://snomed.info/sct\" /><code value=\"439401001\" /><display value=\"Diagnosis\" /></coding></category><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"24484000\" /><display value=\"Severe\" /></coding></severity><onsetDateTime value=\"2012-05-24\" /><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"49521004\" /><display value=\"Left external ear structure\" /></coding><text value=\"Left Ear\" /></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/9833268b2e5f491b98a1a5c0e535b813/_history/12\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/9054892526b04a3ab94a2264a8d9a9ee/_history/11\" /><resource><Condition><id value=\"9054892526b04a3ab94a2264a8d9a9ee\" /><meta><versionId value=\"11\" /><lastUpdated value=\"2015-09-29T11:46:52.61+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <div xmlns=\"\">code:asthma</div>\r\n  <div xmlns=\"\">verificationStatus:differential</div>\r\n</div></text><patient><reference value=\"Patient/5df8b715b3ed4225b72869dc984cf364\" /><display value=\"david hay \" /></patient><code><text value=\"asthma\" /></code><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/9054892526b04a3ab94a2264a8d9a9ee/_history/11\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/786dbc25d9a14687b4225fa3b5f71932/_history/10\" /><resource><Condition><id value=\"786dbc25d9a14687b4225fa3b5f71932\" /><meta><versionId value=\"10\" /><lastUpdated value=\"2015-09-29T11:46:52.53+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f202</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 01/12/2012</p>\r\n  <p>\r\n    <b>code</b>: Malignant neoplastic disease <span>(Details : {SNOMED CT code '363346000' = '363346000', given as 'Malignant neoplastic disease'})</span></p>\r\n  <p>\r\n    <b>category</b>: Diagnosis <span>(Details : {http://hl7.org/fhir/condition-category code 'diagnosis' = 'Diagnosis)</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Severe <span>(Details : {SNOMED CT code '24484000' = '24484000', given as 'Severe'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 52 years<span> (Details: SNOMED CT code 258707000 = '258707000')</span></p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Detail</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>\r\n        <a>Erasmus' diagnostic report of Roel's tumor</a>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Entire head and neck <span>(Details : {SNOMED CT code '361355005' = '361355005', given as 'Entire head and neck'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><dateRecorded value=\"2012-12-01\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"363346000\" /><display value=\"Malignant neoplastic disease\" /></coding></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"24484000\" /><display value=\"Severe\" /></coding></severity><onsetQuantity><value value=\"52\" /><unit value=\"years\" /><system value=\"http://snomed.info/sct\" /><code value=\"258707000\" /></onsetQuantity><evidence><detail><reference value=\"DiagnosticReport/f201\" /><display value=\"Erasmus' diagnostic report of Roel's tumor\" /></detail></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"361355005\" /><display value=\"Entire head and neck\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/786dbc25d9a14687b4225fa3b5f71932/_history/10\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/68d1644650ac47109c148d18d7c31e94/_history/9\" /><resource><Condition><id value=\"68d1644650ac47109c148d18d7c31e94\" /><meta><versionId value=\"9\" /><lastUpdated value=\"2015-09-29T11:46:52.5+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 04/04/2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/f201\" /></asserter><dateRecorded value=\"2013-04-04\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"active\" /><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/68d1644650ac47109c148d18d7c31e94/_history/9\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/50c57f80063742628757a5e9252ac804/_history/8\" /><resource><Condition><id value=\"50c57f80063742628757a5e9252ac804\" /><meta><versionId value=\"8\" /><lastUpdated value=\"2015-09-29T11:46:52.483+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <div xmlns=\"\">code:Asthma finding (finding)</div>\r\n  <div xmlns=\"\">verificationStatus:differential</div>\r\n</div></text><patient><reference value=\"Patient/89780f9eb9ab41da8ed0189807c55150\" /><display value=\"david hay\" /></patient><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"390798007\" /><display value=\"Asthma finding (finding)\" /></coding><text value=\"Asthma finding (finding)\" /></code><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/50c57f80063742628757a5e9252ac804/_history/8\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/478e0a37381f47f3ae69afd67d77c7df/_history/7\" /><resource><Condition><id value=\"478e0a37381f47f3ae69afd67d77c7df\" /><meta><versionId value=\"7\" /><lastUpdated value=\"2015-09-29T11:46:52.437+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: Apr 4, 2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/c919e3aa2e3f4ca1bc5e08c7c802f9f4\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/0e473e39e9b24ea896cc48fa22ec343b\" /></asserter><dateRecorded value=\"2013-04-04\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"active\" /><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/478e0a37381f47f3ae69afd67d77c7df/_history/7\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/3f86216bef164c15a92360dba2ef5b28/_history/6\" /><resource><Condition><id value=\"3f86216bef164c15a92360dba2ef5b28\" /><meta><versionId value=\"6\" /><lastUpdated value=\"2015-09-29T11:46:52.407+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f003</p>\r\n  <p>\r\n    <b>patient</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Encounter/f003</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 20/02/2012</p>\r\n  <p>\r\n    <b>code</b>: Retropharyngeal abscess <span>(Details : {SNOMED CT code '18099001' = '18099001', given as 'Retropharyngeal abscess'})</span></p>\r\n  <p>\r\n    <b>category</b>: diagnosis <span>(Details : {SNOMED CT code '439401001' = '439401001', given as 'diagnosis'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Mild to moderate <span>(Details : {SNOMED CT code '371923003' = '371923003', given as 'Mild to moderate'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 27/02/2012</p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Code</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>CT of neck <span>(Details : {SNOMED CT code '169068008' = '169068008', given as 'CT of neck'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Entire retropharyngeal area <span>(Details : {SNOMED CT code '280193007' = '280193007', given as 'Entire retropharyngeal area'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></patient><encounter><reference value=\"Encounter/f003\" /></encounter><asserter><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></asserter><dateRecorded value=\"2012-02-20\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"18099001\" /><display value=\"Retropharyngeal abscess\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"439401001\" /><display value=\"diagnosis\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"371923003\" /><display value=\"Mild to moderate\" /></coding></severity><onsetDateTime value=\"2012-02-27\" /><evidence><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"169068008\" /><display value=\"CT of neck\" /></coding></code></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"280193007\" /><display value=\"Entire retropharyngeal area\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/3f86216bef164c15a92360dba2ef5b28/_history/6\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/3df918d8e4774a91a9f880e8be2b26ef/_history/5\" /><resource><Condition><id value=\"3df918d8e4774a91a9f880e8be2b26ef\" /><meta><versionId value=\"5\" /><lastUpdated value=\"2015-09-29T11:46:52.36+00:00\" /></meta><implicitRules value=\"jzDd7YdIROai9Tbh8ggiCw==\" /><language value=\"X3eCOckAXdynkLZep8Zb\" /><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <div xmlns=\"\">code:asthma</div>\r\n  <div xmlns=\"\">verificationStatus:confirmed</div>\r\n</div></text><patient><reference value=\"Patient/5df8b715b3ed4225b72869dc984cf364\" /><display value=\"david hay \" /></patient><asserter><reference value=\"Practitioner/38b041800a8a43d1952ecb43439192a6\" /><display value=\"Practitioner\" /></asserter><dateRecorded value=\"2015-09-16\" /><code><text value=\"asthma\" /></code><clinicalStatus value=\"resolved\" /><verificationStatus value=\"confirmed\" /><notes value=\"s6F3OF+VYbYTBZWnLmsI9Q==\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/3df918d8e4774a91a9f880e8be2b26ef/_history/5\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/36310207febe42a495b426169d36bb44/_history/4\" /><resource><Condition><id value=\"36310207febe42a495b426169d36bb44\" /><meta><versionId value=\"4\" /><lastUpdated value=\"2015-09-29T11:46:52.327+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: cond-uslab-example2</p>\r\n  <p>\r\n    <b>patient</b>: <a>Todd Lerr</a></p>\r\n  <p>\r\n    <b>code</b>: Abnormal lead level in blood <span>(Details : {http://www.cms.gov/Medicare/Coding/ICD10/index.html code 'R78.71' = '??', given as 'Abnormal lead level in blood'})</span></p>\r\n  <p>\r\n    <b>category</b>: Diagnosis <span>(Details : {http://hl7.org/fhir/condition-category code 'diagnosis' = 'Diagnosis', given as 'Diagnosis'})</span></p>\r\n  <p>\r\n    <b>verificationStatus</b>: provisional</p>\r\n</div></text><patient><reference value=\"Patient/patient-uslab-example2\" /><display value=\"Todd Lerr\" /></patient><code><coding><system value=\"http://www.cms.gov/Medicare/Coding/ICD10/index.html\" /><code value=\"R78.71\" /><display value=\"Abnormal lead level in blood\" /></coding></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /><display value=\"Diagnosis\" /></coding></category><verificationStatus value=\"provisional\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/36310207febe42a495b426169d36bb44/_history/4\" /></request></entry></Bundle>",
                "description": "Search condition and _include",
                "id": "SE06G",
                "key": "SE06G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/condition.html#search"
                ],
                "message": "The server did not include the Patient referenced in the Condition.",
                "status": "fail",
                "test_method": "se06g_search_condition_and__include_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Condition"
                    }
                ]
            },
            {
                "code": "      test \"SE21#{action[0]}\", 'Search for quantity (in observation) - precision tests' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html#quantity\"\n          links \"#{BASE_SPEC_LINK}/observation.html#search\"\n          validates resource: \"Observation\", methods: [\"search\"]\n        }\n        skip unless (@obs_a && @obs_b && @obs_c)\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'value-quantity' => '4.1234||mmol'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Observation, options)\n        has_obs_a = has_obs_b = has_obs_c = false\n        while reply != nil\n          assert_response_ok(reply)\n          assert_bundle_response(reply)\n          has_obs_a = true if reply.resource.get_by_id(@obs_a)\n          has_obs_b = true if reply.resource.get_by_id(@obs_b)\n          has_obs_c = true if reply.resource.get_by_id(@obs_c)\n          reply = @client.next_page(reply)\n        end\n\n        assert has_obs_a,  'Search on quantity value 4.1234 should return 4.12345'\n        assert !has_obs_b, 'Search on quantity value 4.1234 should not return 4.12346'\n        assert !has_obs_c, 'Search on quantity value 4.1234 should not return 4.12349'\n      end\n",
                "data": null,
                "description": "Search for quantity (in observation) - precision tests",
                "id": "SE21G",
                "key": "SE21G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html#quantity",
                    "http://hl7.org/fhir/DSTU2/observation.html#search"
                ],
                "message": "Skipped: se21g_search_for_quantity_(in_observation)_-_precision_tests_test",
                "status": "skip",
                "test_method": "se21g_search_for_quantity_(in_observation)_-_precision_tests_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"SE22#{action[0]}\", 'Search for quantity (in observation) - operators' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html#quantity\"\n          links \"#{BASE_SPEC_LINK}/observation.html#search\"\n          validates resource: \"Observation\", methods: [\"search\"]\n        }\n        skip unless (@obs_a && @obs_d && @obs_e)\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'value-quantity' => 'gt5||mmol'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Observation, options)\n        has_obs_a = has_obs_b = has_obs_c = false\n        while reply != nil\n          assert_response_ok(reply)\n          assert_bundle_response(reply)\n          has_obs_a = true if reply.resource.get_by_id(@obs_a)\n          has_obs_d = true if reply.resource.get_by_id(@obs_d)\n          has_obs_e = true if reply.resource.get_by_id(@obs_e)\n          reply = @client.next_page(reply)\n        end\n\n        assert !has_obs_a,  'Search greater than quantity should not return lesser value.'\n        assert has_obs_d, 'Search greater than quantity should return greater value.'\n        assert has_obs_e, 'Search greater than quantity should return greater value.'\n      end\n",
                "data": null,
                "description": "Search for quantity (in observation) - operators",
                "id": "SE22G",
                "key": "SE22G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html#quantity",
                    "http://hl7.org/fhir/DSTU2/observation.html#search"
                ],
                "message": "Skipped: se22g_search_for_quantity_(in_observation)_-_operators_test",
                "status": "skip",
                "test_method": "se22g_search_for_quantity_(in_observation)_-_operators_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Observation"
                    }
                ]
            },
            {
                "code": "      test \"SE23#{action[0]}\", 'Search with quantifier :missing, on Patient.gender' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # how many patients in the bundle have no gender?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          expected += 1 if !patient.nil? && patient.gender.nil?\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'gender:missing' => true\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n",
                "data": null,
                "description": "Search with quantifier :missing, on Patient.gender",
                "id": "SE23G",
                "key": "SE23G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": "The server did not report the correct number of results. Expected: 3, but found: 311.",
                "status": "fail",
                "test_method": "se23g_search_with_quantifier_:missing,_on_patient.gender_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE24#{action[0]}\", 'Search with non-existing parameter' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        # non-existing parameters should be ignored\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'bonkers' => 'foobar'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search with non-existing parameter",
                "id": "SE24G",
                "key": "SE24G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se24g_search_with_non-existing_parameter_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"SE25#{action[0]}\", 'Search with malformed parameters' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        # a malformed parameters are non-existing parameters, and they should be ignored\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '...' => 'foobar'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n",
                "description": "Search with malformed parameters",
                "id": "SE25G",
                "key": "SE25G",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#search",
                    "http://hl7.org/fhir/DSTU2/search.html",
                    "http://hl7.org/fhir/DSTU2/patient.html#search"
                ],
                "message": null,
                "status": "pass",
                "test_method": "se25g_search_with_malformed_parameters_test",
                "validates": [
                    {
                        "methods": [
                            "search"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0554d4d3261a6c50000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840200"
        },
        "updated_at": {
            "$date": "2015-10-02T19:00:21.757-0400"
        }
    }
]
