[{ "_id" : { "$oid" : "560f06924d4d3266f8850200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0434d4d3261a6000000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "CAEP1", "id" : "CAEP1", "description" : "Create a Patient then check for AuditEvent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter reference does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create" ] }, { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "create" ] }, { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/patient.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/auditevent.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture" ], "code" : "      test 'CAEP1','Create a Patient then check for AuditEvent' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/auditevent.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create']\n          requires resource: 'AuditEvent', methods: ['search']\n          validates resource: 'Patient', methods: ['create']\n          validates resource: 'AuditEvent', methods: ['search']\n        }\n        @patient = @resources.minimal_patient\n        @patient.xmlId = nil # clear the identifier\n        reply = @client.create(@patient)      \n        assert_response_ok(reply)\n        @patient.xmlId = reply.id\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'reference' => \"Patient/#{@patient.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::AuditEvent, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(1, reply.resource.entry.size, 'There should only be one AuditEvent for the test Patient currently in the system.', reply.body)\n        assert(reply.resource.entry[0].try(:resource).try(:object).try(:reference).include?(@patient.xmlId), 'The correct AuditEvent was not returned.', reply.body)\n        warning { assert_equal('110110', reply.resource.entry[0].try(:resource).try(:event).try(:type).try(:code), 'Was expecting an AuditEvent.event.type.code of 110110 (Patient Record).', reply.body) }\n      end\n", "test_method" : "caep1_create_a_patient_then_check_for_auditevent_test" }, { "key" : "CAEP2", "id" : "CAEP2", "description" : "Create a Patient then check for Provenance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter target does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create" ] }, { "resource" : "Provenance", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "create" ] }, { "resource" : "Provenance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/patient.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/provenance.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture" ], "code" : "      test 'CAEP2','Create a Patient then check for Provenance' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/provenance.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create']\n          requires resource: 'Provenance', methods: ['search']\n          validates resource: 'Patient', methods: ['create']\n          validates resource: 'Provenance', methods: ['search']\n        }\n        @patient1 = @resources.minimal_patient\n        @patient1.xmlId = nil # clear the identifier\n        reply = @client.create(@patient1)      \n        assert_response_ok(reply)\n        @patient1.xmlId = reply.id\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'target' => \"Patient/#{@patient1.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::Provenance, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(1, reply.resource.entry.size, 'There should only be one Provenance for the test Patient currently in the system.', reply.body)\n        assert(reply.resource.entry[0].try(:resource).try(:target).try(:reference).include?(@patient1.xmlId), 'The correct Provenance was not returned.', reply.body)\n      end\n", "test_method" : "caep2_create_a_patient_then_check_for_provenance_test" }, { "key" : "CAEP3", "id" : "CAEP3", "description" : "Update a Patient then check for AuditEvent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter reference does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update" ] }, { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "update" ] }, { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/patient.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/auditevent.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture" ], "code" : "      test 'CAEP3','Update a Patient then check for AuditEvent' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/auditevent.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create','update']\n          requires resource: 'AuditEvent', methods: ['search']\n          validates resource: 'Patient', methods: ['update']\n          validates resource: 'AuditEvent', methods: ['search']\n        }\n        @patient.gender = 'male'\n        reply = @client.update(@patient,@patient.xmlId)      \n        assert_response_ok(reply)\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'reference' => \"Patient/#{@patient.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::AuditEvent, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(2, reply.resource.entry.size, 'There should be two AuditEvents for the test Patient currently in the system.', reply.body)\n        reply.resource.entry.each do |entry|\n          assert(entry.try(:resource).try(:object).try(:reference).include?(@patient.xmlId), 'An incorrect AuditEvent was returned.', reply.body)\n          warning { assert_equal('110110', entry.try(:resource).try(:event).try(:type).try(:code), 'Was expecting an AuditEvent.event.type.code of 110110 (Patient Record).', reply.body) }\n        end\n      end\n", "test_method" : "caep3_update_a_patient_then_check_for_auditevent_test" }, { "key" : "CAEP4", "id" : "CAEP4", "description" : "Update a Patient then check for Provenance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter target does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update" ] }, { "resource" : "Provenance", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "update" ] }, { "resource" : "Provenance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/patient.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/provenance.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture" ], "code" : "      test 'CAEP4','Update a Patient then check for Provenance' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/provenance.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create','update']\n          requires resource: 'Provenance', methods: ['search']\n          validates resource: 'Patient', methods: ['update']\n          validates resource: 'Provenance', methods: ['search']\n        }\n        @patient1.gender = 'male'\n        reply = @client.update(@patient1,@patient1.xmlId)      \n        assert_response_ok(reply)\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'target' => \"Patient/#{@patient1.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::Provenance, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(2, reply.resource.entry.size, 'There should be two Provenance resources for the test Patient currently in the system.', reply.body)\n        reply.resource.entry.each do |entry|\n          assert(entry.try(:resource).try(:target).try(:reference).include?(@patient1.xmlId), 'An incorrect Provenance was returned.', reply.body)\n        end\n      end\n", "test_method" : "caep4_update_a_patient_then_check_for_provenance_test" }, { "key" : "CAEP5", "id" : "CAEP5", "description" : "Read a Patient and check for AuditEvent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Parameter reference does not support restricting to ResourceType: Patient\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] }, { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] }, { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/patient.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/auditevent.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture" ], "code" : "      test 'CAEP5','Read a Patient and check for AuditEvent' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/patient.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/auditevent.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_4_-EHR_record_lifecycle_architecture'\n          requires resource: 'Patient', methods: ['create','read']\n          requires resource: 'AuditEvent', methods: ['search']\n          validates resource: 'Patient', methods: ['read']\n          validates resource: 'AuditEvent', methods: ['search']\n        }\n        reply = @client.read(FHIR::Patient,@patient.xmlId)      \n        assert_response_ok(reply)\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'reference' => \"Patient/#{@patient.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::AuditEvent, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(3, reply.resource.entry.size, 'There should be three AuditEvents for the test Patient currently in the system.', reply.body)\n        reply.resource.entry.each do |entry|\n          assert(entry.try(:resource).try(:object).try(:reference).include?(@patient.xmlId), 'An incorrect AuditEvent was returned.', reply.body)\n          warning { assert_equal('110110', entry.try(:resource).try(:event).try(:type).try(:code), 'Was expecting an AuditEvent.event.type.code of 110110 (Patient Record).', reply.body) }\n        end\n      end\n", "test_method" : "caep5_read_a_patient_and_check_for_auditevent_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:34:58.440-0400" }, "created_at" : { "$date" : "2015-10-02T18:34:58.440-0400" } }
,{ "_id" : { "$oid" : "560f06ad4d4d3266f8860200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0434d4d3261a6010000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "C8T2_1A", "id" : "C8T2_1A", "description" : "Fetch all patient records", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation everything is not supported on the Patient resource\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "$everything" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "$everything" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient-operations.html#everything", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29" ], "code" : "      test 'C8T2_1A', 'Fetch all patient records' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['$everything']\n          validates resource: 'Patient', methods: ['$everything']\n        }\n\n        reply = @client.fetch_patient_record\n\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "c8t2_1a_fetch_all_patient_records_test" }, { "key" : "C8T2_1B", "id" : "C8T2_1B", "description" : "Fetch all patient records with [start, end]", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation everything is not supported on the Patient resource\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "$everything" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "$everything" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient-operations.html#everything", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29" ], "code" : "      test 'C8T2_1B', 'Fetch all patient records with [start, end]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['$everything']\n          validates resource: 'Patient', methods: ['$everything']\n        }\n\n        reply = @client.fetch_patient_record(nil, \"2012-01-01\", \"2012-12-31\")\n\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        skip # TODO: Determine how start/end scope all patient records (e.g., birthdate?)\n      end\n", "test_method" : "c8t2_1b_fetch_all_patient_records_with_[start,_end]_test" }, { "key" : "C8T2_2A", "id" : "C8T2_2A", "description" : "Fetch specific patient record", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "$everything" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "create", "$everything" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient-operations.html#everything", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29" ], "code" : "      test 'C8T2_2A', 'Fetch specific patient record' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['create', '$everything']\n          validates resource: 'Patient', methods: ['create', '$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@patient_id)\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        patient = @patient\n        patient.xmlId = @patient_id\n\n        assert patient.equals?(record.resource.entry[0].resource), \"Returned patient doesn't match original patient.\"\n      end\n", "test_method" : "c8t2_2a_fetch_specific_patient_record_test" }, { "key" : "C8T2_2B", "id" : "C8T2_2B", "description" : "Fetch specific patient record with [start, end]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "$everything" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "create", "$everything" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient-operations.html#everything", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29" ], "code" : "      test 'C8T2_2B', 'Fetch specific patient record with [start, end]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['create', '$everything']\n          validates resource: 'Patient', methods: ['create', '$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@patient_id, \"2012-01-01\", \"2012-12-31\")\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        patient = @patient\n        patient.xmlId = @patient_id\n\n        assert patient.equals?(record.resource.entry[0].resource), \"Returned patient doesn't match original patient.\"\n\n        # TODO: Determine how start/end scope specific patient records (e.g., birthdate?)\n      end\n", "test_method" : "c8t2_2b_fetch_specific_patient_record_with_[start,_end]_test" }, { "key" : "C8T2_2C", "id" : "C8T2_2C", "description" : "Fetch specific patient record - BONUS: Update", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "$everything" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "create", "update", "$everything" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient-operations.html#everything", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29" ], "code" : "      test 'C8T2_2C', 'Fetch specific patient record - BONUS: Update' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Expose_the_.27Fetch_Patient_Record.27_operation_.28Server.29'\n          requires resource: 'Patient', methods: ['create', 'update', '$everything']\n          validates resource: 'Patient', methods: ['create', 'update', '$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@patient_id)\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        @patient.telecom[0].value='1-234-567-8901'\n        @patient.name[0].given = [\"Not\", \"Given\"]\n\n        reply = @client.update @patient, @patient_id\n\n        assert_response_ok(reply)\n\n        record = @client.fetch_patient_record(@patient_id)\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n        assert record.resource.entry[0].resource.telecom[0].value == '1-234-567-8901'\n        assert record.resource.entry[0].resource.name[0].given == ['Not', 'Given']\n      end\n", "test_method" : "c8t2_2c_fetch_specific_patient_record_-_bonus:_update_test" }, { "key" : "C8T2_3_A", "id" : "C8T2_3_A", "description" : "Fetch an entire patient record - exact", "status" : "fail", "message" : "Data returned from the server did not match source data: [\"FHIR::Patient::meta\", \"FHIR::Observation::meta\", \"FHIR::Encounter::meta\", \"FHIR::Encounter::meta\", \"FHIR::Condition::text\", \"FHIR::Narrative::div\", \"FHIR::Condition::meta\", \"FHIR::Condition::text\", \"FHIR::Narrative::div\", \"FHIR::Condition::meta\", \"FHIR::DiagnosticReport::text\", \"FHIR::Narrative::div\", \"FHIR::DiagnosticReport::meta\", \"FHIR::Procedure::text\", \"FHIR::Narrative::div\", \"FHIR::Procedure::meta\"]", "data" : null, "requires" : [ { "resource" : "Organization", "methods" : [ "create" ] }, { "resource" : "Practitioner", "methods" : [ "create" ] }, { "resource" : "Patient", "methods" : [ "create" ] }, { "resource" : "Condition", "methods" : [ "create" ] }, { "resource" : "Observation", "methods" : [ "create" ] }, { "resource" : "DiagnosticReport", "methods" : [ "create" ] }, { "resource" : "Encounter", "methods" : [ "create" ] }, { "resource" : "Procedure", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "create", "$everything" ] }, { "resource" : "Organization", "methods" : [ "create" ] }, { "resource" : "Practitioner", "methods" : [ "create" ] }, { "resource" : "Patient", "methods" : [ "create" ] }, { "resource" : "Condition", "methods" : [ "create" ] }, { "resource" : "Observation", "methods" : [ "create" ] }, { "resource" : "DiagnosticReport", "methods" : [ "create" ] }, { "resource" : "Encounter", "methods" : [ "create" ] }, { "resource" : "Procedure", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient-operations.html#everything", "http://hl7.org/fhir/DSTU2/argonauts.html" ], "code" : "      test 'C8T2_3_A', 'Fetch an entire patient record - exact' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links \"#{BASE_SPEC_LINK}/argonauts.html\"\n          requires resource: 'Organization', methods: ['create']\n          requires resource: 'Practitioner', methods: ['create']\n          requires resource: 'Patient', methods: ['create']\n          requires resource: 'Condition', methods: ['create']\n          requires resource: 'Observation', methods: ['create']\n          requires resource: 'DiagnosticReport', methods: ['create']\n          requires resource: 'Encounter', methods: ['create']\n          requires resource: 'Procedure', methods: ['create']\n          validates resource: 'Patient', methods: ['create', '$everything']\n          validates resource: 'Organization', methods: ['create']\n          validates resource: 'Practitioner', methods: ['create']\n          validates resource: 'Patient', methods: ['create']\n          validates resource: 'Condition', methods: ['create']\n          validates resource: 'Observation', methods: ['create']\n          validates resource: 'DiagnosticReport', methods: ['create']\n          validates resource: 'Encounter', methods: ['create']\n          validates resource: 'Procedure', methods: ['create']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@pat_reply.id)\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        mismatches = []\n        record.resource.entry.each do |bundle_entry|\n          case bundle_entry.resource.class\n          when FHIR::Organization\n            case bundle_entry.resource.xmlId\n            when @org1_id\n              mismatches << bundle_entry.resource.mismatch(@organization_1) unless bundle_entry.resource.equals?(@organization_1)\n            when @org2_id\n              mismatches << bundle_entry.resource.mismatch(@organization_2) unless bundle_entry.resource.equals?(@organization_2)\n            end\n          when FHIR::Practitioner\n            mismatches << bundle_entry.resource.mismatch(@practitioner) unless bundle_entry.resource.equals?(@practitioner)\n          when FHIR::Patient\n            mismatches << bundle_entry.resource.mismatch(@patient) unless bundle_entry.resource.equals?(@patient)\n          when FHIR::Condition\n            case bundle_entry.resource.xmlId\n            when @cond1_id\n              mismatches << bundle_entry.resource.mismatch(@condition_1) unless bundle_entry.resource.equals?(@condition_1)\n            when @cond2_id\n              mismatches << bundle_entry.resource.mismatch(@condition_2) unless bundle_entry.resource.equals?(@condition_2)\n            end\n          when FHIR::Observation\n            mismatches << bundle_entry.resource.mismatch(@observation) unless bundle_entry.resource.equals?(@observation)\n          when FHIR::DiagnosticReport\n            mismatches << bundle_entry.resource.mismatch(@diagnosticreport) unless bundle_entry.resource.equals?(@diagnosticreport)\n          when FHIR::Encounter\n            case bundle_entry.resource.xmlId\n            when @enc1_id\n              mismatches << bundle_entry.resource.mismatch(@encounter_1) unless bundle_entry.resource.equals?(@encounter_1)\n            when @enc2_id\n              mismatches << bundle_entry.resource.mismatch(@encounter_2) unless bundle_entry.resource.equals?(@encounter_2)\n            end\n          when FHIR::Procedure\n            mismatches << bundle_entry.resource.mismatch(@procedure) unless bundle_entry.resource.equals?(@procedure)\n          end\n        end\n\n        assert mismatches.flatten.empty?, \"Data returned from the server did not match source data: #{mismatches.flatten}\"\n      end\n", "test_method" : "c8t2_3_a_fetch_an_entire_patient_record_-_exact_test" }, { "key" : "C8T2_3_B", "id" : "C8T2_3_B", "description" : "Fetch an entire patient record - ignore meta & text", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "$everything" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient-operations.html#everything", "http://hl7.org/fhir/DSTU2/argonauts.html" ], "code" : "      test 'C8T2_3_B', 'Fetch an entire patient record - ignore meta & text' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links \"#{BASE_SPEC_LINK}/argonauts.html\"\n          validates resource: 'Patient', methods: ['$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@pat_reply.id)\n\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        mismatches = []\n        record.resource.entry.each do |bundle_entry|\n          case bundle_entry.resource.class\n          when FHIR::Organization\n            case bundle_entry.resource.xmlId\n            when @org1_id\n              mismatches << bundle_entry.resource.mismatch(@organization_1, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@organization_1)\n            when @org2_id\n              mismatches << bundle_entry.resource.mismatch(@organization_2, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@organization_2)\n            end\n          when FHIR::Practitioner\n            mismatches << bundle_entry.resource.mismatch(@practitioner, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@practitioner)\n          when FHIR::Patient\n            mismatches << bundle_entry.resource.mismatch(@patient, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@patient)\n          when FHIR::Condition\n            case bundle_entry.resource.xmlId\n            when @cond1_id\n              mismatches << bundle_entry.resource.mismatch(@condition_1, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@condition_1)\n            when @cond2_id\n              mismatches << bundle_entry.resource.mismatch(@condition_2, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@condition_2)\n            end\n          when FHIR::Observation\n            mismatches << bundle_entry.resource.mismatch(@observation, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@observation)\n          when FHIR::DiagnosticReport\n            mismatches << bundle_entry.resource.mismatch(@diagnosticreport, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@diagnosticreport)\n          when FHIR::Encounter\n            case bundle_entry.resource.xmlId\n            when @enc1_id\n              mismatches << bundle_entry.resource.mismatch(@encounter_1, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@encounter_1)\n            when @enc2_id\n              mismatches << bundle_entry.resource.mismatch(@encounter_2, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@encounter_2)\n            end\n          when FHIR::Procedure\n            mismatches << bundle_entry.resource.mismatch(@procedure, ['_id', 'meta', 'text']) unless bundle_entry.resource.equals?(@procedure)\n          end\n        end\n\n        assert mismatches.flatten.empty?, \"Data returned from the server did not match source data: #{mismatches.flatten}\"\n      end\n", "test_method" : "c8t2_3_b_fetch_an_entire_patient_record_-_ignore_meta_&_text_test" }, { "key" : "C8T2_3_C", "id" : "C8T2_3_C", "description" : "Fetch an entire patient record - count", "status" : "fail", "message" : "Returned Bundle is missing resources: {\"FHIR::Organization\"=>[\"bd274af642254a019681b4b4e338d0cf\", \"5cc2d404428244cca63310f6488dac7a\"], \"FHIR::Practitioner\"=>[\"4090bd6b52b441f39377af5f9abfe177\"]}", "data" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "$everything" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient-operations.html#everything", "http://hl7.org/fhir/DSTU2/argonauts.html" ], "code" : "      test 'C8T2_3_C', 'Fetch an entire patient record - count' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient-operations.html#everything\"\n          links \"#{BASE_SPEC_LINK}/argonauts.html\"\n          validates resource: 'Patient', methods: ['$everything']\n        }\n\n        skip unless @created_patient_record\n        record = @client.fetch_patient_record(@pat_reply.id)\n        assert_response_ok(record)\n        assert_bundle_response(record)\n\n        record.resource.entry.each do |bundle_entry|\n          if @ids_count.keys.include?(bundle_entry.resource.class.to_s)\n            @ids_count[bundle_entry.resource.class.to_s].delete bundle_entry.resource.xmlId\n          else\n            warning { assert @ids_count.keys.include?(bundle_entry.resource.class.to_s),\n              \"Found additional resource(s) in $everything Bundle: #{bundle_entry.resource.class}#{ \"-#{bundle_entry.resource.code.text}\" if bundle_entry.resource.class == FHIR::List}\" }\n          end\n        end\n\n        @ids_count.each {|klass,ids| @ids_count.delete(klass) if ids.blank?}\n        assert @ids_count.flatten.empty?, \"Returned Bundle is missing resources: #{@ids_count}\"\n      end\n", "test_method" : "c8t2_3_c_fetch_an_entire_patient_record_-_count_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:35:25.379-0400" }, "created_at" : { "$date" : "2015-10-02T18:35:25.379-0400" } }
,{ "_id" : { "$oid" : "560f06c84d4d3266f88b0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0434d4d3261a6020000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "C9F_1A", "id" : "C9F_1A", "description" : "Register a simple claim", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Claim", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Claim", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/claim.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_1A','Register a simple claim' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/claim.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'Claim', methods: ['create']\n          validates resource: 'Claim', methods: ['create']\n        }\n\n        reply = @client.create(@simple)\n        assert_response_ok(reply)\n        @simple_id = reply.id\n        sleep(10) # sleep to allow server to process claim, no wait time was causing incorrect failures in subsequent tests\n\n        if !reply.resource.nil?\n          # Response is Claim\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @simple.equals?(reply.resource), 'The server did not correctly preserve the Claim data.' }\n          reply.resource.xmlId = temp\n        elsif !reply.body.nil?\n          begin\n            cr = FHIR::Resource.from_contents(reply.body)\n            if cr.class==FHIR::ClaimResponse\n              # Response is ClaimResponse\n              @simple_response_id = cr.xmlId\n              @simple_id = cr.request.reference if cr.request\n            else\n              warning { assert(false,\"The Claim request responded with an unexpected resource: #{cr.class}\",reply.body) }\n            end\n          rescue Exception => ex\n            warning { assert(false,'The Claim request responded with an unexpected body.',reply.body) }\n          end\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c9f_1a_register_a_simple_claim_test" }, { "key" : "C9F_1B", "id" : "C9F_1B", "description" : "Register an average claim", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Claim", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Claim", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/claim.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_1B','Register an average claim' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/claim.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'Claim', methods: ['create']\n          validates resource: 'Claim', methods: ['create']\n        }\n\n        reply = @client.create(@average)\n        assert_response_ok(reply)\n        @average_id = reply.id\n        sleep(10) # sleep to allow server to process claim, no wait time was causing incorrect failures in subsequent tests\n\n        if !reply.resource.nil?\n          # Response is Claim\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @average.equals?(reply.resource), 'The server did not correctly preserve the Claim data.' }\n          reply.resource.xmlId = temp\n        elsif !reply.body.nil?\n          begin\n            cr = FHIR::Resource.from_contents(reply.body)\n            if cr.class==FHIR::ClaimResponse\n              # Response is ClaimResponse\n              @average_response_id = cr.xmlId\n              @average_id = cr.request.reference if cr.request\n            else\n              warning { assert(false,\"The Claim request responded with an unexpected resource: #{cr.class}\",reply.body) }\n            end\n          rescue Exception => ex\n            warning { assert(false,'The Claim request responded with an unexpected body.',reply.body) }\n          end\n        end\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c9f_1b_register_an_average_claim_test" }, { "key" : "C9F_1C", "id" : "C9F_1C", "description" : "Check on simple claim", "status" : "fail", "message" : "Claim does not reference a ClaimResponse.", "data" : "﻿<Claim xmlns=\"http://hl7.org/fhir\"><id value=\"7c84273592f543bfbf9ae4641a523a56\" /><meta><versionId value=\"28\" /><lastUpdated value=\"2015-10-02T22:35:26.18+00:00\" /></meta><type value=\"oral\" /><created value=\"2015-04-16\" /><target><reference value=\"Organization/654123\" /></target><organization><reference value=\"Organization/1535\" /></organization><use value=\"complete\" /><priority><code value=\"normal\" /></priority><payee><type><code value=\"provider\" /></type></payee><diagnosis><sequence value=\"1\" /><diagnosis><code value=\"123456\" /></diagnosis></diagnosis><patient><reference value=\"Patient/1\" /></patient><coverage><sequence value=\"1\" /><focal value=\"true\" /><coverage><reference value=\"Coverage/9876B1\" /></coverage><relationship><code value=\"self\" /></relationship></coverage><item><sequence value=\"1\" /><type><code value=\"service\" /></type><provider><reference value=\"Practitioner/1\" /></provider><service><code value=\"1201\" /></service><serviceDate value=\"2015-04-16\" /><unitPrice><value value=\"135.57\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"135.57\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net></item></Claim>", "requires" : [ { "resource" : "Claim", "methods" : [ "read" ] } ], "validates" : [ { "resource" : "Claim", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/claim.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_1C','Check on simple claim' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/claim.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'Claim', methods: ['read']\n          validates resource: 'Claim', methods: ['read']\n        }\n\n        reply = @client.read(FHIR::Claim,@simple_id)\n        assert_response_ok(reply)\n        assert_resource_type(reply,FHIR::Claim)\n        reply.resource.coverage.each do |coverage|\n          assert(!coverage.try(:claimResponse).try(:reference).nil?,'Claim does not reference a ClaimResponse.',reply.body)\n        end\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c9f_1c_check_on_simple_claim_test" }, { "key" : "C9F_1D", "id" : "C9F_1D", "description" : "Check on average claim", "status" : "fail", "message" : "Claim does not reference a ClaimResponse.", "data" : "﻿<Claim xmlns=\"http://hl7.org/fhir\"><id value=\"d2db78a4f58540808b041589448abc34\" /><meta><versionId value=\"29\" /><lastUpdated value=\"2015-10-02T22:35:36.97+00:00\" /></meta><type value=\"oral\" /><created value=\"2014-08-16\" /><target><reference value=\"Organization/2\" /></target><organization><reference value=\"Organization/1\" /></organization><use value=\"complete\" /><priority><code value=\"normal\" /></priority><payee><type><code value=\"provider\" /></type></payee><diagnosis><sequence value=\"1\" /><diagnosis><code value=\"123456\" /></diagnosis></diagnosis><patient><reference value=\"Patient/1\" /></patient><coverage><sequence value=\"1\" /><focal value=\"true\" /><coverage><reference value=\"Coverage/9876B1\" /></coverage><relationship><code value=\"self\" /></relationship></coverage><item><sequence value=\"1\" /><type><code value=\"service\" /></type><provider><reference value=\"Practitioner/1\" /></provider><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"1200\" /></service><serviceDate value=\"2014-08-16\" /><unitPrice><value value=\"135.57\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"135.57\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net></item><item><sequence value=\"2\" /><type><code value=\"service\" /></type><provider><reference value=\"Practitioner/1\" /></provider><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"21211\" /></service><serviceDate value=\"2014-08-16\" /><unitPrice><value value=\"105.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"105.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net><bodySite><system value=\"http://fdi.org/fhir/oraltoothcodes\" /><code value=\"21\" /></bodySite><subSite><system value=\"http://fdi.org/fhir/oralsurfacecodes\" /><code value=\"L\" /></subSite></item><item><sequence value=\"3\" /><type><code value=\"group\" /></type><provider><reference value=\"Practitioner/1\" /></provider><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"27211\" /></service><serviceDate value=\"2014-08-16\" /><unitPrice><value value=\"1100.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"1100.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net><bodySite><system value=\"http://fdi.org/fhir/oraltoothcodes\" /><code value=\"36\" /></bodySite><detail><sequence value=\"1\" /><type><code value=\"service\" /></type><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"27211\" /></service><unitPrice><value value=\"750.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"750.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net></detail><detail><sequence value=\"2\" /><type><code value=\"service\" /></type><service><system value=\"http://hl7.org/fhir/oralservicecodes\" /><code value=\"lab\" /></service><unitPrice><value value=\"350.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></unitPrice><net><value value=\"350.0\" /><system value=\"urn:std:iso:4217\" /><code value=\"USD\" /></net></detail></item></Claim>", "requires" : [ { "resource" : "Claim", "methods" : [ "read" ] } ], "validates" : [ { "resource" : "Claim", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/claim.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_1D','Check on average claim' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/claim.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'Claim', methods: ['read']\n          validates resource: 'Claim', methods: ['read']\n        }\n\n        reply = @client.read(FHIR::Claim,@average_id)\n        assert_response_ok(reply)\n        assert_resource_type(reply,FHIR::Claim)\n        reply.resource.coverage.each do |coverage|\n          assert(!coverage.try(:claimResponse).try(:reference).nil?,'Claim does not reference a ClaimResponse.',reply.body)\n        end\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c9f_1d_check_on_average_claim_test" }, { "key" : "C9F_2A_request", "id" : "C9F_2A_request", "description" : "Search ClaimResponse by simple claim ID", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "requires" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_2A_request', 'Search ClaimResponse by simple claim ID' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @simple_id\n\n        search_string = @simple_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              'request' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @simple_response_id = reply.resource.entry[0].resource.xmlId unless @simple_response_id\n      end\n", "test_method" : "c9f_2a_request_search_claimresponse_by_simple_claim_id_test" }, { "key" : "C9F_2A_text", "id" : "C9F_2A_text", "description" : "Search ClaimResponse by simple claim ID in the text", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "requires" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_2A_text', 'Search ClaimResponse by simple claim ID in the text' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @simple_id\n\n        search_string = @simple_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              '_text' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @simple_response_id = reply.resource.entry[0].resource.xmlId unless @simple_response_id\n      end\n", "test_method" : "c9f_2a_text_search_claimresponse_by_simple_claim_id_in_the_text_test" }, { "key" : "C9F_2A_content", "id" : "C9F_2A_content", "description" : "Search ClaimResponse by simple claim ID in the content", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "requires" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_2A_content', 'Search ClaimResponse by simple claim ID in the content' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @simple_id\n\n        search_string = @simple_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              '_content' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @simple_response_id = reply.resource.entry[0].resource.xmlId unless @simple_response_id\n      end\n", "test_method" : "c9f_2a_content_search_claimresponse_by_simple_claim_id_in_the_content_test" }, { "key" : "C9F_2B_request", "id" : "C9F_2B_request", "description" : "Search ClaimResponse by average claim ID", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "requires" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_2B_request', 'Search ClaimResponse by average claim ID' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @average_id\n\n        search_string = @average_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              'request' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @average_response_id = reply.resource.entry[0].resource.xmlId unless @average_response_id\n      end\n", "test_method" : "c9f_2b_request_search_claimresponse_by_average_claim_id_test" }, { "key" : "C9F_2B_text", "id" : "C9F_2B_text", "description" : "Search ClaimResponse by average claim ID in the text", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "requires" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_2B_text', 'Search ClaimResponse by average claim ID in the text' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @average_id\n\n        search_string = @average_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              '_text' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @average_response_id = reply.resource.entry[0].resource.xmlId unless @average_response_id\n      end\n", "test_method" : "c9f_2b_text_search_claimresponse_by_average_claim_id_in_the_text_test" }, { "key" : "C9F_2B_content", "id" : "C9F_2B_content", "description" : "Search ClaimResponse by average claim ID in the content", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "requires" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html", "http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse" ], "code" : "      test 'C9F_2B_content', 'Search ClaimResponse by average claim ID in the content' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/claimresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=Connectathon9_Financial#Submit_a_Claim_via_REST.2C_Retrieve_a_ClaimResponse'\n          requires resource: 'ClaimResponse', methods: ['search']\n          validates resource: 'ClaimResponse', methods: ['search']\n        }\n        skip unless @average_id\n\n        search_string = @average_id\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => true,\n            :compartment => nil,\n            :parameters => {\n              '_content' => search_string\n            }\n          }\n        }\n        @client.use_format_param = true\n        reply = @client.search(FHIR::ClaimResponse, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n\n        @average_response_id = reply.resource.entry[0].resource.xmlId unless @average_response_id\n      end\n", "test_method" : "c9f_2b_content_search_claimresponse_by_average_claim_id_in_the_content_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:35:52.208-0400" }, "created_at" : { "$date" : "2015-10-02T18:35:52.208-0400" } }
,{ "_id" : { "$oid" : "560f06d14d4d3266f8950200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0434d4d3261a6030000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "C8T1_1A", "id" : "C8T1_1A", "description" : "Register a new patient", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#1._Register_a_new_patient" ], "code" : "      test 'C8T1_1A','Register a new patient' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#1._Register_a_new_patient'\n          requires resource: 'Patient', methods: ['create']\n          validates resource: 'Patient', methods: ['create']\n        }\n\n        reply = @client.create @patient\n        @patient_id = reply.id\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c8t1_1a_register_a_new_patient_test" }, { "key" : "C8T1_1B", "id" : "C8T1_1B", "description" : "Register a new patient - BONUS: Extensions", "status" : "pass", "message" : null, "warnings" : [ "The server did not correctly preserve the Patient data." ], "requires" : [ { "resource" : "Patient", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "create" ] }, { "extensions" : [ "extensions" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#1._Register_a_new_patient" ], "code" : "      test 'C8T1_1B','Register a new patient - BONUS: Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#1._Register_a_new_patient'\n          requires resource: 'Patient', methods: ['create']\n          validates resource: 'Patient', methods: ['create']\n          validates extensions: ['extensions']\n        }\n\n        reply = @client.create @patient_us\n        @patient_us_id = reply.id\n\t\t    @patient_us.xmlId = reply.resource.xmlId || reply.id\n\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c8t1_1b_register_a_new_patient_-_bonus:_extensions_test" }, { "key" : "C8T1_2A", "id" : "C8T1_2A", "description" : "Update a patient", "status" : "pass", "message" : null, "warnings" : [ "The server did not correctly preserve the Patient data." ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient" ], "code" : "      test 'C8T1_2A','Update a patient' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create', 'update']\n          validates resource: 'Patient', methods: ['update']\n        }\n        skip unless @patient_id\n\n\t\t    @patient.xmlId = @patient_id\n        @patient.telecom[0].value='1-800-TOLL-FREE'\n        @patient.telecom[0].system='phone'\n        @patient.name[0].given = ['Crocodile','Pants']\n\n        reply = @client.update @patient, @patient_id\n\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c8t1_2a_update_a_patient_test" }, { "key" : "C8T1_2B", "id" : "C8T1_2B", "description" : "Update a patient - BONUS: Unmodifier Extensions", "status" : "pass", "message" : null, "warnings" : [ "The server did not correctly preserve the Patient data." ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "update" ] }, { "extensions" : [ "extensions" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient" ], "code" : "      test 'C8T1_2B','Update a patient - BONUS: Unmodifier Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create','update']\n          validates resource: 'Patient', methods: ['update']\n          validates extensions: ['extensions']\n        }\n        skip unless @patient_us_id\n\t\t\n        @patient_us.xmlId = @patient_us_id\n        @patient_us.extension[0].value.value.coding[0].code = '1569-3'\n        @patient_us.extension[1].value.value.coding[0].code = '2186-5'\n\n        reply = @client.update @patient_us, @patient_us_id\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c8t1_2b_update_a_patient_-_bonus:_unmodifier_extensions_test" }, { "key" : "C8T1_2C", "id" : "C8T1_2C", "description" : "Update a patient - BONUS: Modifier Extensions", "status" : "pass", "message" : null, "warnings" : [ "The server did not correctly preserve the Patient data." ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "update" ] }, { "extensions" : [ "modifying extensions" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient" ], "code" : "      test 'C8T1_2C','Update a patient - BONUS: Modifier Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create','update']\n          validates resource: 'Patient', methods: ['update']\n          validates extensions: ['modifying extensions']\n        }\n        skip unless @patient_us_id\n\n\t\t    @patient_us.xmlId = @patient_us_id\n        @patient_us.modifierExtension << FHIR::Extension.new\n        @patient_us.modifierExtension[0].url='http://projectcrucible.org/modifierExtension/foo'\n        @patient_us.modifierExtension[0].value = FHIR::AnyType.new('Boolean',true)\n\n        reply = @client.update @patient_us, @patient_us_id\n\n        @patient_us.modifierExtension.clear\n\n        assert([200,201,422].include?(reply.code), 'The server should except a modifierExtension, or return 422 if it chooses to reject a modifierExtension it does not understand.',\"Server response code: #{reply.code}\\n#{reply.body}\")\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c8t1_2c_update_a_patient_-_bonus:_modifier_extensions_test" }, { "key" : "C8T1_2D", "id" : "C8T1_2D", "description" : "Update a patient - BONUS: Primitive Extensions", "status" : "pass", "message" : null, "warnings" : [ "The server did not correctly preserve the Patient data." ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "update" ] }, { "extensions" : [ "primitive extensions" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient" ], "code" : "      test 'C8T1_2D','Update a patient - BONUS: Primitive Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create','update']\n          validates resource: 'Patient', methods: ['update']\n          validates extensions: ['primitive extensions']\n        }\n        skip unless @patient_us_id\n\n        @patient_us.xmlId = @patient_us_id\n        @patient_us.gender = 'male'\n        pe = FHIR::PrimitiveExtension.new\n        pe.path='_gender'\n        pe['extension'] = [ FHIR::Extension.new ]\n        pe['extension'][0].url = 'http://hl7.org/test/gender'\n        pe['extension'][0].value = FHIR::AnyType.new('String','Male')\n        @patient_us.primitiveExtension << pe\n\n        reply = @client.update @patient_us, @patient_us_id\n\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c8t1_2d_update_a_patient_-_bonus:_primitive_extensions_test" }, { "key" : "C8T1_2E", "id" : "C8T1_2E", "description" : "Update a patient - BONUS: Complex Extensions", "status" : "pass", "message" : null, "warnings" : [ "The server did not correctly preserve the Patient data." ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "update" ] }, { "extensions" : [ "complex extensions" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient" ], "code" : "      test 'C8T1_2E','Update a patient - BONUS: Complex Extensions' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#2._Update_a_patient'\n          requires resource: 'Patient', methods: ['create','update']\n          validates resource: 'Patient', methods: ['update']\n          validates extensions: ['complex extensions']\n        }\n        skip unless @patient_us_id\n\n        @patient_us.xmlId = @patient_us_id\n        begin\n          @patient_us.primitiveExtension.clear\n        rescue Exception => e\n          # IGNORE: the above call always throws an exception -- even though it succeeds!!\n        end\n        ext = FHIR::Extension.new\n        ext.url = 'http://hl7.org/complex/foo'\n        ext.extension << FHIR::Extension.new\n        ext.extension[0].url='http://complex/foo/bar'\n        ext.extension[0].value=FHIR::AnyType.new('String','foobar')\n        @patient.extension << ext\n\n        reply = @client.update @patient_us, @patient_us_id\n\n        assert_response_ok(reply)\n\n        if !reply.resource.nil?\n          temp = reply.resource.xmlId\n          reply.resource.xmlId = nil\n          warning { assert @patient.equals?(reply.resource), 'The server did not correctly preserve the Patient data.' }\n          reply.resource.xmlId = temp\n        end\n\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_last_modified_present(reply) }\n        warning { assert_valid_content_location_present(reply) }\n      end\n", "test_method" : "c8t1_2e_update_a_patient_-_bonus:_complex_extensions_test" }, { "key" : "C8T1_3", "id" : "C8T1_3", "description" : "Retrieve Patient History", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#3._Retrieve_Patient_history" ], "code" : "      test  'C8T1_3','Retrieve Patient History' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#3._Retrieve_Patient_history'\n          requires resource: 'Patient', methods: ['create', 'update']\n          validates resource: 'Patient', methods: ['history-instance']\n        }\n        skip unless @patient_id\n\n        result = @client.resource_instance_history(FHIR::Patient,@patient_id)\n        assert_response_ok result\n        assert_equal 2, result.resource.total, 'The number of returned versions is not correct'\n        warning { assert_equal 'history', result.resource.fhirType, 'The bundle does not have the correct type: history' }\n        warning { check_sort_order(result.resource.entry) }\n      end\n", "test_method" : "c8t1_3_retrieve_patient_history_test" }, { "key" : "C8T1_4", "id" : "C8T1_4", "description" : "Search patient resource on given name", "status" : "fail", "message" : "The server did not report any results.", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/search.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#4._Search_for_a_patient_on_name" ], "code" : "      test 'C8T1_4', 'Search patient resource on given name' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#4._Search_for_a_patient_on_name'\n          requires resource: 'Patient', methods: ['create']\n          validates resource: 'Patient', methods: ['search']\n        }\n\n        search_string = @patient.name[0].given[0]\n        search_regex = Regexp.new(search_string)\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'given' => search_string\n            }\n          }\n        }\n        @client.use_format_param = false\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (reply.resource.total > 0), 'The server did not report any results.'\n      end\n", "test_method" : "c8t1_4_search_patient_resource_on_given_name_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:36:01.431-0400" }, "created_at" : { "$date" : "2015-10-02T18:36:01.431-0400" } }
,{ "_id" : { "$oid" : "560f06d84d4d3266f8960200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0434d4d3261a6040000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "C8T3_2A", "id" : "C8T3_2A", "description" : "Validate Observations against the General Specification", "status" : "pass", "message" : null, "requires" : [ { "resource" : "StructureDefinition", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Observation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#Track_3_-_Experimental:_Profiles_and_conformance", "http://hl7.org/fhir/DSTU2/structuredefinition.html", "http://hl7.org/fhir/DSTU2/observation.html", "http://hl7.org/fhir/DSTU2/operation-resource-validate.html" ], "code" : "      test 'C8T3_2A','Validate Observations against the General Specification' do\n        metadata {\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#Track_3_-_Experimental:_Profiles_and_conformance'\n          links \"#{BASE_SPEC_LINK}/structuredefinition.html\"\n          links \"#{BASE_SPEC_LINK}/observation.html\"\n          links \"#{BASE_SPEC_LINK}/operation-resource-validate.html\"\n          requires resource: 'StructureDefinition', methods: ['create']\n          validates resource: 'Observation', methods: ['validate']\n          validates profiles: ['validate-profile']\n        }\n\n        @obs.each do |x|\n          reply = @client.validate(x)\n          assert_response_ok(reply)\n          if !reply.id.nil?\n            assert( !reply.id.include?('_validate'), \"Server created an Observation with the ID `_validate` rather than validate the resource.\", reply.id)\n          end\n        end\n      end\n", "test_method" : "c8t3_2a_validate_observations_against_the_general_specification_test" }, { "key" : "C8T3_2B", "id" : "C8T3_2B", "description" : "Validate Observations against a Server-Side Profile", "status" : "pass", "message" : null, "requires" : [ { "resource" : "StructureDefinition", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Observation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#Track_3_-_Experimental:_Profiles_and_conformance", "http://hl7.org/fhir/DSTU2/structuredefinition.html", "http://hl7.org/fhir/DSTU2/observation.html", "http://hl7.org/fhir/DSTU2/operation-resource-validate.html" ], "code" : "      test 'C8T3_2B','Validate Observations against a Server-Side Profile' do\n        metadata {\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_8#Track_3_-_Experimental:_Profiles_and_conformance'\n          links \"#{BASE_SPEC_LINK}/structuredefinition.html\"\n          links \"#{BASE_SPEC_LINK}/observation.html\"\n          links \"#{BASE_SPEC_LINK}/operation-resource-validate.html\"\n          requires resource: 'StructureDefinition', methods: ['create']\n          validates resource: 'Observation', methods: ['validate']\n          validates profiles: ['validate-profile']\n        }\n        \n        # @profile_url = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n        @obs.each do |x|\n          x.meta = FHIR::Resource::ResourceMetaComponent.new\n          x.meta.profile = [ @profile_url ]\n          reply = @client.validate(x,{profile_uri: @profile_url})\n          assert_response_ok(reply)\n          if !reply.id.nil?\n            assert( !reply.id.include?('_validate'), \"Server created an Observation with the ID `_validate` rather than validate the resource.\", reply.id)\n          end\n        end\n      end\n", "test_method" : "c8t3_2b_validate_observations_against_a_server-side_profile_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:36:08.267-0400" }, "created_at" : { "$date" : "2015-10-02T18:36:08.267-0400" } }
,{ "_id" : { "$oid" : "560f06e64d4d3266f8970200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0434d4d3261a6050000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "CST01", "id" : "CST01", "description" : "Find Practitioner's Schedule", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Schedule", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "Schedule", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/schedule.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST01','Find Practitioner\\'s Schedule' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/schedule.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Schedule', methods: ['search']\n          validates resource: 'Schedule', methods: ['search']\n        }\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'actor' => \"Practitioner/#{@practitioner.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::Schedule, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(1, reply.resource.entry.size, 'There should only be one Schedule for the test Practitioner currently in the system.', reply.body)\n        assert_equal(@schedule.xmlId, reply.resource.entry[0].try(:resource).try(:xmlId), 'The correct Schedule was not returned.', reply.body)\n      end\n", "test_method" : "cst01_find_practitioner's_schedule_test" }, { "key" : "CST02", "id" : "CST02", "description" : "Find Slot in Practitioner's Schedule", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Slot", "methods" : [ "search" ] } ], "validates" : [ { "resource" : "Slot", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/slot.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST02','Find Slot in Practitioner\\'s Schedule' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/slot.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Slot', methods: ['search']\n          validates resource: 'Slot', methods: ['search']\n        }\n\n        options = {\n          :search => {\n            :flag => false,\n            :compartment => nil,\n            :parameters => {\n              'schedule' => \"Schedule/#{@schedule.xmlId}\"\n            }\n          }\n        }\n        reply = @client.search(FHIR::Slot, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal(1, reply.resource.entry.size, 'There should only be one Slot for the test Practitioner\\'s Schedule currently in the system.', reply.body)\n        assert_equal(@slot.xmlId, reply.resource.entry[0].try(:resource).try(:xmlId), 'The correct Slot was not returned.', reply.body)\n      end\n", "test_method" : "cst02_find_slot_in_practitioner's_schedule_test" }, { "key" : "CST03", "id" : "CST03", "description" : "Create Proposed Appointment in Slot", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Appointment", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "Appointment", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/appointment.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST03','Create Proposed Appointment in Slot' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['create']\n          validates resource: 'Appointment', methods: ['create']\n        }\n        @appointment = @resources.scheduling_appointment\n        @appointment.xmlId = nil # clear the identifier\n        @appointment.participant[0].actor.reference = \"Patient/#{@patient.xmlId}\"\n        @appointment.participant[1].actor.reference = \"Practitioner/#{@practitioner.xmlId}\"\n        reply = @client.create(@appointment)      \n        assert_response_ok(reply)\n        @appointment.xmlId = reply.id\n      end \n", "test_method" : "cst03_create_proposed_appointment_in_slot_test" }, { "key" : "CST04", "id" : "CST04", "description" : "Update Slot status to busy-tentative", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Slot", "methods" : [ "update" ] } ], "validates" : [ { "resource" : "Slot", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/slot.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST04','Update Slot status to busy-tentative' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/slot.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Slot', methods: ['update']\n          validates resource: 'Slot', methods: ['update']\n        }\n        @slot.freeBusyType = 'busy-tentative'\n        reply = @client.update(@slot,@slot.xmlId)      \n        assert_response_ok(reply)\n      end   \n", "test_method" : "cst04_update_slot_status_to_busy-tentative_test" }, { "key" : "CST05", "id" : "CST05", "description" : "Create AppointmentResponse for Patient (accepted)", "status" : "pass", "message" : null, "requires" : [ { "resource" : "AppointmentResponse", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/appointmentresponse.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST05','Create AppointmentResponse for Patient (accepted)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/appointmentresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'AppointmentResponse', methods: ['create']\n          validates resource: 'AppointmentResponse', methods: ['create']\n        }\n        @appointment_response_patient = @resources.scheduling_response_patient\n        @appointment_response_patient.xmlId = nil # clear the identifier\n        @appointment_response_patient.appointment.reference = \"Appointment/#{@appointment.xmlId}\"\n        reply = @client.create(@appointment_response_patient)      \n        assert_response_ok(reply)\n        @appointment_response_patient.xmlId = reply.id\n      end \n", "test_method" : "cst05_create_appointmentresponse_for_patient_(accepted)_test" }, { "key" : "CST06", "id" : "CST06", "description" : "Update Appointment.participant.status for Patient (accepted)", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "validates" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/appointment.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST06','Update Appointment.participant.status for Patient (accepted)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['update']\n          validates resource: 'Appointment', methods: ['update']\n        }\n        @appointment.participant[0].status = 'accepted'\n        reply = @client.update(@appointment,@appointment.xmlId)      \n        assert_response_ok(reply)\n      end\n", "test_method" : "cst06_update_appointment.participant.status_for_patient_(accepted)_test" }, { "key" : "CST07", "id" : "CST07", "description" : "Create AppointmentResponse for Practitioner (accepted)", "status" : "pass", "message" : null, "requires" : [ { "resource" : "AppointmentResponse", "methods" : [ "create" ] } ], "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/appointmentresponse.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST07','Create AppointmentResponse for Practitioner (accepted)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#create\"\n          links \"#{BASE_SPEC_LINK}/appointmentresponse.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'AppointmentResponse', methods: ['create']\n          validates resource: 'AppointmentResponse', methods: ['create']\n        }\n        @appointment_response_practitioner = @resources.scheduling_response_practitioner\n        @appointment_response_practitioner.xmlId = nil # clear the identifier\n        @appointment_response_practitioner.appointment.reference = \"Appointment/#{@appointment.xmlId}\"\n        reply = @client.create(@appointment_response_practitioner)      \n        assert_response_ok(reply)\n        @appointment_response_practitioner.xmlId = reply.id\n      end \n", "test_method" : "cst07_create_appointmentresponse_for_practitioner_(accepted)_test" }, { "key" : "CST08", "id" : "CST08", "description" : "Update Appointment.participant.status for Practitioner (accepted)", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "validates" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/appointment.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST08','Update Appointment.participant.status for Practitioner (accepted)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['update']\n          validates resource: 'Appointment', methods: ['update']\n        }\n        @appointment.participant[1].status = 'accepted'\n        reply = @client.update(@appointment,@appointment.xmlId)      \n        assert_response_ok(reply)\n      end\n", "test_method" : "cst08_update_appointment.participant.status_for_practitioner_(accepted)_test" }, { "key" : "CST09", "id" : "CST09", "description" : "Update Slot status (busy)", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Slot", "methods" : [ "update" ] } ], "validates" : [ { "resource" : "Slot", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/slot.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST09','Update Slot status (busy)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/slot.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Slot', methods: ['update']\n          validates resource: 'Slot', methods: ['update']\n        }\n        @slot.freeBusyType = 'busy'\n        reply = @client.update(@slot,@slot.xmlId)      \n        assert_response_ok(reply)\n      end  \n", "test_method" : "cst09_update_slot_status_(busy)_test" }, { "key" : "CST10", "id" : "CST10", "description" : "Update Appointment status (booked)", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "validates" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/appointment.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST10','Update Appointment status (booked)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['update']\n          validates resource: 'Appointment', methods: ['update']\n        }\n        @appointment.status = 'booked'\n        reply = @client.update(@appointment,@appointment.xmlId)      \n        assert_response_ok(reply)\n      end \n", "test_method" : "cst10_update_appointment_status_(booked)_test" }, { "key" : "CST11", "id" : "CST11", "description" : "Update Appointment status (cancelled)", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "validates" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/appointment.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST11','Update Appointment status (cancelled)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/appointment.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Appointment', methods: ['update']\n          validates resource: 'Appointment', methods: ['update']\n        }\n        @appointment.status = 'cancelled'\n        reply = @client.update(@appointment,@appointment.xmlId)      \n        assert_response_ok(reply)\n      end \n", "test_method" : "cst11_update_appointment_status_(cancelled)_test" }, { "key" : "CST12", "id" : "CST12", "description" : "Update Slot status (free)", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Slot", "methods" : [ "update" ] } ], "validates" : [ { "resource" : "Slot", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/slot.html", "http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling" ], "code" : "      test 'CST12','Update Slot status (free)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#update\"\n          links \"#{BASE_SPEC_LINK}/slot.html\"\n          links 'http://wiki.hl7.org/index.php?title=FHIR_Connectathon_10#Track_6_-_Scheduling'\n          requires resource: 'Slot', methods: ['update']\n          validates resource: 'Slot', methods: ['update']\n        }\n        @slot.freeBusyType = 'free'\n        reply = @client.update(@slot,@slot.xmlId)      \n        assert_response_ok(reply)\n      end \n", "test_method" : "cst12_update_slot_status_(free)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:36:22.886-0400" }, "created_at" : { "$date" : "2015-10-02T18:36:22.886-0400" } }
,{ "_id" : { "$oid" : "560f06f54d4d3266f8980200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0434d4d3261a6060000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "CT01G", "id" : "CT01G", "description" : "Expand a specific ValueSet (GET)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 500. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"ArgumentNullException: Value cannot be null.&#xD;&#xA;Parameter name: s\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.IO.StringReader..ctor(String s)&#xD;&#xA;   at Hl7.Fhir.Serialization.FhirParser.XmlReaderFromXml(String xml) in C:\\src\\FHIR\\fhir-net-api-DSTU2\\src\\Hl7.Fhir.Core\\Serialization\\FhirParser.cs:line 273&#xD;&#xA;   at Hl7.Fhir.Serialization.FhirParser.ParseResourceFromXml(String xml) in C:\\src\\FHIR\\fhir-net-api-DSTU2\\src\\Hl7.Fhir.Core\\Serialization\\FhirParser.cs:line 311&#xD;&#xA;   at HealthConnex.Fhir.Models.ValueSetModel.GetForExpansion(fhirstore store, String ResourceId, Int64&amp; internal_id) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\ValueSetModel.cs:line 159&#xD;&#xA;   at HealthConnex.Fhir.Models.ValueSetModel.PerformOperation(String id, String operation, Parameters operationParameters, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\ValueSetModel.cs:line 179&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.PerformOperation(String ResourceName, String id, String operation) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 346&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$expand" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#expand" ], "code" : "        test \"CT01#{how[0]}\", \"Expand a specific ValueSet (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#expand\"\n            validates resource: 'ValueSet', methods: ['$expand']\n          }\n          skip if @valueset.nil?\n          options = {\n            :id => @valueset.xmlId,\n            :operation => {\n              :method => how\n            }\n          }\n          reply = @client.value_set_expansion(options)\n          assert_response_ok(reply)\n          assert_resource_type(reply, FHIR::ValueSet)\n          check_expansion_for_concepts(reply.resource)\n        end\n", "test_method" : "ct01g_expand_a_specific_valueset_(get)_test" }, { "key" : "CT02G", "id" : "CT02G", "description" : "Expand a ValueSet by context (GET)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation expand is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$expand" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#expand" ], "code" : "        test \"CT02#{how[0]}\", \"Expand a ValueSet by context (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#expand\"\n            validates resource: 'ValueSet', methods: ['$expand']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'context' => { type: 'Uri', value: 'http://hl7.org/fhir/StructureDefinition/StructureDefinition#StructureDefinition.constrainedType' }\n              }\n            }\n          }\n          reply = @client.value_set_expansion(options)\n          assert_response_ok(reply)\n          assert_resource_type(reply, FHIR::ValueSet)\n          check_expansion_for_concepts(reply.resource)\n        end\n", "test_method" : "ct02g_expand_a_valueset_by_context_(get)_test" }, { "key" : "CT03G", "id" : "CT03G", "description" : "Validate a code (GET)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation validate-code is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$validate-code" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code" ], "code" : "        test \"CT03#{how[0]}\", \"Validate a code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$validate-code']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'female' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/ValueSet/administrative-gender' }\n              }\n            }\n          }\n          reply = @client.value_set_code_validation(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'result','valueBoolean','true')\n        end\n", "test_method" : "ct03g_validate_a_code_(get)_test" }, { "key" : "CT04G", "id" : "CT04G", "description" : "Validate a v2 code (GET)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation validate-code is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$validate-code" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code" ], "code" : "        test \"CT04#{how[0]}\", \"Validate a v2 code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$validate-code']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'BRN' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/v2/0487' }\n              }\n            }\n          }\n          reply = @client.value_set_code_validation(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'result','valueBoolean','true')\n        end\n", "test_method" : "ct04g_validate_a_v2_code_(get)_test" }, { "key" : "CT05G", "id" : "CT05G", "description" : "Lookup a v2 code (GET)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation lookup is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$lookup" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code" ], "code" : "        test \"CT05#{how[0]}\", \"Lookup a v2 code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$lookup']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'BRN' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/v2/0487' }\n              }\n            }\n          }\n          reply = @client.value_set_code_lookup(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'display','valueString','Burn')\n        end\n", "test_method" : "ct05g_lookup_a_v2_code_(get)_test" }, { "key" : "CT01P", "id" : "CT01P", "description" : "Expand a specific ValueSet (POST)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Body parsing failed: Cannot parse xml: Root element is missing.\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$expand" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#expand" ], "code" : "        test \"CT01#{how[0]}\", \"Expand a specific ValueSet (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#expand\"\n            validates resource: 'ValueSet', methods: ['$expand']\n          }\n          skip if @valueset.nil?\n          options = {\n            :id => @valueset.xmlId,\n            :operation => {\n              :method => how\n            }\n          }\n          reply = @client.value_set_expansion(options)\n          assert_response_ok(reply)\n          assert_resource_type(reply, FHIR::ValueSet)\n          check_expansion_for_concepts(reply.resource)\n        end\n", "test_method" : "ct01p_expand_a_specific_valueset_(post)_test" }, { "key" : "CT02P", "id" : "CT02P", "description" : "Expand a ValueSet by context (POST)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation expand is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$expand" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#expand" ], "code" : "        test \"CT02#{how[0]}\", \"Expand a ValueSet by context (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#expand\"\n            validates resource: 'ValueSet', methods: ['$expand']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'context' => { type: 'Uri', value: 'http://hl7.org/fhir/StructureDefinition/StructureDefinition#StructureDefinition.constrainedType' }\n              }\n            }\n          }\n          reply = @client.value_set_expansion(options)\n          assert_response_ok(reply)\n          assert_resource_type(reply, FHIR::ValueSet)\n          check_expansion_for_concepts(reply.resource)\n        end\n", "test_method" : "ct02p_expand_a_valueset_by_context_(post)_test" }, { "key" : "CT03P", "id" : "CT03P", "description" : "Validate a code (POST)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation validate-code is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$validate-code" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code" ], "code" : "        test \"CT03#{how[0]}\", \"Validate a code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$validate-code']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'female' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/ValueSet/administrative-gender' }\n              }\n            }\n          }\n          reply = @client.value_set_code_validation(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'result','valueBoolean','true')\n        end\n", "test_method" : "ct03p_validate_a_code_(post)_test" }, { "key" : "CT04P", "id" : "CT04P", "description" : "Validate a v2 code (POST)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation validate-code is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$validate-code" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code" ], "code" : "        test \"CT04#{how[0]}\", \"Validate a v2 code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$validate-code']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'BRN' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/v2/0487' }\n              }\n            }\n          }\n          reply = @client.value_set_code_validation(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'result','valueBoolean','true')\n        end\n", "test_method" : "ct04p_validate_a_v2_code_(post)_test" }, { "key" : "CT05P", "id" : "CT05P", "description" : "Lookup a v2 code (POST)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 501. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Operation lookup is not supported on the ValueSet resource\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ValueSet", "methods" : [ "$lookup" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operations.html#executing", "http://hl7.org/fhir/DSTU2/valueset-operations.html#validate-code" ], "code" : "        test \"CT05#{how[0]}\", \"Lookup a v2 code (#{how})\" do\n          metadata {\n            links \"#{BASE_SPEC_LINK}/operations.html#executing\"\n            links \"#{BASE_SPEC_LINK}/valueset-operations.html#validate-code\"\n            validates resource: 'ValueSet', methods: ['$lookup']\n          }\n          options = {\n            :operation => {\n              :method => how,\n              :parameters => {\n                'code' => { type: 'Code', value: 'BRN' },\n                'system' => { type: 'Uri', value: 'http://hl7.org/fhir/v2/0487' }\n              }\n            }\n          }\n          reply = @client.value_set_code_lookup(options)\n          assert_response_ok(reply)\n          check_response_params(reply.body,'display','valueString','Burn')\n        end\n", "test_method" : "ct05p_lookup_a_v2_code_(post)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:36:37.305-0400" }, "created_at" : { "$date" : "2015-10-02T18:36:37.305-0400" } }
,{ "_id" : { "$oid" : "560f070c4d4d3266f8990200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a6070000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "CT01", "id" : "CT01", "description" : "Request xml using headers", "status" : "pass", "message" : null, "warnings" : [ "requested XML (headers) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT01', 'Request xml using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format)\n          assert compare_response_format(patient, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (headers) resource does not match created resource' }\n        rescue => e\n          raise AssertionException.new(\"CTO1 - Failed to handle XML format header response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct01_request_xml_using_headers_test" }, { "key" : "CT02A", "id" : "CT02A", "description" : "Request [xml] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT02A', 'Request [xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[0], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct02a_request_[xml]_using_[_format]_test" }, { "key" : "CT02B", "id" : "CT02B", "description" : "Request [text/xml] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT02B', 'Request [text/xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[1], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct02b_request_[text/xml]_using_[_format]_test" }, { "key" : "CT02C", "id" : "CT02C", "description" : "Request [application/xml] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT02C', 'Request [application/xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[2], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct02c_request_[application/xml]_using_[_format]_test" }, { "key" : "CT02D", "id" : "CT02D", "description" : "Request [application/xml+fhir] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT02D', 'Request [application/xml+fhir] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[3], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct02d_request_[application/xml+fhir]_using_[_format]_test" }, { "key" : "CT03", "id" : "CT03", "description" : "Request json using headers", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (headers) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT03', 'Request json using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format)\n          assert compare_response_format(patient, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (headers) resource does not match created resource' }\n        rescue => e\n          raise AssertionException.new(\"CTO3 - Failed to handle JSON format header response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct03_request_json_using_headers_test" }, { "key" : "CT04A", "id" : "CT04A", "description" : "Request [json] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT04A', 'Request [json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[0], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct04a_request_[json]_using_[_format]_test" }, { "key" : "CT04B", "id" : "CT04B", "description" : "Request [text/json] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT04B', 'Request [text/json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[1], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct04b_request_[text/json]_using_[_format]_test" }, { "key" : "CT04C", "id" : "CT04C", "description" : "Request [application/json] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT04C', 'Request [application/json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[2], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct04c_request_[application/json]_using_[_format]_test" }, { "key" : "CT04D", "id" : "CT04D", "description" : "Request [application/json+fhir] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT04D', 'Request [application/json+fhir] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[3], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct04d_request_[application/json+fhir]_using_[_format]_test" }, { "key" : "FT01", "id" : "FT01", "description" : "Request xml and json using headers", "status" : "pass", "message" : null, "warnings" : [ "requested XML & JSON (headers) resources do not match created resource or each other" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML", "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT01', 'Request xml and json using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML','JSON']\n        }\n        begin\n          patient_xml = request_entry(FHIR::Patient, @id, @xml_format)\n          patient_json = request_entry(FHIR::Patient, @id, @json_format)\n\n          assert compare_response_format(patient_xml, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient_xml.response_format}\"\n          assert compare_response_format(patient_json, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient_json.response_format}\"\n          warning { assert compare_entries(patient_xml, patient_json), 'requested XML & JSON (headers) resources do not match created resource or each other' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"FTO1 - Failed to handle XML & JSON header param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft01_request_xml_and_json_using_headers_test" }, { "key" : "FT02", "id" : "FT02", "description" : "Request xml and json using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML & JSON (_format) resources do not match created resource or each other" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML", "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT02', 'Request xml and json using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML','JSON']\n        }\n        begin\n          patient_xml = request_entry(FHIR::Patient, @id, @xml_format, true)\n          patient_json = request_entry(FHIR::Patient, @id, @json_format, true)\n\n          assert compare_response_format(patient_xml, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient_xml.response_format}\"\n          assert compare_response_format(patient_json, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient_json.response_format}\"\n          warning { assert compare_entries(patient_xml, patient_json), 'requested XML & JSON (_format) resources do not match created resource or each other' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"FTO2 - Failed to handle XML & JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft02_request_xml_and_json_using_[_format]_test" }, { "key" : "FT03", "id" : "FT03", "description" : "Request xml Bundle using headers", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT03', 'Request xml Bundle using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format header mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO3 - Failed to handle Bundle XML format header response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft03_request_xml_bundle_using_headers_test" }, { "key" : "FT04A", "id" : "FT04A", "description" : "Request [xml] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT04A', 'Request [xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[0], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft04a_request_[xml]_bundle_using_[_format]_test" }, { "key" : "FT04B", "id" : "FT04B", "description" : "Request [text/xml] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT04B', 'Request [text/xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[1], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft04b_request_[text/xml]_bundle_using_[_format]_test" }, { "key" : "FT04C", "id" : "FT04C", "description" : "Request [application/xml] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT04C', 'Request [application/xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[2], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft04c_request_[application/xml]_bundle_using_[_format]_test" }, { "key" : "FT04D", "id" : "FT04D", "description" : "Request [application/xml+fhir] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT04D', 'Request [application/xml+fhir] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[3], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft04d_request_[application/xml+fhir]_bundle_using_[_format]_test" }, { "key" : "FT05", "id" : "FT05", "description" : "Request json Bundle using headers", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT05', 'Request json Bundle using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format header mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FT05 - Failed to handle Bundle JSON format header response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft05_request_json_bundle_using_headers_test" }, { "key" : "FT06A", "id" : "FT06A", "description" : "Request [json] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT06A', 'Request [json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[0], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft06a_request_[json]_bundle_using_[_format]_test" }, { "key" : "FT06B", "id" : "FT06B", "description" : "Request [text/json] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT06B', 'Request [text/json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[1], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft06b_request_[text/json]_bundle_using_[_format]_test" }, { "key" : "FT06C", "id" : "FT06C", "description" : "Request [application/json] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT06C', 'Request [application/json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[2], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft06c_request_[application/json]_bundle_using_[_format]_test" }, { "key" : "FT06D", "id" : "FT06D", "description" : "Request [application/json+fhir] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT06D', 'Request [application/json+fhir] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[3], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft06d_request_[application/json+fhir]_bundle_using_[_format]_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:37:00.273-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:00.273-0400" } }
,{ "_id" : { "$oid" : "560f07244d4d3266f89d0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a6080000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "HI01", "id" : "HI01", "description" : "History for specific resource", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test  'HI01','History for specific resource' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-instance\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n        bundle = result.resource\n\n        assert_equal \"history\", bundle.fhirType, \"The bundle type is not correct\"\n        assert_equal @version_count, bundle.total, \"the number of returned versions is not correct\"\n        check_sort_order(bundle.entry)\n      end\n", "test_method" : "hi01_history_for_specific_resource_test" }, { "key" : "HI01.1", "id" : "HI01.1", "description" : "History request entries", "status" : "fail", "message" : "Wrong number of PUT transactions in the history bundle Expected: 1, but found: 0.", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test  'HI01.1','History request entries' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-instance\"]\n        }\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n        bundle = result.resource\n        entries = bundle.entry\n\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'DELETE' }.size, 'Wrong number of DELETE transactions in the history bundle'\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'PUT' }.size, 'Wrong number of PUT transactions in the history bundle'\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'POST' }.size, 'Wrong number of POST transactions in the history bundle'\n\n      end\n", "test_method" : "hi01.1_history_request_entries_test" }, { "key" : "HI02", "id" : "HI02", "description" : "full history of a resource by id with since", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 404. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Exception of type 'Hl7.Fhir.Server.FhirServerException' was thrown.\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI02\", \"full history of a resource by id with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-instance\"]\n        }\n\n        before = @create_date - 1.minute\n        after = before + 1.hour\n\n        all_history = @client.resource_instance_history(FHIR::Patient,@id)\n\n        result = @client.resource_instance_history_as_of(FHIR::Patient,@id,before)\n        assert_response_ok result\n        bundle = result.resource\n\n        assert_equal @version_count, bundle.total, \"the number of returned versions since the creation date is not correct\"\n\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n        result = @client.resource_instance_history_as_of(FHIR::Patient,@id,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"there should not be any history one hour after the creation date\"\n      end\n", "test_method" : "hi02_full_history_of_a_resource_by_id_with_since_test" }, { "key" : "HI03", "id" : "HI03", "description" : "individual history versions", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "vread", "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI03\", \"individual history versions\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"vread\", \"history-instance\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n\n        bundle = result.resource\n\n        active_entries(bundle.entry).each do |entry|\n          pulled = @client.vread(FHIR::Patient, entry.resource.xmlId, entry.resource.meta.versionId)\n          assert_response_ok pulled\n          assert !pulled.nil?, \"Cannot find version that was present in history\"\n        end\n\n        deleted_entries(bundle.entry).each do |entry|\n          # FIXME: Should we parse the request URL or drop this assertion?\n          if entry.resource\n            pulled = @client.vread(FHIR::Patient, entry.resource.xmlId, entry.resource.meta.versionId)\n            assert pulled.resource.nil?, \"resource should not be found since it was deleted\"\n            assert_response_gone pulled\n          end\n        end\n      end\n", "test_method" : "hi03_individual_history_versions_test" }, { "key" : "HI04", "id" : "HI04", "description" : "history for missing resource", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI04\", \"history for missing resource\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-instance\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,'3141592unlikely')\n        assert_response_not_found result\n        assert result.resource.nil?, 'bad history request should not return a resource'\n      end\n", "test_method" : "hi04_history_for_missing_resource_test" }, { "key" : "HI06", "id" : "HI06", "description" : "all history for resource with since", "status" : "fail", "message" : "Setting since to a future moment still returns history Expected: 0, but found: 9.", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-type" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI06\", \"all history for resource with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        before = @create_date - 1.minute\n        after = Time.now.utc + 1.minute\n\n        result = @client.resource_history_as_of(FHIR::Patient,before)\n        assert_response_ok result\n        bundle = result.resource\n\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n\n        result = @client.resource_history_as_of(FHIR::Patient,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"Setting since to a future moment still returns history\"\n\n      end\n", "test_method" : "hi06_all_history_for_resource_with_since_test" }, { "key" : "HI08", "id" : "HI08", "description" : "all history whole system with since", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 404. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Resource [_history] is not supported on this server\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : null, "methods" : [ "history-system" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI08\", \"all history whole system with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: nil, methods: [\"history-system\"]\n        }\n\n        before = @create_date - 1.minute\n        after = Time.now.utc + 1.minute\n\n        result = @client.all_history_as_of(before)\n        assert_response_ok result\n        bundle = result.resource\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n        warning { assert_navigation_links(bundle) }\n\n        result = @client.resource_history_as_of(FHIR::Patient,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"Setting since to a future moment still returns history\"\n\n      end\n", "test_method" : "hi08_all_history_whole_system_with_since_test" }, { "key" : "HI09", "id" : "HI09", "description" : "resource history page forward", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-type" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI09\", \"resource history page forward\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        page_size = 2\n        page = @client.history(resource: FHIR::Patient, history: {since: (Time.now.utc - 1.hour), count: page_size})\n\n        forward_count = 0\n        # browse forwards\n        while page != nil\n          assert !page.resource.nil?, \"Unable to page forward through results.  A bundle was not returned from the page forward request.\"\n          warning { entry_ids_are_present(page.resource.entry) }\n          assert page.resource.entry.size <= page_size, \"Server returned a page with more entries than set by _count\"\n          forward_count += page.resource.entry.size\n          page = @client.next_page(page)\n        end\n\n        assert forward_count > 2, \"there should be at least 2 history entries\"\n      end\n", "test_method" : "hi09_resource_history_page_forward_test" }, { "key" : "HI10", "id" : "HI10", "description" : "resource history page backwards", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-type" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI10\", \"resource history page backwards\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        page_size = 2\n        page = @client.history(resource: FHIR::Patient, history: {since: (Time.now.utc - 1.hour), count: page_size})\n\n        forward_count = 0\n        last_page = page\n        # browse forwards\n        while page != nil\n          assert !page.resource.nil?, \"Unable to page forward through results.  A bundle was not returned from the page forward request.\"\n          forward_count += page.resource.entry.size\n          page = @client.next_page(page)\n          last_page = page if page\n        end\n\n        backward_count = 0\n        page = last_page\n        # browse backwards\n        while page != nil\n          warning { entry_ids_are_present(page.resource.entry) }\n          assert page.resource.entry.size <= page_size, \"Server returned a page with more entries than set by _count\"\n          backward_count += page.resource.entry.size\n          page = @client.next_page(page, FHIR::Sections::Feed::BACKWARD)\n        end\n\n        assert_equal forward_count, backward_count, \"entry numbers were different moving forwards and backwards\"\n\n      end\n", "test_method" : "hi10_resource_history_page_backwards_test" }, { "key" : "HI11", "id" : "HI11", "description" : "first page full history", "status" : "fail", "message" : "A bundle was not returned from the history request.", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : null, "methods" : [ "history-system" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI11\", \"first page full history\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: nil, methods: [\"history-system\"]\n        }\n\n        history = @client.all_history\n        assert !history.resource.nil?, \"A bundle was not returned from the history request.\"\n        assert history.resource.entry.size >= 3, \"there should be at least 3 history entries\"\n      end\n", "test_method" : "hi11_first_page_full_history_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:37:24.408-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:24.408-0400" } }
,{ "_id" : { "$oid" : "560f07274d4d3266f89e0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a6090000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "R001", "id" : "R001", "description" : "Result headers on normal read.", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'R001', 'Result headers on normal read.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        assert(@id, 'Setup was unable to create a patient.',@body)\n        reply = @client.read(FHIR::Patient, @id)\n        assert_response_ok(reply)\n        assert_equal @id, reply.id, 'Server returned wrong patient.'\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_etag_present(reply) }\n        warning { assert_last_modified_present(reply) }\n      end\n", "test_method" : "r001_result_headers_on_normal_read._test" }, { "key" : "R002", "id" : "R002", "description" : "Read unknown resource type.", "status" : "pass", "message" : null, "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/http.html#update" ], "code" : "      test 'R002', 'Read unknown resource type.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{REST_SPEC_LINK}#update\"\n        }\n\n        reply = @client.read(Crucible::Tests::ReadTest, @id)\n        assert_response_not_found(reply)\n      end\n", "test_method" : "r002_read_unknown_resource_type._test" }, { "key" : "R003", "id" : "R003", "description" : "Read non-existing resource id.", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'R003', 'Read non-existing resource id.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        reply = @client.read(FHIR::Patient, 'Supercalifragilisticexpialidocious')\n        assert_response_not_found(reply)\n      end\n", "test_method" : "r003_read_non-existing_resource_id._test" }, { "key" : "R004", "id" : "R004", "description" : "Read invalid format resource id", "status" : "fail", "message" : "Bad response code: expected 400, but found 404", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/datatypes.html#id", "http://hl7.org/fhir/DSTU2/resource.html#id" ], "code" : "      test 'R004', 'Read invalid format resource id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/datatypes.html#id\"\n          links \"#{BASE_SPEC_LINK}/resource.html#id\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        reply = @client.read(FHIR::Patient, 'Invalid-ID-Because_Of_!@$Special_Characters_and_Length_Over_Sixty_Four_Characters')\n        assert_response_bad(reply)\n      end\n", "test_method" : "r004_read_invalid_format_resource_id_test" }, { "key" : "R005", "id" : "R005", "description" : "Read _summary=text", "status" : "fail", "message" : "Requested summary narrative was not provided.", "data" : "﻿<Patient xmlns=\"http://hl7.org/fhir\"><id value=\"9940f2415237475d8e8d62753dd1b79f\" /><meta><versionId value=\"458\" /><lastUpdated value=\"2015-10-02T22:37:24.957+00:00\" /></meta><name><family value=\"Emerald\" /><given value=\"Caro\" /></name></Patient>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/datatypes.html#id", "http://hl7.org/fhir/DSTU2/resource.html#id" ], "code" : "      test 'R005', 'Read _summary=text' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/datatypes.html#id\"\n          links \"#{BASE_SPEC_LINK}/resource.html#id\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        assert(@id, 'Setup was unable to create a patient.', @body)\n        reply = @client.read(FHIR::Patient, @id, @client.default_format, 'text')\n        assert_response_ok(reply)\n        assert(reply.try(:resource).try(:text), 'Requested summary narrative was not provided.', reply.body)\n      end      \n", "test_method" : "r005_read__summary=text_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:37:27.821-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:27.821-0400" } }
,{ "_id" : { "$oid" : "560f072f4d4d3266f89f0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Account", "description" : "Account: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Account", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Account", "description" : "Account: Create New", "status" : "pass", "message" : "New Account was created.", "validates" : [ { "resource" : "Account", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Account", "description" : "Account: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Account.", "validates" : [ { "resource" : "Account", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Account", "description" : "Account: Update Existing", "status" : "pass", "message" : "Updated existing Account.", "validates" : [ { "resource" : "Account", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Account", "description" : "Account: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Account", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Account", "description" : "Account: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Account.", "validates" : [ { "resource" : "Account", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Account", "description" : "Account: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Account.", "validates" : [ { "resource" : "Account", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Account", "description" : "Account: Validate", "status" : "pass", "message" : "Account was validated.", "validates" : [ { "resource" : "Account", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Account", "description" : "Account: Validate Existing", "status" : "pass", "message" : "Existing Account was validated.", "validates" : [ { "resource" : "Account", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Account", "description" : "Account: Validate against a profile", "status" : "pass", "message" : "Account was validated.", "validates" : [ { "resource" : "Account", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Account", "description" : "Account: Delete Existing", "status" : "pass", "message" : "Existing Account was deleted.", "validates" : [ { "resource" : "Account", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Account", "description" : "Account: Get Deleted Resource", "status" : "pass", "message" : "Deleted Account was correctly reported as gone.", "validates" : [ { "resource" : "Account", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:37:35.185-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:35.185-0400" } }
,{ "_id" : { "$oid" : "560f07364d4d3266f8a00200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_AllergyIntolerance", "description" : "AllergyIntolerance: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_AllergyIntolerance", "description" : "AllergyIntolerance: Create New", "status" : "pass", "message" : "New AllergyIntolerance was created.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_AllergyIntolerance", "description" : "AllergyIntolerance: Read Existing", "status" : "pass", "message" : "Successfully read preexisting AllergyIntolerance.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_AllergyIntolerance", "description" : "AllergyIntolerance: Update Existing", "status" : "pass", "message" : "Updated existing AllergyIntolerance.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_AllergyIntolerance", "description" : "AllergyIntolerance: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_AllergyIntolerance", "description" : "AllergyIntolerance: Version read existing", "status" : "pass", "message" : "Read current version of preexisting AllergyIntolerance.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_AllergyIntolerance", "description" : "AllergyIntolerance: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting AllergyIntolerance.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_AllergyIntolerance", "description" : "AllergyIntolerance: Validate", "status" : "pass", "message" : "AllergyIntolerance was validated.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_AllergyIntolerance", "description" : "AllergyIntolerance: Validate Existing", "status" : "pass", "message" : "Existing AllergyIntolerance was validated.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_AllergyIntolerance", "description" : "AllergyIntolerance: Validate against a profile", "status" : "pass", "message" : "AllergyIntolerance was validated.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_AllergyIntolerance", "description" : "AllergyIntolerance: Delete Existing", "status" : "pass", "message" : "Existing AllergyIntolerance was deleted.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_AllergyIntolerance", "description" : "AllergyIntolerance: Get Deleted Resource", "status" : "pass", "message" : "Deleted AllergyIntolerance was correctly reported as gone.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:37:42.691-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:42.691-0400" } }
,{ "_id" : { "$oid" : "560f073e4d4d3266f8a10200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Appointment", "description" : "Appointment: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Appointment", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Appointment", "description" : "Appointment: Create New", "status" : "pass", "message" : "New Appointment was created.", "validates" : [ { "resource" : "Appointment", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Appointment", "description" : "Appointment: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Appointment.", "validates" : [ { "resource" : "Appointment", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Appointment", "description" : "Appointment: Update Existing", "status" : "pass", "message" : "Updated existing Appointment.", "validates" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Appointment", "description" : "Appointment: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Appointment", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Appointment", "description" : "Appointment: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Appointment.", "validates" : [ { "resource" : "Appointment", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Appointment", "description" : "Appointment: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Appointment.", "validates" : [ { "resource" : "Appointment", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Appointment", "description" : "Appointment: Validate", "status" : "pass", "message" : "Appointment was validated.", "validates" : [ { "resource" : "Appointment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Appointment", "description" : "Appointment: Validate Existing", "status" : "pass", "message" : "Existing Appointment was validated.", "validates" : [ { "resource" : "Appointment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Appointment", "description" : "Appointment: Validate against a profile", "status" : "pass", "message" : "Appointment was validated.", "validates" : [ { "resource" : "Appointment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Appointment", "description" : "Appointment: Delete Existing", "status" : "pass", "message" : "Existing Appointment was deleted.", "validates" : [ { "resource" : "Appointment", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Appointment", "description" : "Appointment: Get Deleted Resource", "status" : "pass", "message" : "Deleted Appointment was correctly reported as gone.", "validates" : [ { "resource" : "Appointment", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:37:50.242-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:50.242-0400" } }
,{ "_id" : { "$oid" : "560f07454d4d3266f8a20200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_AppointmentResponse", "description" : "AppointmentResponse: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_AppointmentResponse", "description" : "AppointmentResponse: Create New", "status" : "pass", "message" : "New AppointmentResponse was created.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_AppointmentResponse", "description" : "AppointmentResponse: Read Existing", "status" : "pass", "message" : "Successfully read preexisting AppointmentResponse.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_AppointmentResponse", "description" : "AppointmentResponse: Update Existing", "status" : "pass", "message" : "Updated existing AppointmentResponse.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_AppointmentResponse", "description" : "AppointmentResponse: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_AppointmentResponse", "description" : "AppointmentResponse: Version read existing", "status" : "pass", "message" : "Read current version of preexisting AppointmentResponse.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_AppointmentResponse", "description" : "AppointmentResponse: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting AppointmentResponse.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_AppointmentResponse", "description" : "AppointmentResponse: Validate", "status" : "pass", "message" : "AppointmentResponse was validated.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_AppointmentResponse", "description" : "AppointmentResponse: Validate Existing", "status" : "pass", "message" : "Existing AppointmentResponse was validated.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_AppointmentResponse", "description" : "AppointmentResponse: Validate against a profile", "status" : "pass", "message" : "AppointmentResponse was validated.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_AppointmentResponse", "description" : "AppointmentResponse: Delete Existing", "status" : "pass", "message" : "Existing AppointmentResponse was deleted.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_AppointmentResponse", "description" : "AppointmentResponse: Get Deleted Resource", "status" : "pass", "message" : "Deleted AppointmentResponse was correctly reported as gone.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:37:57.257-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:57.257-0400" } }
,{ "_id" : { "$oid" : "560f074e4d4d3266f8a30200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_AuditEvent", "description" : "AuditEvent: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AuditEvent", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_AuditEvent", "description" : "AuditEvent: Create New", "status" : "pass", "message" : "New AuditEvent was created.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_AuditEvent", "description" : "AuditEvent: Read Existing", "status" : "pass", "message" : "Successfully read preexisting AuditEvent.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_AuditEvent", "description" : "AuditEvent: Update Existing", "status" : "fail", "message" : [ "error: : System AuditEvents cannot be modified" ], "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"System AuditEvents cannot be modified\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_AuditEvent", "description" : "AuditEvent: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_AuditEvent", "description" : "AuditEvent: Version read existing", "status" : "pass", "message" : "Read current version of preexisting AuditEvent.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_AuditEvent", "description" : "AuditEvent: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting AuditEvent.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_AuditEvent", "description" : "AuditEvent: Validate", "status" : "pass", "message" : "AuditEvent was validated.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_AuditEvent", "description" : "AuditEvent: Validate Existing", "status" : "pass", "message" : "Existing AuditEvent was validated.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_AuditEvent", "description" : "AuditEvent: Validate against a profile", "status" : "pass", "message" : "AuditEvent was validated.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_AuditEvent", "description" : "AuditEvent: Delete Existing", "status" : "pass", "message" : "Existing AuditEvent was deleted.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_AuditEvent", "description" : "AuditEvent: Get Deleted Resource", "status" : "pass", "message" : "Deleted AuditEvent was correctly reported as gone.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:38:06.839-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:06.839-0400" } }
,{ "_id" : { "$oid" : "560f07584d4d3266f8a40200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a60f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Basic", "description" : "Basic: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Basic", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Basic", "description" : "Basic: Create New", "status" : "pass", "message" : "New Basic was created.", "validates" : [ { "resource" : "Basic", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Basic", "description" : "Basic: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Basic.", "validates" : [ { "resource" : "Basic", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Basic", "description" : "Basic: Update Existing", "status" : "pass", "message" : "Updated existing Basic.", "validates" : [ { "resource" : "Basic", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Basic", "description" : "Basic: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Basic", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Basic", "description" : "Basic: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Basic.", "validates" : [ { "resource" : "Basic", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Basic", "description" : "Basic: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Basic.", "validates" : [ { "resource" : "Basic", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Basic", "description" : "Basic: Validate", "status" : "pass", "message" : "Basic was validated.", "validates" : [ { "resource" : "Basic", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Basic", "description" : "Basic: Validate Existing", "status" : "pass", "message" : "Existing Basic was validated.", "validates" : [ { "resource" : "Basic", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Basic", "description" : "Basic: Validate against a profile", "status" : "pass", "message" : "Basic was validated.", "validates" : [ { "resource" : "Basic", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Basic", "description" : "Basic: Delete Existing", "status" : "pass", "message" : "Existing Basic was deleted.", "validates" : [ { "resource" : "Basic", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Basic", "description" : "Basic: Get Deleted Resource", "status" : "pass", "message" : "Deleted Basic was correctly reported as gone.", "validates" : [ { "resource" : "Basic", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:38:16.381-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:16.381-0400" } }
,{ "_id" : { "$oid" : "560f075f4d4d3266f8a50200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a6100000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Binary", "description" : "Binary: Read Type", "status" : "fail", "message" : "Expected FHIR Bundle but found: OperationOutcome", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "Binary", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Binary", "description" : "Binary: Create New", "status" : "pass", "message" : "New Binary was created.", "validates" : [ { "resource" : "Binary", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Binary", "description" : "Binary: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Binary.", "validates" : [ { "resource" : "Binary", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Binary", "description" : "Binary: Update Existing", "status" : "pass", "message" : "Updated existing Binary.", "validates" : [ { "resource" : "Binary", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Binary", "description" : "Binary: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Binary", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Binary", "description" : "Binary: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Binary.", "validates" : [ { "resource" : "Binary", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Binary", "description" : "Binary: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Binary.", "validates" : [ { "resource" : "Binary", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Binary", "description" : "Binary: Validate", "status" : "fail", "message" : "Response code 400 with no OperationOutcome provided.", "data" : "{\"Message\":\"The request is invalid.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Binary", "description" : "Binary: Validate Existing", "status" : "fail", "message" : "Response code 400 with no OperationOutcome provided.", "data" : "{\"Message\":\"The request is invalid.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Binary", "description" : "Binary: Validate against a profile", "status" : "fail", "message" : "Response code 400 with no OperationOutcome provided.", "data" : "{\"Message\":\"The request is invalid.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Binary", "description" : "Binary: Delete Existing", "status" : "pass", "message" : "Existing Binary was deleted.", "validates" : [ { "resource" : "Binary", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Binary", "description" : "Binary: Get Deleted Resource", "status" : "pass", "message" : "Deleted Binary was correctly reported as gone.", "validates" : [ { "resource" : "Binary", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:38:23.689-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:23.689-0400" } }
,{ "_id" : { "$oid" : "560f07674d4d3266f8a60200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a6110000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_BodySite", "description" : "BodySite: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "BodySite", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_BodySite", "description" : "BodySite: Create New", "status" : "pass", "message" : "New BodySite was created.", "validates" : [ { "resource" : "BodySite", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_BodySite", "description" : "BodySite: Read Existing", "status" : "pass", "message" : "Successfully read preexisting BodySite.", "validates" : [ { "resource" : "BodySite", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_BodySite", "description" : "BodySite: Update Existing", "status" : "pass", "message" : "Updated existing BodySite.", "validates" : [ { "resource" : "BodySite", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_BodySite", "description" : "BodySite: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "BodySite", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_BodySite", "description" : "BodySite: Version read existing", "status" : "pass", "message" : "Read current version of preexisting BodySite.", "validates" : [ { "resource" : "BodySite", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_BodySite", "description" : "BodySite: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting BodySite.", "validates" : [ { "resource" : "BodySite", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_BodySite", "description" : "BodySite: Validate", "status" : "pass", "message" : "BodySite was validated.", "validates" : [ { "resource" : "BodySite", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_BodySite", "description" : "BodySite: Validate Existing", "status" : "pass", "message" : "Existing BodySite was validated.", "validates" : [ { "resource" : "BodySite", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_BodySite", "description" : "BodySite: Validate against a profile", "status" : "pass", "message" : "BodySite was validated.", "validates" : [ { "resource" : "BodySite", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_BodySite", "description" : "BodySite: Delete Existing", "status" : "pass", "message" : "Existing BodySite was deleted.", "validates" : [ { "resource" : "BodySite", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_BodySite", "description" : "BodySite: Get Deleted Resource", "status" : "pass", "message" : "Deleted BodySite was correctly reported as gone.", "validates" : [ { "resource" : "BodySite", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:38:31.253-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:31.253-0400" } }
,{ "_id" : { "$oid" : "560f076d4d4d3266f8a70200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a6120000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Bundle", "description" : "Bundle: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Bundle", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Bundle", "description" : "Bundle: Create New", "status" : "pass", "message" : "New Bundle was created.", "validates" : [ { "resource" : "Bundle", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Bundle", "description" : "Bundle: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Bundle.", "validates" : [ { "resource" : "Bundle", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Bundle", "description" : "Bundle: Update Existing", "status" : "pass", "message" : "Updated existing Bundle.", "validates" : [ { "resource" : "Bundle", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Bundle", "description" : "Bundle: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Bundle", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Bundle", "description" : "Bundle: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Bundle.", "validates" : [ { "resource" : "Bundle", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Bundle", "description" : "Bundle: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Bundle.", "validates" : [ { "resource" : "Bundle", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Bundle", "description" : "Bundle: Validate", "status" : "pass", "message" : "Bundle was validated.", "validates" : [ { "resource" : "Bundle", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Bundle", "description" : "Bundle: Validate Existing", "status" : "pass", "message" : "Existing Bundle was validated.", "validates" : [ { "resource" : "Bundle", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Bundle", "description" : "Bundle: Validate against a profile", "status" : "pass", "message" : "Bundle was validated.", "validates" : [ { "resource" : "Bundle", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Bundle", "description" : "Bundle: Delete Existing", "status" : "pass", "message" : "Existing Bundle was deleted.", "validates" : [ { "resource" : "Bundle", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Bundle", "description" : "Bundle: Get Deleted Resource", "status" : "pass", "message" : "Deleted Bundle was correctly reported as gone.", "validates" : [ { "resource" : "Bundle", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:38:37.718-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:37.718-0400" } }
,{ "_id" : { "$oid" : "560f07774d4d3266f8a80200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a6130000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_CarePlan", "description" : "CarePlan: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CarePlan", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_CarePlan", "description" : "CarePlan: Create New", "status" : "pass", "message" : "New CarePlan was created.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_CarePlan", "description" : "CarePlan: Read Existing", "status" : "pass", "message" : "Successfully read preexisting CarePlan.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_CarePlan", "description" : "CarePlan: Update Existing", "status" : "pass", "message" : "Updated existing CarePlan.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_CarePlan", "description" : "CarePlan: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_CarePlan", "description" : "CarePlan: Version read existing", "status" : "pass", "message" : "Read current version of preexisting CarePlan.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_CarePlan", "description" : "CarePlan: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting CarePlan.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_CarePlan", "description" : "CarePlan: Validate", "status" : "pass", "message" : "CarePlan was validated.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_CarePlan", "description" : "CarePlan: Validate Existing", "status" : "pass", "message" : "Existing CarePlan was validated.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_CarePlan", "description" : "CarePlan: Validate against a profile", "status" : "pass", "message" : "CarePlan was validated.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_CarePlan", "description" : "CarePlan: Delete Existing", "status" : "pass", "message" : "Existing CarePlan was deleted.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_CarePlan", "description" : "CarePlan: Get Deleted Resource", "status" : "pass", "message" : "Deleted CarePlan was correctly reported as gone.", "validates" : [ { "resource" : "CarePlan", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:38:47.180-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:47.180-0400" } }
,{ "_id" : { "$oid" : "560f07814d4d3266f8a90200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a6140000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Claim", "description" : "Claim: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Claim", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Claim", "description" : "Claim: Create New", "status" : "pass", "message" : "New Claim was created.", "validates" : [ { "resource" : "Claim", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Claim", "description" : "Claim: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Claim.", "validates" : [ { "resource" : "Claim", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Claim", "description" : "Claim: Update Existing", "status" : "pass", "message" : "Updated existing Claim.", "validates" : [ { "resource" : "Claim", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Claim", "description" : "Claim: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Claim", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Claim", "description" : "Claim: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Claim.", "validates" : [ { "resource" : "Claim", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Claim", "description" : "Claim: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Claim.", "validates" : [ { "resource" : "Claim", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Claim", "description" : "Claim: Validate", "status" : "pass", "message" : "Claim was validated.", "validates" : [ { "resource" : "Claim", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Claim", "description" : "Claim: Validate Existing", "status" : "pass", "message" : "Existing Claim was validated.", "validates" : [ { "resource" : "Claim", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Claim", "description" : "Claim: Validate against a profile", "status" : "pass", "message" : "Claim was validated.", "validates" : [ { "resource" : "Claim", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Claim", "description" : "Claim: Delete Existing", "status" : "pass", "message" : "Existing Claim was deleted.", "validates" : [ { "resource" : "Claim", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Claim", "description" : "Claim: Get Deleted Resource", "status" : "pass", "message" : "Deleted Claim was correctly reported as gone.", "validates" : [ { "resource" : "Claim", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:38:57.814-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:57.814-0400" } }
,{ "_id" : { "$oid" : "560f07894d4d3266f8aa0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a6150000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ClaimResponse", "description" : "ClaimResponse: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ClaimResponse", "description" : "ClaimResponse: Create New", "status" : "pass", "message" : "New ClaimResponse was created.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ClaimResponse", "description" : "ClaimResponse: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ClaimResponse.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ClaimResponse", "description" : "ClaimResponse: Update Existing", "status" : "pass", "message" : "Updated existing ClaimResponse.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ClaimResponse", "description" : "ClaimResponse: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ClaimResponse", "description" : "ClaimResponse: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ClaimResponse.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ClaimResponse", "description" : "ClaimResponse: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ClaimResponse.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ClaimResponse", "description" : "ClaimResponse: Validate", "status" : "pass", "message" : "ClaimResponse was validated.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ClaimResponse", "description" : "ClaimResponse: Validate Existing", "status" : "pass", "message" : "Existing ClaimResponse was validated.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ClaimResponse", "description" : "ClaimResponse: Validate against a profile", "status" : "pass", "message" : "ClaimResponse was validated.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ClaimResponse", "description" : "ClaimResponse: Delete Existing", "status" : "pass", "message" : "Existing ClaimResponse was deleted.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ClaimResponse", "description" : "ClaimResponse: Get Deleted Resource", "status" : "pass", "message" : "Deleted ClaimResponse was correctly reported as gone.", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:39:05.667-0400" }, "created_at" : { "$date" : "2015-10-02T18:39:05.667-0400" } }
,{ "_id" : { "$oid" : "560f07914d4d3266f8ab0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0464d4d3261a6160000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ClinicalImpression", "description" : "ClinicalImpression: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ClinicalImpression", "description" : "ClinicalImpression: Create New", "status" : "pass", "message" : "New ClinicalImpression was created.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ClinicalImpression", "description" : "ClinicalImpression: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ClinicalImpression.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ClinicalImpression", "description" : "ClinicalImpression: Update Existing", "status" : "pass", "message" : "Updated existing ClinicalImpression.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ClinicalImpression", "description" : "ClinicalImpression: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ClinicalImpression", "description" : "ClinicalImpression: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ClinicalImpression.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ClinicalImpression", "description" : "ClinicalImpression: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ClinicalImpression.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ClinicalImpression", "description" : "ClinicalImpression: Validate", "status" : "pass", "message" : "ClinicalImpression was validated.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ClinicalImpression", "description" : "ClinicalImpression: Validate Existing", "status" : "pass", "message" : "Existing ClinicalImpression was validated.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ClinicalImpression", "description" : "ClinicalImpression: Validate against a profile", "status" : "pass", "message" : "ClinicalImpression was validated.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ClinicalImpression", "description" : "ClinicalImpression: Delete Existing", "status" : "pass", "message" : "Existing ClinicalImpression was deleted.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ClinicalImpression", "description" : "ClinicalImpression: Get Deleted Resource", "status" : "pass", "message" : "Deleted ClinicalImpression was correctly reported as gone.", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:39:13.632-0400" }, "created_at" : { "$date" : "2015-10-02T18:39:13.632-0400" } }
,{ "_id" : { "$oid" : "560f07994d4d3266f8ac0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0464d4d3261a6170000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Communication", "description" : "Communication: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Communication", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Communication", "description" : "Communication: Create New", "status" : "pass", "message" : "New Communication was created.", "validates" : [ { "resource" : "Communication", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Communication", "description" : "Communication: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Communication.", "validates" : [ { "resource" : "Communication", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Communication", "description" : "Communication: Update Existing", "status" : "pass", "message" : "Updated existing Communication.", "validates" : [ { "resource" : "Communication", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Communication", "description" : "Communication: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Communication", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Communication", "description" : "Communication: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Communication.", "validates" : [ { "resource" : "Communication", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Communication", "description" : "Communication: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Communication.", "validates" : [ { "resource" : "Communication", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Communication", "description" : "Communication: Validate", "status" : "pass", "message" : "Communication was validated.", "validates" : [ { "resource" : "Communication", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Communication", "description" : "Communication: Validate Existing", "status" : "pass", "message" : "Existing Communication was validated.", "validates" : [ { "resource" : "Communication", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Communication", "description" : "Communication: Validate against a profile", "status" : "pass", "message" : "Communication was validated.", "validates" : [ { "resource" : "Communication", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Communication", "description" : "Communication: Delete Existing", "status" : "pass", "message" : "Existing Communication was deleted.", "validates" : [ { "resource" : "Communication", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Communication", "description" : "Communication: Get Deleted Resource", "status" : "pass", "message" : "Deleted Communication was correctly reported as gone.", "validates" : [ { "resource" : "Communication", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:39:21.263-0400" }, "created_at" : { "$date" : "2015-10-02T18:39:21.263-0400" } }
,{ "_id" : { "$oid" : "560f079f4d4d3266f8ad0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0464d4d3261a6180000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_CommunicationRequest", "description" : "CommunicationRequest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_CommunicationRequest", "description" : "CommunicationRequest: Create New", "status" : "pass", "message" : "New CommunicationRequest was created.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_CommunicationRequest", "description" : "CommunicationRequest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting CommunicationRequest.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_CommunicationRequest", "description" : "CommunicationRequest: Update Existing", "status" : "pass", "message" : "Updated existing CommunicationRequest.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_CommunicationRequest", "description" : "CommunicationRequest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_CommunicationRequest", "description" : "CommunicationRequest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting CommunicationRequest.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_CommunicationRequest", "description" : "CommunicationRequest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting CommunicationRequest.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_CommunicationRequest", "description" : "CommunicationRequest: Validate", "status" : "pass", "message" : "CommunicationRequest was validated.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_CommunicationRequest", "description" : "CommunicationRequest: Validate Existing", "status" : "pass", "message" : "Existing CommunicationRequest was validated.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_CommunicationRequest", "description" : "CommunicationRequest: Validate against a profile", "status" : "pass", "message" : "CommunicationRequest was validated.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_CommunicationRequest", "description" : "CommunicationRequest: Delete Existing", "status" : "pass", "message" : "Existing CommunicationRequest was deleted.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_CommunicationRequest", "description" : "CommunicationRequest: Get Deleted Resource", "status" : "pass", "message" : "Deleted CommunicationRequest was correctly reported as gone.", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:39:27.825-0400" }, "created_at" : { "$date" : "2015-10-02T18:39:27.825-0400" } }
,{ "_id" : { "$oid" : "560f07a74d4d3266f8ae0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0464d4d3261a6190000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Composition", "description" : "Composition: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Composition", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Composition", "description" : "Composition: Create New", "status" : "pass", "message" : "New Composition was created.", "validates" : [ { "resource" : "Composition", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Composition", "description" : "Composition: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Composition.", "validates" : [ { "resource" : "Composition", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Composition", "description" : "Composition: Update Existing", "status" : "pass", "message" : "Updated existing Composition.", "validates" : [ { "resource" : "Composition", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Composition", "description" : "Composition: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Composition", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Composition", "description" : "Composition: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Composition.", "validates" : [ { "resource" : "Composition", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Composition", "description" : "Composition: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Composition.", "validates" : [ { "resource" : "Composition", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Composition", "description" : "Composition: Validate", "status" : "pass", "message" : "Composition was validated.", "validates" : [ { "resource" : "Composition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Composition", "description" : "Composition: Validate Existing", "status" : "pass", "message" : "Existing Composition was validated.", "validates" : [ { "resource" : "Composition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Composition", "description" : "Composition: Validate against a profile", "status" : "pass", "message" : "Composition was validated.", "validates" : [ { "resource" : "Composition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Composition", "description" : "Composition: Delete Existing", "status" : "pass", "message" : "Existing Composition was deleted.", "validates" : [ { "resource" : "Composition", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Composition", "description" : "Composition: Get Deleted Resource", "status" : "pass", "message" : "Deleted Composition was correctly reported as gone.", "validates" : [ { "resource" : "Composition", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:39:35.563-0400" }, "created_at" : { "$date" : "2015-10-02T18:39:35.563-0400" } }
,{ "_id" : { "$oid" : "560f07b44d4d3266f8af0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0464d4d3261a61a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ConceptMap", "description" : "ConceptMap: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ConceptMap", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ConceptMap", "description" : "ConceptMap: Create New", "status" : "pass", "message" : "New ConceptMap was created.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ConceptMap", "description" : "ConceptMap: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ConceptMap.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ConceptMap", "description" : "ConceptMap: Update Existing", "status" : "pass", "message" : "Updated existing ConceptMap.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ConceptMap", "description" : "ConceptMap: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ConceptMap", "description" : "ConceptMap: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ConceptMap.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ConceptMap", "description" : "ConceptMap: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ConceptMap.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ConceptMap", "description" : "ConceptMap: Validate", "status" : "pass", "message" : "ConceptMap was validated.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ConceptMap", "description" : "ConceptMap: Validate Existing", "status" : "pass", "message" : "Existing ConceptMap was validated.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ConceptMap", "description" : "ConceptMap: Validate against a profile", "status" : "pass", "message" : "ConceptMap was validated.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ConceptMap", "description" : "ConceptMap: Delete Existing", "status" : "pass", "message" : "Existing ConceptMap was deleted.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ConceptMap", "description" : "ConceptMap: Get Deleted Resource", "status" : "pass", "message" : "Deleted ConceptMap was correctly reported as gone.", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:39:48.195-0400" }, "created_at" : { "$date" : "2015-10-02T18:39:48.195-0400" } }
,{ "_id" : { "$oid" : "560f07bd4d4d3266f8b00200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0464d4d3261a61b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Condition", "description" : "Condition: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Condition", "description" : "Condition: Create New", "status" : "pass", "message" : "New Condition was created.", "validates" : [ { "resource" : "Condition", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Condition", "description" : "Condition: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Condition.", "validates" : [ { "resource" : "Condition", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Condition", "description" : "Condition: Update Existing", "status" : "pass", "message" : "Updated existing Condition.", "validates" : [ { "resource" : "Condition", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Condition", "description" : "Condition: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Condition", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Condition", "description" : "Condition: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Condition.", "validates" : [ { "resource" : "Condition", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Condition", "description" : "Condition: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Condition.", "validates" : [ { "resource" : "Condition", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Condition", "description" : "Condition: Validate", "status" : "pass", "message" : "Condition was validated.", "validates" : [ { "resource" : "Condition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Condition", "description" : "Condition: Validate Existing", "status" : "pass", "message" : "Existing Condition was validated.", "validates" : [ { "resource" : "Condition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Condition", "description" : "Condition: Validate against a profile", "status" : "pass", "message" : "Condition was validated.", "validates" : [ { "resource" : "Condition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Condition", "description" : "Condition: Delete Existing", "status" : "pass", "message" : "Existing Condition was deleted.", "validates" : [ { "resource" : "Condition", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Condition", "description" : "Condition: Get Deleted Resource", "status" : "pass", "message" : "Deleted Condition was correctly reported as gone.", "validates" : [ { "resource" : "Condition", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:39:57.680-0400" }, "created_at" : { "$date" : "2015-10-02T18:39:57.680-0400" } }
,{ "_id" : { "$oid" : "560f07c54d4d3266f8b10200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0474d4d3261a61c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Conformance", "description" : "Conformance: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Conformance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Conformance", "description" : "Conformance: Create New", "status" : "pass", "message" : "New Conformance was created.", "validates" : [ { "resource" : "Conformance", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Conformance", "description" : "Conformance: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Conformance.", "validates" : [ { "resource" : "Conformance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Conformance", "description" : "Conformance: Update Existing", "status" : "pass", "message" : "Updated existing Conformance.", "validates" : [ { "resource" : "Conformance", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Conformance", "description" : "Conformance: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Conformance", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Conformance", "description" : "Conformance: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Conformance.", "validates" : [ { "resource" : "Conformance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Conformance", "description" : "Conformance: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Conformance.", "validates" : [ { "resource" : "Conformance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Conformance", "description" : "Conformance: Validate", "status" : "pass", "message" : "Conformance was validated.", "validates" : [ { "resource" : "Conformance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Conformance", "description" : "Conformance: Validate Existing", "status" : "pass", "message" : "Existing Conformance was validated.", "validates" : [ { "resource" : "Conformance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Conformance", "description" : "Conformance: Validate against a profile", "status" : "pass", "message" : "Conformance was validated.", "validates" : [ { "resource" : "Conformance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Conformance", "description" : "Conformance: Delete Existing", "status" : "pass", "message" : "Existing Conformance was deleted.", "validates" : [ { "resource" : "Conformance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Conformance", "description" : "Conformance: Get Deleted Resource", "status" : "pass", "message" : "Deleted Conformance was correctly reported as gone.", "validates" : [ { "resource" : "Conformance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:40:05.021-0400" }, "created_at" : { "$date" : "2015-10-02T18:40:05.021-0400" } }
,{ "_id" : { "$oid" : "560f07cd4d4d3266f8b20200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0474d4d3261a61d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Contract", "description" : "Contract: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Contract", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Contract", "description" : "Contract: Create New", "status" : "pass", "message" : "New Contract was created.", "validates" : [ { "resource" : "Contract", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Contract", "description" : "Contract: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Contract.", "validates" : [ { "resource" : "Contract", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Contract", "description" : "Contract: Update Existing", "status" : "pass", "message" : "Updated existing Contract.", "validates" : [ { "resource" : "Contract", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Contract", "description" : "Contract: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Contract", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Contract", "description" : "Contract: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Contract.", "validates" : [ { "resource" : "Contract", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Contract", "description" : "Contract: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Contract.", "validates" : [ { "resource" : "Contract", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Contract", "description" : "Contract: Validate", "status" : "pass", "message" : "Contract was validated.", "validates" : [ { "resource" : "Contract", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Contract", "description" : "Contract: Validate Existing", "status" : "pass", "message" : "Existing Contract was validated.", "validates" : [ { "resource" : "Contract", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Contract", "description" : "Contract: Validate against a profile", "status" : "pass", "message" : "Contract was validated.", "validates" : [ { "resource" : "Contract", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Contract", "description" : "Contract: Delete Existing", "status" : "pass", "message" : "Existing Contract was deleted.", "validates" : [ { "resource" : "Contract", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Contract", "description" : "Contract: Get Deleted Resource", "status" : "pass", "message" : "Deleted Contract was correctly reported as gone.", "validates" : [ { "resource" : "Contract", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:40:13.403-0400" }, "created_at" : { "$date" : "2015-10-02T18:40:13.403-0400" } }
,{ "_id" : { "$oid" : "560f07d44d4d3266f8b30200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0474d4d3261a61e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Coverage", "description" : "Coverage: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Coverage", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Coverage", "description" : "Coverage: Create New", "status" : "pass", "message" : "New Coverage was created.", "validates" : [ { "resource" : "Coverage", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Coverage", "description" : "Coverage: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Coverage.", "validates" : [ { "resource" : "Coverage", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Coverage", "description" : "Coverage: Update Existing", "status" : "pass", "message" : "Updated existing Coverage.", "validates" : [ { "resource" : "Coverage", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Coverage", "description" : "Coverage: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Coverage", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Coverage", "description" : "Coverage: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Coverage.", "validates" : [ { "resource" : "Coverage", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Coverage", "description" : "Coverage: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Coverage.", "validates" : [ { "resource" : "Coverage", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Coverage", "description" : "Coverage: Validate", "status" : "pass", "message" : "Coverage was validated.", "validates" : [ { "resource" : "Coverage", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Coverage", "description" : "Coverage: Validate Existing", "status" : "pass", "message" : "Existing Coverage was validated.", "validates" : [ { "resource" : "Coverage", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Coverage", "description" : "Coverage: Validate against a profile", "status" : "pass", "message" : "Coverage was validated.", "validates" : [ { "resource" : "Coverage", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Coverage", "description" : "Coverage: Delete Existing", "status" : "pass", "message" : "Existing Coverage was deleted.", "validates" : [ { "resource" : "Coverage", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Coverage", "description" : "Coverage: Get Deleted Resource", "status" : "pass", "message" : "Deleted Coverage was correctly reported as gone.", "validates" : [ { "resource" : "Coverage", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:40:20.823-0400" }, "created_at" : { "$date" : "2015-10-02T18:40:20.823-0400" } }
,{ "_id" : { "$oid" : "560f07dd4d4d3266f8b40200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0474d4d3261a61f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DataElement", "description" : "DataElement: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DataElement", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DataElement", "description" : "DataElement: Create New", "status" : "pass", "message" : "New DataElement was created.", "validates" : [ { "resource" : "DataElement", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DataElement", "description" : "DataElement: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DataElement.", "validates" : [ { "resource" : "DataElement", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DataElement", "description" : "DataElement: Update Existing", "status" : "pass", "message" : "Updated existing DataElement.", "validates" : [ { "resource" : "DataElement", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DataElement", "description" : "DataElement: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DataElement", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DataElement", "description" : "DataElement: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DataElement.", "validates" : [ { "resource" : "DataElement", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DataElement", "description" : "DataElement: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DataElement.", "validates" : [ { "resource" : "DataElement", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DataElement", "description" : "DataElement: Validate", "status" : "pass", "message" : "DataElement was validated.", "validates" : [ { "resource" : "DataElement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DataElement", "description" : "DataElement: Validate Existing", "status" : "pass", "message" : "Existing DataElement was validated.", "validates" : [ { "resource" : "DataElement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DataElement", "description" : "DataElement: Validate against a profile", "status" : "pass", "message" : "DataElement was validated.", "validates" : [ { "resource" : "DataElement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DataElement", "description" : "DataElement: Delete Existing", "status" : "pass", "message" : "Existing DataElement was deleted.", "validates" : [ { "resource" : "DataElement", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DataElement", "description" : "DataElement: Get Deleted Resource", "status" : "pass", "message" : "Deleted DataElement was correctly reported as gone.", "validates" : [ { "resource" : "DataElement", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:40:29.699-0400" }, "created_at" : { "$date" : "2015-10-02T18:40:29.699-0400" } }
,{ "_id" : { "$oid" : "560f07e44d4d3266f8b50200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0474d4d3261a6200000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DetectedIssue", "description" : "DetectedIssue: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DetectedIssue", "description" : "DetectedIssue: Create New", "status" : "pass", "message" : "New DetectedIssue was created.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DetectedIssue", "description" : "DetectedIssue: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DetectedIssue.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DetectedIssue", "description" : "DetectedIssue: Update Existing", "status" : "pass", "message" : "Updated existing DetectedIssue.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DetectedIssue", "description" : "DetectedIssue: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DetectedIssue", "description" : "DetectedIssue: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DetectedIssue.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DetectedIssue", "description" : "DetectedIssue: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DetectedIssue.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DetectedIssue", "description" : "DetectedIssue: Validate", "status" : "pass", "message" : "DetectedIssue was validated.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DetectedIssue", "description" : "DetectedIssue: Validate Existing", "status" : "pass", "message" : "Existing DetectedIssue was validated.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DetectedIssue", "description" : "DetectedIssue: Validate against a profile", "status" : "pass", "message" : "DetectedIssue was validated.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DetectedIssue", "description" : "DetectedIssue: Delete Existing", "status" : "pass", "message" : "Existing DetectedIssue was deleted.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DetectedIssue", "description" : "DetectedIssue: Get Deleted Resource", "status" : "pass", "message" : "Deleted DetectedIssue was correctly reported as gone.", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:40:36.127-0400" }, "created_at" : { "$date" : "2015-10-02T18:40:36.127-0400" } }
,{ "_id" : { "$oid" : "560f07eb4d4d3266f8b60200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0474d4d3261a6210000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Device", "description" : "Device: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Device", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Device", "description" : "Device: Create New", "status" : "pass", "message" : "New Device was created.", "validates" : [ { "resource" : "Device", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Device", "description" : "Device: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Device.", "validates" : [ { "resource" : "Device", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Device", "description" : "Device: Update Existing", "status" : "pass", "message" : "Updated existing Device.", "validates" : [ { "resource" : "Device", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Device", "description" : "Device: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Device", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Device", "description" : "Device: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Device.", "validates" : [ { "resource" : "Device", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Device", "description" : "Device: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Device.", "validates" : [ { "resource" : "Device", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Device", "description" : "Device: Validate", "status" : "pass", "message" : "Device was validated.", "validates" : [ { "resource" : "Device", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Device", "description" : "Device: Validate Existing", "status" : "pass", "message" : "Existing Device was validated.", "validates" : [ { "resource" : "Device", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Device", "description" : "Device: Validate against a profile", "status" : "pass", "message" : "Device was validated.", "validates" : [ { "resource" : "Device", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Device", "description" : "Device: Delete Existing", "status" : "pass", "message" : "Existing Device was deleted.", "validates" : [ { "resource" : "Device", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Device", "description" : "Device: Get Deleted Resource", "status" : "pass", "message" : "Deleted Device was correctly reported as gone.", "validates" : [ { "resource" : "Device", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:40:43.619-0400" }, "created_at" : { "$date" : "2015-10-02T18:40:43.619-0400" } }
,{ "_id" : { "$oid" : "560f07f44d4d3266f8b70200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0474d4d3261a6220000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DeviceComponent", "description" : "DeviceComponent: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DeviceComponent", "description" : "DeviceComponent: Create New", "status" : "pass", "message" : "New DeviceComponent was created.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DeviceComponent", "description" : "DeviceComponent: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DeviceComponent.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DeviceComponent", "description" : "DeviceComponent: Update Existing", "status" : "pass", "message" : "Updated existing DeviceComponent.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DeviceComponent", "description" : "DeviceComponent: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DeviceComponent", "description" : "DeviceComponent: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DeviceComponent.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DeviceComponent", "description" : "DeviceComponent: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DeviceComponent.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DeviceComponent", "description" : "DeviceComponent: Validate", "status" : "pass", "message" : "DeviceComponent was validated.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DeviceComponent", "description" : "DeviceComponent: Validate Existing", "status" : "pass", "message" : "Existing DeviceComponent was validated.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DeviceComponent", "description" : "DeviceComponent: Validate against a profile", "status" : "pass", "message" : "DeviceComponent was validated.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DeviceComponent", "description" : "DeviceComponent: Delete Existing", "status" : "pass", "message" : "Existing DeviceComponent was deleted.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DeviceComponent", "description" : "DeviceComponent: Get Deleted Resource", "status" : "pass", "message" : "Deleted DeviceComponent was correctly reported as gone.", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:40:52.176-0400" }, "created_at" : { "$date" : "2015-10-02T18:40:52.176-0400" } }
,{ "_id" : { "$oid" : "560f07fc4d4d3266f8b80200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0474d4d3261a6230000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DeviceMetric", "description" : "DeviceMetric: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DeviceMetric", "description" : "DeviceMetric: Create New", "status" : "pass", "message" : "New DeviceMetric was created.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DeviceMetric", "description" : "DeviceMetric: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DeviceMetric.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DeviceMetric", "description" : "DeviceMetric: Update Existing", "status" : "pass", "message" : "Updated existing DeviceMetric.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DeviceMetric", "description" : "DeviceMetric: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DeviceMetric", "description" : "DeviceMetric: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DeviceMetric.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DeviceMetric", "description" : "DeviceMetric: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DeviceMetric.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DeviceMetric", "description" : "DeviceMetric: Validate", "status" : "pass", "message" : "DeviceMetric was validated.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DeviceMetric", "description" : "DeviceMetric: Validate Existing", "status" : "pass", "message" : "Existing DeviceMetric was validated.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DeviceMetric", "description" : "DeviceMetric: Validate against a profile", "status" : "pass", "message" : "DeviceMetric was validated.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DeviceMetric", "description" : "DeviceMetric: Delete Existing", "status" : "pass", "message" : "Existing DeviceMetric was deleted.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DeviceMetric", "description" : "DeviceMetric: Get Deleted Resource", "status" : "pass", "message" : "Deleted DeviceMetric was correctly reported as gone.", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:41:00.021-0400" }, "created_at" : { "$date" : "2015-10-02T18:41:00.021-0400" } }
,{ "_id" : { "$oid" : "560f08044d4d3266f8b90200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0484d4d3261a6240000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DeviceUseRequest", "description" : "DeviceUseRequest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DeviceUseRequest", "description" : "DeviceUseRequest: Create New", "status" : "pass", "message" : "New DeviceUseRequest was created.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DeviceUseRequest", "description" : "DeviceUseRequest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DeviceUseRequest.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DeviceUseRequest", "description" : "DeviceUseRequest: Update Existing", "status" : "pass", "message" : "Updated existing DeviceUseRequest.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DeviceUseRequest", "description" : "DeviceUseRequest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DeviceUseRequest", "description" : "DeviceUseRequest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DeviceUseRequest.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DeviceUseRequest", "description" : "DeviceUseRequest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DeviceUseRequest.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DeviceUseRequest", "description" : "DeviceUseRequest: Validate", "status" : "pass", "message" : "DeviceUseRequest was validated.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DeviceUseRequest", "description" : "DeviceUseRequest: Validate Existing", "status" : "pass", "message" : "Existing DeviceUseRequest was validated.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DeviceUseRequest", "description" : "DeviceUseRequest: Validate against a profile", "status" : "pass", "message" : "DeviceUseRequest was validated.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DeviceUseRequest", "description" : "DeviceUseRequest: Delete Existing", "status" : "pass", "message" : "Existing DeviceUseRequest was deleted.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DeviceUseRequest", "description" : "DeviceUseRequest: Get Deleted Resource", "status" : "pass", "message" : "Deleted DeviceUseRequest was correctly reported as gone.", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:41:08.683-0400" }, "created_at" : { "$date" : "2015-10-02T18:41:08.683-0400" } }
,{ "_id" : { "$oid" : "560f080c4d4d3266f8ba0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0484d4d3261a6250000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DeviceUseStatement", "description" : "DeviceUseStatement: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DeviceUseStatement", "description" : "DeviceUseStatement: Create New", "status" : "pass", "message" : "New DeviceUseStatement was created.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DeviceUseStatement", "description" : "DeviceUseStatement: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DeviceUseStatement.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DeviceUseStatement", "description" : "DeviceUseStatement: Update Existing", "status" : "pass", "message" : "Updated existing DeviceUseStatement.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DeviceUseStatement", "description" : "DeviceUseStatement: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DeviceUseStatement", "description" : "DeviceUseStatement: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DeviceUseStatement.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DeviceUseStatement", "description" : "DeviceUseStatement: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DeviceUseStatement.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DeviceUseStatement", "description" : "DeviceUseStatement: Validate", "status" : "pass", "message" : "DeviceUseStatement was validated.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DeviceUseStatement", "description" : "DeviceUseStatement: Validate Existing", "status" : "pass", "message" : "Existing DeviceUseStatement was validated.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DeviceUseStatement", "description" : "DeviceUseStatement: Validate against a profile", "status" : "pass", "message" : "DeviceUseStatement was validated.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DeviceUseStatement", "description" : "DeviceUseStatement: Delete Existing", "status" : "pass", "message" : "Existing DeviceUseStatement was deleted.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DeviceUseStatement", "description" : "DeviceUseStatement: Get Deleted Resource", "status" : "pass", "message" : "Deleted DeviceUseStatement was correctly reported as gone.", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:41:16.938-0400" }, "created_at" : { "$date" : "2015-10-02T18:41:16.938-0400" } }
,{ "_id" : { "$oid" : "560f08144d4d3266f8bb0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0484d4d3261a6260000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DiagnosticOrder", "description" : "DiagnosticOrder: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DiagnosticOrder", "description" : "DiagnosticOrder: Create New", "status" : "pass", "message" : "New DiagnosticOrder was created.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DiagnosticOrder", "description" : "DiagnosticOrder: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DiagnosticOrder.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DiagnosticOrder", "description" : "DiagnosticOrder: Update Existing", "status" : "pass", "message" : "Updated existing DiagnosticOrder.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DiagnosticOrder", "description" : "DiagnosticOrder: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DiagnosticOrder", "description" : "DiagnosticOrder: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DiagnosticOrder.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DiagnosticOrder", "description" : "DiagnosticOrder: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DiagnosticOrder.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DiagnosticOrder", "description" : "DiagnosticOrder: Validate", "status" : "pass", "message" : "DiagnosticOrder was validated.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DiagnosticOrder", "description" : "DiagnosticOrder: Validate Existing", "status" : "pass", "message" : "Existing DiagnosticOrder was validated.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DiagnosticOrder", "description" : "DiagnosticOrder: Validate against a profile", "status" : "pass", "message" : "DiagnosticOrder was validated.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DiagnosticOrder", "description" : "DiagnosticOrder: Delete Existing", "status" : "pass", "message" : "Existing DiagnosticOrder was deleted.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DiagnosticOrder", "description" : "DiagnosticOrder: Get Deleted Resource", "status" : "pass", "message" : "Deleted DiagnosticOrder was correctly reported as gone.", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:41:24.969-0400" }, "created_at" : { "$date" : "2015-10-02T18:41:24.969-0400" } }
,{ "_id" : { "$oid" : "560f081e4d4d3266f8bc0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0484d4d3261a6270000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DiagnosticReport", "description" : "DiagnosticReport: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DiagnosticReport", "description" : "DiagnosticReport: Create New", "status" : "pass", "message" : "New DiagnosticReport was created.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DiagnosticReport", "description" : "DiagnosticReport: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DiagnosticReport.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DiagnosticReport", "description" : "DiagnosticReport: Update Existing", "status" : "pass", "message" : "Updated existing DiagnosticReport.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DiagnosticReport", "description" : "DiagnosticReport: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DiagnosticReport", "description" : "DiagnosticReport: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DiagnosticReport.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DiagnosticReport", "description" : "DiagnosticReport: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DiagnosticReport.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DiagnosticReport", "description" : "DiagnosticReport: Validate", "status" : "pass", "message" : "DiagnosticReport was validated.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DiagnosticReport", "description" : "DiagnosticReport: Validate Existing", "status" : "pass", "message" : "Existing DiagnosticReport was validated.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DiagnosticReport", "description" : "DiagnosticReport: Validate against a profile", "status" : "pass", "message" : "DiagnosticReport was validated.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DiagnosticReport", "description" : "DiagnosticReport: Delete Existing", "status" : "pass", "message" : "Existing DiagnosticReport was deleted.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DiagnosticReport", "description" : "DiagnosticReport: Get Deleted Resource", "status" : "pass", "message" : "Deleted DiagnosticReport was correctly reported as gone.", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:41:34.282-0400" }, "created_at" : { "$date" : "2015-10-02T18:41:34.282-0400" } }
,{ "_id" : { "$oid" : "560f08254d4d3266f8bd0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0484d4d3261a6280000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DocumentManifest", "description" : "DocumentManifest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DocumentManifest", "description" : "DocumentManifest: Create New", "status" : "pass", "message" : "New DocumentManifest was created.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DocumentManifest", "description" : "DocumentManifest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DocumentManifest.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DocumentManifest", "description" : "DocumentManifest: Update Existing", "status" : "pass", "message" : "Updated existing DocumentManifest.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DocumentManifest", "description" : "DocumentManifest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DocumentManifest", "description" : "DocumentManifest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DocumentManifest.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DocumentManifest", "description" : "DocumentManifest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DocumentManifest.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DocumentManifest", "description" : "DocumentManifest: Validate", "status" : "pass", "message" : "DocumentManifest was validated.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DocumentManifest", "description" : "DocumentManifest: Validate Existing", "status" : "pass", "message" : "Existing DocumentManifest was validated.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DocumentManifest", "description" : "DocumentManifest: Validate against a profile", "status" : "pass", "message" : "DocumentManifest was validated.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DocumentManifest", "description" : "DocumentManifest: Delete Existing", "status" : "pass", "message" : "Existing DocumentManifest was deleted.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DocumentManifest", "description" : "DocumentManifest: Get Deleted Resource", "status" : "pass", "message" : "Deleted DocumentManifest was correctly reported as gone.", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:41:41.459-0400" }, "created_at" : { "$date" : "2015-10-02T18:41:41.459-0400" } }
,{ "_id" : { "$oid" : "560f082f4d4d3266f8be0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0484d4d3261a6290000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_DocumentReference", "description" : "DocumentReference: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DocumentReference", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_DocumentReference", "description" : "DocumentReference: Create New", "status" : "pass", "message" : "New DocumentReference was created.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_DocumentReference", "description" : "DocumentReference: Read Existing", "status" : "pass", "message" : "Successfully read preexisting DocumentReference.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_DocumentReference", "description" : "DocumentReference: Update Existing", "status" : "pass", "message" : "Updated existing DocumentReference.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_DocumentReference", "description" : "DocumentReference: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_DocumentReference", "description" : "DocumentReference: Version read existing", "status" : "pass", "message" : "Read current version of preexisting DocumentReference.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_DocumentReference", "description" : "DocumentReference: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting DocumentReference.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_DocumentReference", "description" : "DocumentReference: Validate", "status" : "pass", "message" : "DocumentReference was validated.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_DocumentReference", "description" : "DocumentReference: Validate Existing", "status" : "pass", "message" : "Existing DocumentReference was validated.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_DocumentReference", "description" : "DocumentReference: Validate against a profile", "status" : "pass", "message" : "DocumentReference was validated.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_DocumentReference", "description" : "DocumentReference: Delete Existing", "status" : "pass", "message" : "Existing DocumentReference was deleted.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_DocumentReference", "description" : "DocumentReference: Get Deleted Resource", "status" : "pass", "message" : "Deleted DocumentReference was correctly reported as gone.", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:41:51.028-0400" }, "created_at" : { "$date" : "2015-10-02T18:41:51.028-0400" } }
,{ "_id" : { "$oid" : "560f08374d4d3266f8bf0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0484d4d3261a62a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_EligibilityRequest", "description" : "EligibilityRequest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_EligibilityRequest", "description" : "EligibilityRequest: Create New", "status" : "pass", "message" : "New EligibilityRequest was created.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_EligibilityRequest", "description" : "EligibilityRequest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting EligibilityRequest.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_EligibilityRequest", "description" : "EligibilityRequest: Update Existing", "status" : "pass", "message" : "Updated existing EligibilityRequest.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_EligibilityRequest", "description" : "EligibilityRequest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_EligibilityRequest", "description" : "EligibilityRequest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting EligibilityRequest.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_EligibilityRequest", "description" : "EligibilityRequest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting EligibilityRequest.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_EligibilityRequest", "description" : "EligibilityRequest: Validate", "status" : "pass", "message" : "EligibilityRequest was validated.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_EligibilityRequest", "description" : "EligibilityRequest: Validate Existing", "status" : "pass", "message" : "Existing EligibilityRequest was validated.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_EligibilityRequest", "description" : "EligibilityRequest: Validate against a profile", "status" : "pass", "message" : "EligibilityRequest was validated.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_EligibilityRequest", "description" : "EligibilityRequest: Delete Existing", "status" : "pass", "message" : "Existing EligibilityRequest was deleted.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_EligibilityRequest", "description" : "EligibilityRequest: Get Deleted Resource", "status" : "pass", "message" : "Deleted EligibilityRequest was correctly reported as gone.", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:41:59.822-0400" }, "created_at" : { "$date" : "2015-10-02T18:41:59.822-0400" } }
,{ "_id" : { "$oid" : "560f083f4d4d3266f8c00200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0494d4d3261a62b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_EligibilityResponse", "description" : "EligibilityResponse: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_EligibilityResponse", "description" : "EligibilityResponse: Create New", "status" : "pass", "message" : "New EligibilityResponse was created.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_EligibilityResponse", "description" : "EligibilityResponse: Read Existing", "status" : "pass", "message" : "Successfully read preexisting EligibilityResponse.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_EligibilityResponse", "description" : "EligibilityResponse: Update Existing", "status" : "pass", "message" : "Updated existing EligibilityResponse.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_EligibilityResponse", "description" : "EligibilityResponse: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_EligibilityResponse", "description" : "EligibilityResponse: Version read existing", "status" : "pass", "message" : "Read current version of preexisting EligibilityResponse.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_EligibilityResponse", "description" : "EligibilityResponse: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting EligibilityResponse.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_EligibilityResponse", "description" : "EligibilityResponse: Validate", "status" : "pass", "message" : "EligibilityResponse was validated.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_EligibilityResponse", "description" : "EligibilityResponse: Validate Existing", "status" : "pass", "message" : "Existing EligibilityResponse was validated.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_EligibilityResponse", "description" : "EligibilityResponse: Validate against a profile", "status" : "pass", "message" : "EligibilityResponse was validated.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_EligibilityResponse", "description" : "EligibilityResponse: Delete Existing", "status" : "pass", "message" : "Existing EligibilityResponse was deleted.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_EligibilityResponse", "description" : "EligibilityResponse: Get Deleted Resource", "status" : "pass", "message" : "Deleted EligibilityResponse was correctly reported as gone.", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:42:07.595-0400" }, "created_at" : { "$date" : "2015-10-02T18:42:07.595-0400" } }
,{ "_id" : { "$oid" : "560f08474d4d3266f8c10200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0494d4d3261a62c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Encounter", "description" : "Encounter: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Encounter", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Encounter", "description" : "Encounter: Create New", "status" : "pass", "message" : "New Encounter was created.", "validates" : [ { "resource" : "Encounter", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Encounter", "description" : "Encounter: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Encounter.", "validates" : [ { "resource" : "Encounter", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Encounter", "description" : "Encounter: Update Existing", "status" : "pass", "message" : "Updated existing Encounter.", "validates" : [ { "resource" : "Encounter", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Encounter", "description" : "Encounter: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Encounter", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Encounter", "description" : "Encounter: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Encounter.", "validates" : [ { "resource" : "Encounter", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Encounter", "description" : "Encounter: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Encounter.", "validates" : [ { "resource" : "Encounter", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Encounter", "description" : "Encounter: Validate", "status" : "pass", "message" : "Encounter was validated.", "validates" : [ { "resource" : "Encounter", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Encounter", "description" : "Encounter: Validate Existing", "status" : "pass", "message" : "Existing Encounter was validated.", "validates" : [ { "resource" : "Encounter", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Encounter", "description" : "Encounter: Validate against a profile", "status" : "pass", "message" : "Encounter was validated.", "validates" : [ { "resource" : "Encounter", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Encounter", "description" : "Encounter: Delete Existing", "status" : "pass", "message" : "Existing Encounter was deleted.", "validates" : [ { "resource" : "Encounter", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Encounter", "description" : "Encounter: Get Deleted Resource", "status" : "pass", "message" : "Deleted Encounter was correctly reported as gone.", "validates" : [ { "resource" : "Encounter", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:42:15.939-0400" }, "created_at" : { "$date" : "2015-10-02T18:42:15.939-0400" } }
,{ "_id" : { "$oid" : "560f084f4d4d3266f8c20200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0494d4d3261a62d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_EnrollmentRequest", "description" : "EnrollmentRequest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_EnrollmentRequest", "description" : "EnrollmentRequest: Create New", "status" : "pass", "message" : "New EnrollmentRequest was created.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_EnrollmentRequest", "description" : "EnrollmentRequest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting EnrollmentRequest.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_EnrollmentRequest", "description" : "EnrollmentRequest: Update Existing", "status" : "pass", "message" : "Updated existing EnrollmentRequest.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_EnrollmentRequest", "description" : "EnrollmentRequest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_EnrollmentRequest", "description" : "EnrollmentRequest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting EnrollmentRequest.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_EnrollmentRequest", "description" : "EnrollmentRequest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting EnrollmentRequest.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_EnrollmentRequest", "description" : "EnrollmentRequest: Validate", "status" : "pass", "message" : "EnrollmentRequest was validated.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_EnrollmentRequest", "description" : "EnrollmentRequest: Validate Existing", "status" : "pass", "message" : "Existing EnrollmentRequest was validated.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_EnrollmentRequest", "description" : "EnrollmentRequest: Validate against a profile", "status" : "pass", "message" : "EnrollmentRequest was validated.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_EnrollmentRequest", "description" : "EnrollmentRequest: Delete Existing", "status" : "pass", "message" : "Existing EnrollmentRequest was deleted.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_EnrollmentRequest", "description" : "EnrollmentRequest: Get Deleted Resource", "status" : "pass", "message" : "Deleted EnrollmentRequest was correctly reported as gone.", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:42:23.157-0400" }, "created_at" : { "$date" : "2015-10-02T18:42:23.157-0400" } }
,{ "_id" : { "$oid" : "560f08564d4d3266f8c30200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0494d4d3261a62e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_EnrollmentResponse", "description" : "EnrollmentResponse: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_EnrollmentResponse", "description" : "EnrollmentResponse: Create New", "status" : "pass", "message" : "New EnrollmentResponse was created.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_EnrollmentResponse", "description" : "EnrollmentResponse: Read Existing", "status" : "pass", "message" : "Successfully read preexisting EnrollmentResponse.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_EnrollmentResponse", "description" : "EnrollmentResponse: Update Existing", "status" : "pass", "message" : "Updated existing EnrollmentResponse.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_EnrollmentResponse", "description" : "EnrollmentResponse: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_EnrollmentResponse", "description" : "EnrollmentResponse: Version read existing", "status" : "pass", "message" : "Read current version of preexisting EnrollmentResponse.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_EnrollmentResponse", "description" : "EnrollmentResponse: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting EnrollmentResponse.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_EnrollmentResponse", "description" : "EnrollmentResponse: Validate", "status" : "pass", "message" : "EnrollmentResponse was validated.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_EnrollmentResponse", "description" : "EnrollmentResponse: Validate Existing", "status" : "pass", "message" : "Existing EnrollmentResponse was validated.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_EnrollmentResponse", "description" : "EnrollmentResponse: Validate against a profile", "status" : "pass", "message" : "EnrollmentResponse was validated.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_EnrollmentResponse", "description" : "EnrollmentResponse: Delete Existing", "status" : "pass", "message" : "Existing EnrollmentResponse was deleted.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_EnrollmentResponse", "description" : "EnrollmentResponse: Get Deleted Resource", "status" : "pass", "message" : "Deleted EnrollmentResponse was correctly reported as gone.", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:42:30.437-0400" }, "created_at" : { "$date" : "2015-10-02T18:42:30.437-0400" } }
,{ "_id" : { "$oid" : "560f085d4d4d3266f8c40200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0494d4d3261a62f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_EpisodeOfCare", "description" : "EpisodeOfCare: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_EpisodeOfCare", "description" : "EpisodeOfCare: Create New", "status" : "pass", "message" : "New EpisodeOfCare was created.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_EpisodeOfCare", "description" : "EpisodeOfCare: Read Existing", "status" : "pass", "message" : "Successfully read preexisting EpisodeOfCare.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_EpisodeOfCare", "description" : "EpisodeOfCare: Update Existing", "status" : "pass", "message" : "Updated existing EpisodeOfCare.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_EpisodeOfCare", "description" : "EpisodeOfCare: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_EpisodeOfCare", "description" : "EpisodeOfCare: Version read existing", "status" : "pass", "message" : "Read current version of preexisting EpisodeOfCare.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_EpisodeOfCare", "description" : "EpisodeOfCare: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting EpisodeOfCare.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_EpisodeOfCare", "description" : "EpisodeOfCare: Validate", "status" : "pass", "message" : "EpisodeOfCare was validated.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_EpisodeOfCare", "description" : "EpisodeOfCare: Validate Existing", "status" : "pass", "message" : "Existing EpisodeOfCare was validated.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_EpisodeOfCare", "description" : "EpisodeOfCare: Validate against a profile", "status" : "pass", "message" : "EpisodeOfCare was validated.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_EpisodeOfCare", "description" : "EpisodeOfCare: Delete Existing", "status" : "pass", "message" : "Existing EpisodeOfCare was deleted.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_EpisodeOfCare", "description" : "EpisodeOfCare: Get Deleted Resource", "status" : "pass", "message" : "Deleted EpisodeOfCare was correctly reported as gone.", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:42:37.467-0400" }, "created_at" : { "$date" : "2015-10-02T18:42:37.467-0400" } }
,{ "_id" : { "$oid" : "560f08644d4d3266f8c50200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0494d4d3261a6300000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Create New", "status" : "pass", "message" : "New ExplanationOfBenefit was created.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ExplanationOfBenefit.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Update Existing", "status" : "pass", "message" : "Updated existing ExplanationOfBenefit.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ExplanationOfBenefit.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ExplanationOfBenefit.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Validate", "status" : "pass", "message" : "ExplanationOfBenefit was validated.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Validate Existing", "status" : "pass", "message" : "Existing ExplanationOfBenefit was validated.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Validate against a profile", "status" : "pass", "message" : "ExplanationOfBenefit was validated.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Delete Existing", "status" : "pass", "message" : "Existing ExplanationOfBenefit was deleted.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ExplanationOfBenefit", "description" : "ExplanationOfBenefit: Get Deleted Resource", "status" : "pass", "message" : "Deleted ExplanationOfBenefit was correctly reported as gone.", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:42:44.162-0400" }, "created_at" : { "$date" : "2015-10-02T18:42:44.162-0400" } }
,{ "_id" : { "$oid" : "560f086b4d4d3266f8c60200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0494d4d3261a6310000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_FamilyMemberHistory", "description" : "FamilyMemberHistory: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_FamilyMemberHistory", "description" : "FamilyMemberHistory: Create New", "status" : "pass", "message" : "New FamilyMemberHistory was created.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_FamilyMemberHistory", "description" : "FamilyMemberHistory: Read Existing", "status" : "pass", "message" : "Successfully read preexisting FamilyMemberHistory.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_FamilyMemberHistory", "description" : "FamilyMemberHistory: Update Existing", "status" : "pass", "message" : "Updated existing FamilyMemberHistory.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_FamilyMemberHistory", "description" : "FamilyMemberHistory: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_FamilyMemberHistory", "description" : "FamilyMemberHistory: Version read existing", "status" : "pass", "message" : "Read current version of preexisting FamilyMemberHistory.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_FamilyMemberHistory", "description" : "FamilyMemberHistory: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting FamilyMemberHistory.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_FamilyMemberHistory", "description" : "FamilyMemberHistory: Validate", "status" : "pass", "message" : "FamilyMemberHistory was validated.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_FamilyMemberHistory", "description" : "FamilyMemberHistory: Validate Existing", "status" : "pass", "message" : "Existing FamilyMemberHistory was validated.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_FamilyMemberHistory", "description" : "FamilyMemberHistory: Validate against a profile", "status" : "pass", "message" : "FamilyMemberHistory was validated.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_FamilyMemberHistory", "description" : "FamilyMemberHistory: Delete Existing", "status" : "pass", "message" : "Existing FamilyMemberHistory was deleted.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_FamilyMemberHistory", "description" : "FamilyMemberHistory: Get Deleted Resource", "status" : "pass", "message" : "Deleted FamilyMemberHistory was correctly reported as gone.", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:42:51.625-0400" }, "created_at" : { "$date" : "2015-10-02T18:42:51.625-0400" } }
,{ "_id" : { "$oid" : "560f08734d4d3266f8c70200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04a4d4d3261a6320000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Flag", "description" : "Flag: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Flag", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Flag", "description" : "Flag: Create New", "status" : "pass", "message" : "New Flag was created.", "validates" : [ { "resource" : "Flag", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Flag", "description" : "Flag: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Flag.", "validates" : [ { "resource" : "Flag", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Flag", "description" : "Flag: Update Existing", "status" : "pass", "message" : "Updated existing Flag.", "validates" : [ { "resource" : "Flag", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Flag", "description" : "Flag: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Flag", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Flag", "description" : "Flag: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Flag.", "validates" : [ { "resource" : "Flag", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Flag", "description" : "Flag: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Flag.", "validates" : [ { "resource" : "Flag", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Flag", "description" : "Flag: Validate", "status" : "pass", "message" : "Flag was validated.", "validates" : [ { "resource" : "Flag", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Flag", "description" : "Flag: Validate Existing", "status" : "pass", "message" : "Existing Flag was validated.", "validates" : [ { "resource" : "Flag", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Flag", "description" : "Flag: Validate against a profile", "status" : "pass", "message" : "Flag was validated.", "validates" : [ { "resource" : "Flag", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Flag", "description" : "Flag: Delete Existing", "status" : "pass", "message" : "Existing Flag was deleted.", "validates" : [ { "resource" : "Flag", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Flag", "description" : "Flag: Get Deleted Resource", "status" : "pass", "message" : "Deleted Flag was correctly reported as gone.", "validates" : [ { "resource" : "Flag", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:42:59.243-0400" }, "created_at" : { "$date" : "2015-10-02T18:42:59.243-0400" } }
,{ "_id" : { "$oid" : "560f087a4d4d3266f8c80200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04a4d4d3261a6330000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Goal", "description" : "Goal: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Goal", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Goal", "description" : "Goal: Create New", "status" : "pass", "message" : "New Goal was created.", "validates" : [ { "resource" : "Goal", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Goal", "description" : "Goal: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Goal.", "validates" : [ { "resource" : "Goal", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Goal", "description" : "Goal: Update Existing", "status" : "pass", "message" : "Updated existing Goal.", "validates" : [ { "resource" : "Goal", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Goal", "description" : "Goal: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Goal", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Goal", "description" : "Goal: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Goal.", "validates" : [ { "resource" : "Goal", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Goal", "description" : "Goal: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Goal.", "validates" : [ { "resource" : "Goal", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Goal", "description" : "Goal: Validate", "status" : "pass", "message" : "Goal was validated.", "validates" : [ { "resource" : "Goal", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Goal", "description" : "Goal: Validate Existing", "status" : "pass", "message" : "Existing Goal was validated.", "validates" : [ { "resource" : "Goal", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Goal", "description" : "Goal: Validate against a profile", "status" : "pass", "message" : "Goal was validated.", "validates" : [ { "resource" : "Goal", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Goal", "description" : "Goal: Delete Existing", "status" : "pass", "message" : "Existing Goal was deleted.", "validates" : [ { "resource" : "Goal", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Goal", "description" : "Goal: Get Deleted Resource", "status" : "pass", "message" : "Deleted Goal was correctly reported as gone.", "validates" : [ { "resource" : "Goal", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:43:06.889-0400" }, "created_at" : { "$date" : "2015-10-02T18:43:06.889-0400" } }
,{ "_id" : { "$oid" : "560f08834d4d3266f8c90200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04a4d4d3261a6340000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Group", "description" : "Group: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Group", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Group", "description" : "Group: Create New", "status" : "pass", "message" : "New Group was created.", "validates" : [ { "resource" : "Group", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Group", "description" : "Group: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Group.", "validates" : [ { "resource" : "Group", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Group", "description" : "Group: Update Existing", "status" : "pass", "message" : "Updated existing Group.", "validates" : [ { "resource" : "Group", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Group", "description" : "Group: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Group", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Group", "description" : "Group: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Group.", "validates" : [ { "resource" : "Group", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Group", "description" : "Group: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Group.", "validates" : [ { "resource" : "Group", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Group", "description" : "Group: Validate", "status" : "pass", "message" : "Group was validated.", "validates" : [ { "resource" : "Group", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Group", "description" : "Group: Validate Existing", "status" : "pass", "message" : "Existing Group was validated.", "validates" : [ { "resource" : "Group", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Group", "description" : "Group: Validate against a profile", "status" : "pass", "message" : "Group was validated.", "validates" : [ { "resource" : "Group", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Group", "description" : "Group: Delete Existing", "status" : "pass", "message" : "Existing Group was deleted.", "validates" : [ { "resource" : "Group", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Group", "description" : "Group: Get Deleted Resource", "status" : "pass", "message" : "Deleted Group was correctly reported as gone.", "validates" : [ { "resource" : "Group", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:43:15.214-0400" }, "created_at" : { "$date" : "2015-10-02T18:43:15.214-0400" } }
,{ "_id" : { "$oid" : "560f088d4d4d3266f8ca0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04a4d4d3261a6350000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_HealthcareService", "description" : "HealthcareService: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "HealthcareService", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_HealthcareService", "description" : "HealthcareService: Create New", "status" : "pass", "message" : "New HealthcareService was created.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_HealthcareService", "description" : "HealthcareService: Read Existing", "status" : "pass", "message" : "Successfully read preexisting HealthcareService.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_HealthcareService", "description" : "HealthcareService: Update Existing", "status" : "pass", "message" : "Updated existing HealthcareService.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_HealthcareService", "description" : "HealthcareService: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_HealthcareService", "description" : "HealthcareService: Version read existing", "status" : "pass", "message" : "Read current version of preexisting HealthcareService.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_HealthcareService", "description" : "HealthcareService: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting HealthcareService.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_HealthcareService", "description" : "HealthcareService: Validate", "status" : "pass", "message" : "HealthcareService was validated.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_HealthcareService", "description" : "HealthcareService: Validate Existing", "status" : "pass", "message" : "Existing HealthcareService was validated.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_HealthcareService", "description" : "HealthcareService: Validate against a profile", "status" : "pass", "message" : "HealthcareService was validated.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_HealthcareService", "description" : "HealthcareService: Delete Existing", "status" : "pass", "message" : "Existing HealthcareService was deleted.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_HealthcareService", "description" : "HealthcareService: Get Deleted Resource", "status" : "pass", "message" : "Deleted HealthcareService was correctly reported as gone.", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:43:25.625-0400" }, "created_at" : { "$date" : "2015-10-02T18:43:25.625-0400" } }
,{ "_id" : { "$oid" : "560f08954d4d3266f8cb0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04a4d4d3261a6360000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ImagingObjectSelection", "description" : "ImagingObjectSelection: Read Type", "status" : "fail", "message" : "Expected FHIR Bundle but found: OperationOutcome", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'identifier'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ImagingObjectSelection", "description" : "ImagingObjectSelection: Create New", "status" : "fail", "message" : [ "error: : EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.", "information: :    at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\r\n   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<>c__DisplayClass7.<GetResults>b__6()\r\n   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<>c__DisplayClass7.<GetResults>b__5()\r\n   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<System.Collections.Generic.IEnumerable<T>.GetEnumerator>b__0()\r\n   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()\r\n   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.<GetElementFunction>b__1[TResult](IEnumerable`1 sequence)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.ExecuteSingle[TResult](IEnumerable`1 query, Expression queryRoot)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.System.Linq.IQueryProvider.Execute[TResult](Expression expression)\r\n   at System.Data.Entity.Internal.Linq.DbQueryProvider.Execute[TResult](Expression expression)\r\n   at System.Linq.Queryable.FirstOrDefault[TSource](IQueryable`1 source)\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1888\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806\r\n   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672\r\n   at lambda_method(Closure , Object , Object[] )\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.<>c__DisplayClass10.<GetExecutor>b__9(Object instance, Object[] methodParameters)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.<InvokeActionAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.<ExecuteAsync>d__2.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ExceptionFilterResult.<ExecuteAsync>d__0.MoveNext()", "error: : SqlException: Invalid column name 'identifier'.", "information: :    at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\r\n   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\r\n   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)\r\n   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean& dataReady)\r\n   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()\r\n   at System.Data.SqlClient.SqlDataReader.get_MetaData()\r\n   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task& task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task& task, Boolean asyncWrite)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)\r\n   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)\r\n   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)\r\n   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)\r\n   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.<Reader>b__c(DbCommand t, DbCommandInterceptionContext`1 c)\r\n   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)\r\n   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)\r\n   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)\r\n   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)\r\n   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)" ], "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.&lt;GetElementFunction&gt;b__1[TResult](IEnumerable`1 sequence)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.ExecuteSingle[TResult](IEnumerable`1 query, Expression queryRoot)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.System.Linq.IQueryProvider.Execute[TResult](Expression expression)&#xD;&#xA;   at System.Data.Entity.Internal.Linq.DbQueryProvider.Execute[TResult](Expression expression)&#xD;&#xA;   at System.Linq.Queryable.FirstOrDefault[TSource](IQueryable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1888&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'identifier'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ImagingObjectSelection", "description" : "ImagingObjectSelection: Read Existing", "status" : "fail", "message" : "Preexisting ImagingObjectSelection unknown.", "data" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ImagingObjectSelection", "description" : "ImagingObjectSelection: Update Existing", "status" : "skip", "message" : "Unable to update -- existing ImagingObjectSelection is not available or was not valid.", "data" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ImagingObjectSelection", "description" : "ImagingObjectSelection: Read History of existing", "status" : "skip", "message" : "Preexisting ImagingObjectSelection unknown.", "data" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ImagingObjectSelection", "description" : "ImagingObjectSelection: Version read existing", "status" : "skip", "message" : "Preexisting ImagingObjectSelection unknown.", "data" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ImagingObjectSelection", "description" : "ImagingObjectSelection: Previous version read existing", "status" : "skip", "message" : "Previous version of ImagingObjectSelection unavailable.", "data" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ImagingObjectSelection", "description" : "ImagingObjectSelection: Validate", "status" : "pass", "message" : "ImagingObjectSelection was validated.", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ImagingObjectSelection", "description" : "ImagingObjectSelection: Validate Existing", "status" : "pass", "message" : "Existing ImagingObjectSelection was validated.", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ImagingObjectSelection", "description" : "ImagingObjectSelection: Validate against a profile", "status" : "pass", "message" : "ImagingObjectSelection was validated.", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ImagingObjectSelection", "description" : "ImagingObjectSelection: Delete Existing", "status" : "skip", "message" : "Preexisting ImagingObjectSelection unknown.", "data" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ImagingObjectSelection", "description" : "ImagingObjectSelection: Get Deleted Resource", "status" : "skip", "message" : "Skipped: x075_get_deleted_resource_test", "data" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:43:33.742-0400" }, "created_at" : { "$date" : "2015-10-02T18:43:33.742-0400" } }
,{ "_id" : { "$oid" : "560f089c4d4d3266f8cc0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04a4d4d3261a6370000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ImagingStudy", "description" : "ImagingStudy: Read Type", "status" : "fail", "message" : "Expected FHIR Bundle but found: OperationOutcome", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'study'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ImagingStudy", "description" : "ImagingStudy: Create New", "status" : "fail", "message" : [ "error: : EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.", "information: :    at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\r\n   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<>c__DisplayClass7.<GetResults>b__6()\r\n   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<>c__DisplayClass7.<GetResults>b__5()\r\n   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)\r\n   at System.Data.Entity.Core.Objects.ObjectQuery`1.<System.Collections.Generic.IEnumerable<T>.GetEnumerator>b__0()\r\n   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()\r\n   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.<GetElementFunction>b__1[TResult](IEnumerable`1 sequence)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.ExecuteSingle[TResult](IEnumerable`1 query, Expression queryRoot)\r\n   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.System.Linq.IQueryProvider.Execute[TResult](Expression expression)\r\n   at System.Data.Entity.Internal.Linq.DbQueryProvider.Execute[TResult](Expression expression)\r\n   at System.Linq.Queryable.FirstOrDefault[TSource](IQueryable`1 source)\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1888\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806\r\n   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672\r\n   at lambda_method(Closure , Object , Object[] )\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.<>c__DisplayClass10.<GetExecutor>b__9(Object instance, Object[] methodParameters)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.<InvokeActionAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.<ExecuteAsync>d__2.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ExceptionFilterResult.<ExecuteAsync>d__0.MoveNext()", "error: : SqlException: Invalid column name 'study'.", "information: :    at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\r\n   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\r\n   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)\r\n   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean& dataReady)\r\n   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()\r\n   at System.Data.SqlClient.SqlDataReader.get_MetaData()\r\n   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task& task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task& task, Boolean asyncWrite)\r\n   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)\r\n   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)\r\n   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)\r\n   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)\r\n   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.<Reader>b__c(DbCommand t, DbCommandInterceptionContext`1 c)\r\n   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)\r\n   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)\r\n   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)\r\n   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)\r\n   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)" ], "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.&lt;GetElementFunction&gt;b__1[TResult](IEnumerable`1 sequence)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.ExecuteSingle[TResult](IEnumerable`1 query, Expression queryRoot)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ELinq.ObjectQueryProvider.System.Linq.IQueryProvider.Execute[TResult](Expression expression)&#xD;&#xA;   at System.Data.Entity.Internal.Linq.DbQueryProvider.Execute[TResult](Expression expression)&#xD;&#xA;   at System.Linq.Queryable.FirstOrDefault[TSource](IQueryable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1888&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'study'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ImagingStudy", "description" : "ImagingStudy: Read Existing", "status" : "fail", "message" : "Preexisting ImagingStudy unknown.", "data" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ImagingStudy", "description" : "ImagingStudy: Update Existing", "status" : "skip", "message" : "Unable to update -- existing ImagingStudy is not available or was not valid.", "data" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ImagingStudy", "description" : "ImagingStudy: Read History of existing", "status" : "skip", "message" : "Preexisting ImagingStudy unknown.", "data" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ImagingStudy", "description" : "ImagingStudy: Version read existing", "status" : "skip", "message" : "Preexisting ImagingStudy unknown.", "data" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ImagingStudy", "description" : "ImagingStudy: Previous version read existing", "status" : "skip", "message" : "Previous version of ImagingStudy unavailable.", "data" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ImagingStudy", "description" : "ImagingStudy: Validate", "status" : "pass", "message" : "ImagingStudy was validated.", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ImagingStudy", "description" : "ImagingStudy: Validate Existing", "status" : "pass", "message" : "Existing ImagingStudy was validated.", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ImagingStudy", "description" : "ImagingStudy: Validate against a profile", "status" : "pass", "message" : "ImagingStudy was validated.", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ImagingStudy", "description" : "ImagingStudy: Delete Existing", "status" : "skip", "message" : "Preexisting ImagingStudy unknown.", "data" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ImagingStudy", "description" : "ImagingStudy: Get Deleted Resource", "status" : "skip", "message" : "Skipped: x075_get_deleted_resource_test", "data" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:43:40.721-0400" }, "created_at" : { "$date" : "2015-10-02T18:43:40.721-0400" } }
,{ "_id" : { "$oid" : "560f08a44d4d3266f8cd0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04a4d4d3261a6380000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Immunization", "description" : "Immunization: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Immunization", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Immunization", "description" : "Immunization: Create New", "status" : "pass", "message" : "New Immunization was created.", "validates" : [ { "resource" : "Immunization", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Immunization", "description" : "Immunization: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Immunization.", "validates" : [ { "resource" : "Immunization", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Immunization", "description" : "Immunization: Update Existing", "status" : "pass", "message" : "Updated existing Immunization.", "validates" : [ { "resource" : "Immunization", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Immunization", "description" : "Immunization: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Immunization", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Immunization", "description" : "Immunization: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Immunization.", "validates" : [ { "resource" : "Immunization", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Immunization", "description" : "Immunization: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Immunization.", "validates" : [ { "resource" : "Immunization", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Immunization", "description" : "Immunization: Validate", "status" : "pass", "message" : "Immunization was validated.", "validates" : [ { "resource" : "Immunization", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Immunization", "description" : "Immunization: Validate Existing", "status" : "pass", "message" : "Existing Immunization was validated.", "validates" : [ { "resource" : "Immunization", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Immunization", "description" : "Immunization: Validate against a profile", "status" : "pass", "message" : "Immunization was validated.", "validates" : [ { "resource" : "Immunization", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Immunization", "description" : "Immunization: Delete Existing", "status" : "pass", "message" : "Existing Immunization was deleted.", "validates" : [ { "resource" : "Immunization", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Immunization", "description" : "Immunization: Get Deleted Resource", "status" : "pass", "message" : "Deleted Immunization was correctly reported as gone.", "validates" : [ { "resource" : "Immunization", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:43:48.020-0400" }, "created_at" : { "$date" : "2015-10-02T18:43:48.020-0400" } }
,{ "_id" : { "$oid" : "560f08ab4d4d3266f8ce0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04a4d4d3261a6390000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Create New", "status" : "pass", "message" : "New ImmunizationRecommendation was created.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ImmunizationRecommendation.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Update Existing", "status" : "pass", "message" : "Updated existing ImmunizationRecommendation.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ImmunizationRecommendation.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ImmunizationRecommendation.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Validate", "status" : "pass", "message" : "ImmunizationRecommendation was validated.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Validate Existing", "status" : "pass", "message" : "Existing ImmunizationRecommendation was validated.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Validate against a profile", "status" : "pass", "message" : "ImmunizationRecommendation was validated.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Delete Existing", "status" : "pass", "message" : "Existing ImmunizationRecommendation was deleted.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ImmunizationRecommendation", "description" : "ImmunizationRecommendation: Get Deleted Resource", "status" : "pass", "message" : "Deleted ImmunizationRecommendation was correctly reported as gone.", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:43:55.184-0400" }, "created_at" : { "$date" : "2015-10-02T18:43:55.184-0400" } }
,{ "_id" : { "$oid" : "560f08b14d4d3266f8cf0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04b4d4d3261a63a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ImplementationGuide", "description" : "ImplementationGuide: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ImplementationGuide", "description" : "ImplementationGuide: Create New", "status" : "pass", "message" : "New ImplementationGuide was created.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ImplementationGuide", "description" : "ImplementationGuide: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ImplementationGuide.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ImplementationGuide", "description" : "ImplementationGuide: Update Existing", "status" : "pass", "message" : "Updated existing ImplementationGuide.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ImplementationGuide", "description" : "ImplementationGuide: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ImplementationGuide", "description" : "ImplementationGuide: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ImplementationGuide.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ImplementationGuide", "description" : "ImplementationGuide: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ImplementationGuide.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ImplementationGuide", "description" : "ImplementationGuide: Validate", "status" : "pass", "message" : "ImplementationGuide was validated.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ImplementationGuide", "description" : "ImplementationGuide: Validate Existing", "status" : "pass", "message" : "Existing ImplementationGuide was validated.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ImplementationGuide", "description" : "ImplementationGuide: Validate against a profile", "status" : "pass", "message" : "ImplementationGuide was validated.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ImplementationGuide", "description" : "ImplementationGuide: Delete Existing", "status" : "pass", "message" : "Existing ImplementationGuide was deleted.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ImplementationGuide", "description" : "ImplementationGuide: Get Deleted Resource", "status" : "pass", "message" : "Deleted ImplementationGuide was correctly reported as gone.", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:44:01.604-0400" }, "created_at" : { "$date" : "2015-10-02T18:44:01.604-0400" } }
,{ "_id" : { "$oid" : "560f08be4d4d3266f8d00200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04b4d4d3261a63b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_List", "description" : "List: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "List", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_List", "description" : "List: Create New", "status" : "pass", "message" : "New List was created.", "validates" : [ { "resource" : "List", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_List", "description" : "List: Read Existing", "status" : "pass", "message" : "Successfully read preexisting List.", "validates" : [ { "resource" : "List", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_List", "description" : "List: Update Existing", "status" : "pass", "message" : "Updated existing List.", "validates" : [ { "resource" : "List", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_List", "description" : "List: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "List", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_List", "description" : "List: Version read existing", "status" : "pass", "message" : "Read current version of preexisting List.", "validates" : [ { "resource" : "List", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_List", "description" : "List: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting List.", "validates" : [ { "resource" : "List", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_List", "description" : "List: Validate", "status" : "pass", "message" : "List was validated.", "validates" : [ { "resource" : "List", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_List", "description" : "List: Validate Existing", "status" : "pass", "message" : "Existing List was validated.", "validates" : [ { "resource" : "List", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_List", "description" : "List: Validate against a profile", "status" : "pass", "message" : "List was validated.", "validates" : [ { "resource" : "List", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_List", "description" : "List: Delete Existing", "status" : "pass", "message" : "Existing List was deleted.", "validates" : [ { "resource" : "List", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_List", "description" : "List: Get Deleted Resource", "status" : "pass", "message" : "Deleted List was correctly reported as gone.", "validates" : [ { "resource" : "List", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:44:14.224-0400" }, "created_at" : { "$date" : "2015-10-02T18:44:14.224-0400" } }
,{ "_id" : { "$oid" : "560f08c64d4d3266f8d10200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04b4d4d3261a63c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Location", "description" : "Location: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Location", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Location", "description" : "Location: Create New", "status" : "pass", "message" : "New Location was created.", "validates" : [ { "resource" : "Location", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Location", "description" : "Location: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Location.", "validates" : [ { "resource" : "Location", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Location", "description" : "Location: Update Existing", "status" : "pass", "message" : "Updated existing Location.", "validates" : [ { "resource" : "Location", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Location", "description" : "Location: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Location", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Location", "description" : "Location: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Location.", "validates" : [ { "resource" : "Location", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Location", "description" : "Location: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Location.", "validates" : [ { "resource" : "Location", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Location", "description" : "Location: Validate", "status" : "pass", "message" : "Location was validated.", "validates" : [ { "resource" : "Location", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Location", "description" : "Location: Validate Existing", "status" : "pass", "message" : "Existing Location was validated.", "validates" : [ { "resource" : "Location", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Location", "description" : "Location: Validate against a profile", "status" : "pass", "message" : "Location was validated.", "validates" : [ { "resource" : "Location", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Location", "description" : "Location: Delete Existing", "status" : "pass", "message" : "Existing Location was deleted.", "validates" : [ { "resource" : "Location", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Location", "description" : "Location: Get Deleted Resource", "status" : "pass", "message" : "Deleted Location was correctly reported as gone.", "validates" : [ { "resource" : "Location", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:44:22.948-0400" }, "created_at" : { "$date" : "2015-10-02T18:44:22.948-0400" } }
,{ "_id" : { "$oid" : "560f08cf4d4d3266f8d20200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04b4d4d3261a63d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Media", "description" : "Media: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Media", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Media", "description" : "Media: Create New", "status" : "pass", "message" : "New Media was created.", "validates" : [ { "resource" : "Media", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Media", "description" : "Media: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Media.", "validates" : [ { "resource" : "Media", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Media", "description" : "Media: Update Existing", "status" : "pass", "message" : "Updated existing Media.", "validates" : [ { "resource" : "Media", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Media", "description" : "Media: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Media", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Media", "description" : "Media: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Media.", "validates" : [ { "resource" : "Media", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Media", "description" : "Media: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Media.", "validates" : [ { "resource" : "Media", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Media", "description" : "Media: Validate", "status" : "pass", "message" : "Media was validated.", "validates" : [ { "resource" : "Media", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Media", "description" : "Media: Validate Existing", "status" : "pass", "message" : "Existing Media was validated.", "validates" : [ { "resource" : "Media", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Media", "description" : "Media: Validate against a profile", "status" : "pass", "message" : "Media was validated.", "validates" : [ { "resource" : "Media", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Media", "description" : "Media: Delete Existing", "status" : "pass", "message" : "Existing Media was deleted.", "validates" : [ { "resource" : "Media", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Media", "description" : "Media: Get Deleted Resource", "status" : "pass", "message" : "Deleted Media was correctly reported as gone.", "validates" : [ { "resource" : "Media", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:44:31.050-0400" }, "created_at" : { "$date" : "2015-10-02T18:44:31.050-0400" } }
,{ "_id" : { "$oid" : "560f08d74d4d3266f8d30200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04b4d4d3261a63e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Medication", "description" : "Medication: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Medication", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Medication", "description" : "Medication: Create New", "status" : "pass", "message" : "New Medication was created.", "validates" : [ { "resource" : "Medication", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Medication", "description" : "Medication: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Medication.", "validates" : [ { "resource" : "Medication", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Medication", "description" : "Medication: Update Existing", "status" : "pass", "message" : "Updated existing Medication.", "validates" : [ { "resource" : "Medication", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Medication", "description" : "Medication: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Medication", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Medication", "description" : "Medication: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Medication.", "validates" : [ { "resource" : "Medication", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Medication", "description" : "Medication: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Medication.", "validates" : [ { "resource" : "Medication", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Medication", "description" : "Medication: Validate", "status" : "pass", "message" : "Medication was validated.", "validates" : [ { "resource" : "Medication", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Medication", "description" : "Medication: Validate Existing", "status" : "pass", "message" : "Existing Medication was validated.", "validates" : [ { "resource" : "Medication", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Medication", "description" : "Medication: Validate against a profile", "status" : "pass", "message" : "Medication was validated.", "validates" : [ { "resource" : "Medication", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Medication", "description" : "Medication: Delete Existing", "status" : "pass", "message" : "Existing Medication was deleted.", "validates" : [ { "resource" : "Medication", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Medication", "description" : "Medication: Get Deleted Resource", "status" : "pass", "message" : "Deleted Medication was correctly reported as gone.", "validates" : [ { "resource" : "Medication", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:44:39.622-0400" }, "created_at" : { "$date" : "2015-10-02T18:44:39.622-0400" } }
,{ "_id" : { "$oid" : "560f08de4d4d3266f8d40200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04b4d4d3261a63f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_MedicationAdministration", "description" : "MedicationAdministration: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_MedicationAdministration", "description" : "MedicationAdministration: Create New", "status" : "pass", "message" : "New MedicationAdministration was created.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_MedicationAdministration", "description" : "MedicationAdministration: Read Existing", "status" : "pass", "message" : "Successfully read preexisting MedicationAdministration.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_MedicationAdministration", "description" : "MedicationAdministration: Update Existing", "status" : "pass", "message" : "Updated existing MedicationAdministration.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_MedicationAdministration", "description" : "MedicationAdministration: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_MedicationAdministration", "description" : "MedicationAdministration: Version read existing", "status" : "pass", "message" : "Read current version of preexisting MedicationAdministration.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_MedicationAdministration", "description" : "MedicationAdministration: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting MedicationAdministration.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_MedicationAdministration", "description" : "MedicationAdministration: Validate", "status" : "pass", "message" : "MedicationAdministration was validated.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_MedicationAdministration", "description" : "MedicationAdministration: Validate Existing", "status" : "pass", "message" : "Existing MedicationAdministration was validated.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_MedicationAdministration", "description" : "MedicationAdministration: Validate against a profile", "status" : "pass", "message" : "MedicationAdministration was validated.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_MedicationAdministration", "description" : "MedicationAdministration: Delete Existing", "status" : "pass", "message" : "Existing MedicationAdministration was deleted.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_MedicationAdministration", "description" : "MedicationAdministration: Get Deleted Resource", "status" : "pass", "message" : "Deleted MedicationAdministration was correctly reported as gone.", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:44:46.985-0400" }, "created_at" : { "$date" : "2015-10-02T18:44:46.985-0400" } }
,{ "_id" : { "$oid" : "560f08e94d4d3266f8d50200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04b4d4d3261a6400000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_MedicationDispense", "description" : "MedicationDispense: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_MedicationDispense", "description" : "MedicationDispense: Create New", "status" : "pass", "message" : "New MedicationDispense was created.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_MedicationDispense", "description" : "MedicationDispense: Read Existing", "status" : "pass", "message" : "Successfully read preexisting MedicationDispense.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_MedicationDispense", "description" : "MedicationDispense: Update Existing", "status" : "pass", "message" : "Updated existing MedicationDispense.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_MedicationDispense", "description" : "MedicationDispense: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_MedicationDispense", "description" : "MedicationDispense: Version read existing", "status" : "pass", "message" : "Read current version of preexisting MedicationDispense.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_MedicationDispense", "description" : "MedicationDispense: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting MedicationDispense.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_MedicationDispense", "description" : "MedicationDispense: Validate", "status" : "pass", "message" : "MedicationDispense was validated.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_MedicationDispense", "description" : "MedicationDispense: Validate Existing", "status" : "pass", "message" : "Existing MedicationDispense was validated.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_MedicationDispense", "description" : "MedicationDispense: Validate against a profile", "status" : "pass", "message" : "MedicationDispense was validated.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_MedicationDispense", "description" : "MedicationDispense: Delete Existing", "status" : "pass", "message" : "Existing MedicationDispense was deleted.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_MedicationDispense", "description" : "MedicationDispense: Get Deleted Resource", "status" : "pass", "message" : "Deleted MedicationDispense was correctly reported as gone.", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:44:57.533-0400" }, "created_at" : { "$date" : "2015-10-02T18:44:57.533-0400" } }
,{ "_id" : { "$oid" : "560f08f24d4d3266f8d60200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04c4d4d3261a6410000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_MedicationOrder", "description" : "MedicationOrder: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_MedicationOrder", "description" : "MedicationOrder: Create New", "status" : "pass", "message" : "New MedicationOrder was created.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_MedicationOrder", "description" : "MedicationOrder: Read Existing", "status" : "pass", "message" : "Successfully read preexisting MedicationOrder.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_MedicationOrder", "description" : "MedicationOrder: Update Existing", "status" : "pass", "message" : "Updated existing MedicationOrder.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_MedicationOrder", "description" : "MedicationOrder: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_MedicationOrder", "description" : "MedicationOrder: Version read existing", "status" : "pass", "message" : "Read current version of preexisting MedicationOrder.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_MedicationOrder", "description" : "MedicationOrder: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting MedicationOrder.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_MedicationOrder", "description" : "MedicationOrder: Validate", "status" : "pass", "message" : "MedicationOrder was validated.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_MedicationOrder", "description" : "MedicationOrder: Validate Existing", "status" : "pass", "message" : "Existing MedicationOrder was validated.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_MedicationOrder", "description" : "MedicationOrder: Validate against a profile", "status" : "pass", "message" : "MedicationOrder was validated.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_MedicationOrder", "description" : "MedicationOrder: Delete Existing", "status" : "pass", "message" : "Existing MedicationOrder was deleted.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_MedicationOrder", "description" : "MedicationOrder: Get Deleted Resource", "status" : "pass", "message" : "Deleted MedicationOrder was correctly reported as gone.", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:45:06.796-0400" }, "created_at" : { "$date" : "2015-10-02T18:45:06.796-0400" } }
,{ "_id" : { "$oid" : "560f08fc4d4d3266f8d70200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04c4d4d3261a6420000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_MedicationStatement", "description" : "MedicationStatement: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_MedicationStatement", "description" : "MedicationStatement: Create New", "status" : "pass", "message" : "New MedicationStatement was created.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_MedicationStatement", "description" : "MedicationStatement: Read Existing", "status" : "pass", "message" : "Successfully read preexisting MedicationStatement.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_MedicationStatement", "description" : "MedicationStatement: Update Existing", "status" : "pass", "message" : "Updated existing MedicationStatement.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_MedicationStatement", "description" : "MedicationStatement: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_MedicationStatement", "description" : "MedicationStatement: Version read existing", "status" : "pass", "message" : "Read current version of preexisting MedicationStatement.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_MedicationStatement", "description" : "MedicationStatement: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting MedicationStatement.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_MedicationStatement", "description" : "MedicationStatement: Validate", "status" : "pass", "message" : "MedicationStatement was validated.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_MedicationStatement", "description" : "MedicationStatement: Validate Existing", "status" : "pass", "message" : "Existing MedicationStatement was validated.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_MedicationStatement", "description" : "MedicationStatement: Validate against a profile", "status" : "pass", "message" : "MedicationStatement was validated.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_MedicationStatement", "description" : "MedicationStatement: Delete Existing", "status" : "pass", "message" : "Existing MedicationStatement was deleted.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_MedicationStatement", "description" : "MedicationStatement: Get Deleted Resource", "status" : "pass", "message" : "Deleted MedicationStatement was correctly reported as gone.", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:45:16.467-0400" }, "created_at" : { "$date" : "2015-10-02T18:45:16.467-0400" } }
,{ "_id" : { "$oid" : "560f09054d4d3266f8d80200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04c4d4d3261a6430000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_MessageHeader", "description" : "MessageHeader: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MessageHeader", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_MessageHeader", "description" : "MessageHeader: Create New", "status" : "pass", "message" : "New MessageHeader was created.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_MessageHeader", "description" : "MessageHeader: Read Existing", "status" : "pass", "message" : "Successfully read preexisting MessageHeader.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_MessageHeader", "description" : "MessageHeader: Update Existing", "status" : "pass", "message" : "Updated existing MessageHeader.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_MessageHeader", "description" : "MessageHeader: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_MessageHeader", "description" : "MessageHeader: Version read existing", "status" : "pass", "message" : "Read current version of preexisting MessageHeader.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_MessageHeader", "description" : "MessageHeader: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting MessageHeader.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_MessageHeader", "description" : "MessageHeader: Validate", "status" : "pass", "message" : "MessageHeader was validated.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_MessageHeader", "description" : "MessageHeader: Validate Existing", "status" : "pass", "message" : "Existing MessageHeader was validated.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_MessageHeader", "description" : "MessageHeader: Validate against a profile", "status" : "pass", "message" : "MessageHeader was validated.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_MessageHeader", "description" : "MessageHeader: Delete Existing", "status" : "pass", "message" : "Existing MessageHeader was deleted.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_MessageHeader", "description" : "MessageHeader: Get Deleted Resource", "status" : "pass", "message" : "Deleted MessageHeader was correctly reported as gone.", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:45:25.429-0400" }, "created_at" : { "$date" : "2015-10-02T18:45:25.429-0400" } }
,{ "_id" : { "$oid" : "560f090d4d4d3266f8d90200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04c4d4d3261a6440000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_NamingSystem", "description" : "NamingSystem: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NamingSystem", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_NamingSystem", "description" : "NamingSystem: Create New", "status" : "pass", "message" : "New NamingSystem was created.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_NamingSystem", "description" : "NamingSystem: Read Existing", "status" : "pass", "message" : "Successfully read preexisting NamingSystem.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_NamingSystem", "description" : "NamingSystem: Update Existing", "status" : "pass", "message" : "Updated existing NamingSystem.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_NamingSystem", "description" : "NamingSystem: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_NamingSystem", "description" : "NamingSystem: Version read existing", "status" : "pass", "message" : "Read current version of preexisting NamingSystem.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_NamingSystem", "description" : "NamingSystem: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting NamingSystem.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_NamingSystem", "description" : "NamingSystem: Validate", "status" : "pass", "message" : "NamingSystem was validated.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_NamingSystem", "description" : "NamingSystem: Validate Existing", "status" : "pass", "message" : "Existing NamingSystem was validated.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_NamingSystem", "description" : "NamingSystem: Validate against a profile", "status" : "pass", "message" : "NamingSystem was validated.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_NamingSystem", "description" : "NamingSystem: Delete Existing", "status" : "pass", "message" : "Existing NamingSystem was deleted.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_NamingSystem", "description" : "NamingSystem: Get Deleted Resource", "status" : "pass", "message" : "Deleted NamingSystem was correctly reported as gone.", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:45:33.162-0400" }, "created_at" : { "$date" : "2015-10-02T18:45:33.162-0400" } }
,{ "_id" : { "$oid" : "560f09174d4d3266f8da0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04c4d4d3261a6450000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_NutritionOrder", "description" : "NutritionOrder: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_NutritionOrder", "description" : "NutritionOrder: Create New", "status" : "pass", "message" : "New NutritionOrder was created.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_NutritionOrder", "description" : "NutritionOrder: Read Existing", "status" : "pass", "message" : "Successfully read preexisting NutritionOrder.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_NutritionOrder", "description" : "NutritionOrder: Update Existing", "status" : "pass", "message" : "Updated existing NutritionOrder.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_NutritionOrder", "description" : "NutritionOrder: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_NutritionOrder", "description" : "NutritionOrder: Version read existing", "status" : "pass", "message" : "Read current version of preexisting NutritionOrder.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_NutritionOrder", "description" : "NutritionOrder: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting NutritionOrder.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_NutritionOrder", "description" : "NutritionOrder: Validate", "status" : "pass", "message" : "NutritionOrder was validated.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_NutritionOrder", "description" : "NutritionOrder: Validate Existing", "status" : "pass", "message" : "Existing NutritionOrder was validated.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_NutritionOrder", "description" : "NutritionOrder: Validate against a profile", "status" : "pass", "message" : "NutritionOrder was validated.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_NutritionOrder", "description" : "NutritionOrder: Delete Existing", "status" : "pass", "message" : "Existing NutritionOrder was deleted.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_NutritionOrder", "description" : "NutritionOrder: Get Deleted Resource", "status" : "pass", "message" : "Deleted NutritionOrder was correctly reported as gone.", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:45:43.294-0400" }, "created_at" : { "$date" : "2015-10-02T18:45:43.294-0400" } }
,{ "_id" : { "$oid" : "560f09214d4d3266f8db0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04c4d4d3261a6460000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Observation", "description" : "Observation: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Observation", "description" : "Observation: Create New", "status" : "pass", "message" : "New Observation was created.", "validates" : [ { "resource" : "Observation", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Observation", "description" : "Observation: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Observation.", "validates" : [ { "resource" : "Observation", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Observation", "description" : "Observation: Update Existing", "status" : "pass", "message" : "Updated existing Observation.", "validates" : [ { "resource" : "Observation", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Observation", "description" : "Observation: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Observation", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Observation", "description" : "Observation: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Observation.", "validates" : [ { "resource" : "Observation", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Observation", "description" : "Observation: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Observation.", "validates" : [ { "resource" : "Observation", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Observation", "description" : "Observation: Validate", "status" : "pass", "message" : "Observation was validated.", "validates" : [ { "resource" : "Observation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Observation", "description" : "Observation: Validate Existing", "status" : "pass", "message" : "Existing Observation was validated.", "validates" : [ { "resource" : "Observation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Observation", "description" : "Observation: Validate against a profile", "status" : "pass", "message" : "Observation was validated.", "validates" : [ { "resource" : "Observation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Observation", "description" : "Observation: Delete Existing", "status" : "pass", "message" : "Existing Observation was deleted.", "validates" : [ { "resource" : "Observation", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Observation", "description" : "Observation: Get Deleted Resource", "status" : "pass", "message" : "Deleted Observation was correctly reported as gone.", "validates" : [ { "resource" : "Observation", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:45:53.120-0400" }, "created_at" : { "$date" : "2015-10-02T18:45:53.120-0400" } }
,{ "_id" : { "$oid" : "560f09294d4d3266f8dc0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04c4d4d3261a6470000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_OperationDefinition", "description" : "OperationDefinition: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_OperationDefinition", "description" : "OperationDefinition: Create New", "status" : "pass", "message" : "New OperationDefinition was created.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_OperationDefinition", "description" : "OperationDefinition: Read Existing", "status" : "pass", "message" : "Successfully read preexisting OperationDefinition.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_OperationDefinition", "description" : "OperationDefinition: Update Existing", "status" : "pass", "message" : "Updated existing OperationDefinition.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_OperationDefinition", "description" : "OperationDefinition: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_OperationDefinition", "description" : "OperationDefinition: Version read existing", "status" : "pass", "message" : "Read current version of preexisting OperationDefinition.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_OperationDefinition", "description" : "OperationDefinition: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting OperationDefinition.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_OperationDefinition", "description" : "OperationDefinition: Validate", "status" : "pass", "message" : "OperationDefinition was validated.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_OperationDefinition", "description" : "OperationDefinition: Validate Existing", "status" : "pass", "message" : "Existing OperationDefinition was validated.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_OperationDefinition", "description" : "OperationDefinition: Validate against a profile", "status" : "pass", "message" : "OperationDefinition was validated.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_OperationDefinition", "description" : "OperationDefinition: Delete Existing", "status" : "pass", "message" : "Existing OperationDefinition was deleted.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_OperationDefinition", "description" : "OperationDefinition: Get Deleted Resource", "status" : "pass", "message" : "Deleted OperationDefinition was correctly reported as gone.", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:46:01.484-0400" }, "created_at" : { "$date" : "2015-10-02T18:46:01.484-0400" } }
,{ "_id" : { "$oid" : "560f09314d4d3266f8dd0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04d4d4d3261a6480000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_OperationOutcome", "description" : "OperationOutcome: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_OperationOutcome", "description" : "OperationOutcome: Create New", "status" : "pass", "message" : "New OperationOutcome was created.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_OperationOutcome", "description" : "OperationOutcome: Read Existing", "status" : "pass", "message" : "Successfully read preexisting OperationOutcome.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_OperationOutcome", "description" : "OperationOutcome: Update Existing", "status" : "pass", "message" : "Updated existing OperationOutcome.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_OperationOutcome", "description" : "OperationOutcome: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_OperationOutcome", "description" : "OperationOutcome: Version read existing", "status" : "pass", "message" : "Read current version of preexisting OperationOutcome.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_OperationOutcome", "description" : "OperationOutcome: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting OperationOutcome.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_OperationOutcome", "description" : "OperationOutcome: Validate", "status" : "pass", "message" : "OperationOutcome was validated.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_OperationOutcome", "description" : "OperationOutcome: Validate Existing", "status" : "pass", "message" : "Existing OperationOutcome was validated.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_OperationOutcome", "description" : "OperationOutcome: Validate against a profile", "status" : "pass", "message" : "OperationOutcome was validated.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_OperationOutcome", "description" : "OperationOutcome: Delete Existing", "status" : "pass", "message" : "Existing OperationOutcome was deleted.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_OperationOutcome", "description" : "OperationOutcome: Get Deleted Resource", "status" : "pass", "message" : "Deleted OperationOutcome was correctly reported as gone.", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:46:09.487-0400" }, "created_at" : { "$date" : "2015-10-02T18:46:09.487-0400" } }
,{ "_id" : { "$oid" : "560f093a4d4d3266f8de0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04d4d4d3261a6490000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Order", "description" : "Order: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Order", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Order", "description" : "Order: Create New", "status" : "pass", "message" : "New Order was created.", "validates" : [ { "resource" : "Order", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Order", "description" : "Order: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Order.", "validates" : [ { "resource" : "Order", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Order", "description" : "Order: Update Existing", "status" : "pass", "message" : "Updated existing Order.", "validates" : [ { "resource" : "Order", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Order", "description" : "Order: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Order", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Order", "description" : "Order: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Order.", "validates" : [ { "resource" : "Order", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Order", "description" : "Order: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Order.", "validates" : [ { "resource" : "Order", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Order", "description" : "Order: Validate", "status" : "pass", "message" : "Order was validated.", "validates" : [ { "resource" : "Order", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Order", "description" : "Order: Validate Existing", "status" : "pass", "message" : "Existing Order was validated.", "validates" : [ { "resource" : "Order", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Order", "description" : "Order: Validate against a profile", "status" : "pass", "message" : "Order was validated.", "validates" : [ { "resource" : "Order", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Order", "description" : "Order: Delete Existing", "status" : "pass", "message" : "Existing Order was deleted.", "validates" : [ { "resource" : "Order", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Order", "description" : "Order: Get Deleted Resource", "status" : "pass", "message" : "Deleted Order was correctly reported as gone.", "validates" : [ { "resource" : "Order", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:46:18.185-0400" }, "created_at" : { "$date" : "2015-10-02T18:46:18.185-0400" } }
,{ "_id" : { "$oid" : "560f09404d4d3266f8df0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04d4d4d3261a64a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_OrderResponse", "description" : "OrderResponse: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OrderResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_OrderResponse", "description" : "OrderResponse: Create New", "status" : "pass", "message" : "New OrderResponse was created.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_OrderResponse", "description" : "OrderResponse: Read Existing", "status" : "pass", "message" : "Successfully read preexisting OrderResponse.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_OrderResponse", "description" : "OrderResponse: Update Existing", "status" : "pass", "message" : "Updated existing OrderResponse.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_OrderResponse", "description" : "OrderResponse: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_OrderResponse", "description" : "OrderResponse: Version read existing", "status" : "pass", "message" : "Read current version of preexisting OrderResponse.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_OrderResponse", "description" : "OrderResponse: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting OrderResponse.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_OrderResponse", "description" : "OrderResponse: Validate", "status" : "pass", "message" : "OrderResponse was validated.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_OrderResponse", "description" : "OrderResponse: Validate Existing", "status" : "pass", "message" : "Existing OrderResponse was validated.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_OrderResponse", "description" : "OrderResponse: Validate against a profile", "status" : "pass", "message" : "OrderResponse was validated.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_OrderResponse", "description" : "OrderResponse: Delete Existing", "status" : "pass", "message" : "Existing OrderResponse was deleted.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_OrderResponse", "description" : "OrderResponse: Get Deleted Resource", "status" : "pass", "message" : "Deleted OrderResponse was correctly reported as gone.", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:46:24.922-0400" }, "created_at" : { "$date" : "2015-10-02T18:46:24.922-0400" } }
,{ "_id" : { "$oid" : "560f09484d4d3266f8e00200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04d4d4d3261a64b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Organization", "description" : "Organization: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Organization", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Organization", "description" : "Organization: Create New", "status" : "pass", "message" : "New Organization was created.", "validates" : [ { "resource" : "Organization", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Organization", "description" : "Organization: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Organization.", "validates" : [ { "resource" : "Organization", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Organization", "description" : "Organization: Update Existing", "status" : "pass", "message" : "Updated existing Organization.", "validates" : [ { "resource" : "Organization", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Organization", "description" : "Organization: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Organization", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Organization", "description" : "Organization: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Organization.", "validates" : [ { "resource" : "Organization", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Organization", "description" : "Organization: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Organization.", "validates" : [ { "resource" : "Organization", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Organization", "description" : "Organization: Validate", "status" : "pass", "message" : "Organization was validated.", "validates" : [ { "resource" : "Organization", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Organization", "description" : "Organization: Validate Existing", "status" : "pass", "message" : "Existing Organization was validated.", "validates" : [ { "resource" : "Organization", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Organization", "description" : "Organization: Validate against a profile", "status" : "pass", "message" : "Organization was validated.", "validates" : [ { "resource" : "Organization", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Organization", "description" : "Organization: Delete Existing", "status" : "pass", "message" : "Existing Organization was deleted.", "validates" : [ { "resource" : "Organization", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Organization", "description" : "Organization: Get Deleted Resource", "status" : "pass", "message" : "Deleted Organization was correctly reported as gone.", "validates" : [ { "resource" : "Organization", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:46:32.531-0400" }, "created_at" : { "$date" : "2015-10-02T18:46:32.531-0400" } }
,{ "_id" : { "$oid" : "560f09514d4d3266f8e10200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04d4d4d3261a64c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Patient", "description" : "Patient: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Patient", "description" : "Patient: Create New", "status" : "pass", "message" : "New Patient was created.", "validates" : [ { "resource" : "Patient", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Patient", "description" : "Patient: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Patient.", "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Patient", "description" : "Patient: Update Existing", "status" : "pass", "message" : "Updated existing Patient.", "validates" : [ { "resource" : "Patient", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Patient", "description" : "Patient: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Patient", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Patient", "description" : "Patient: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Patient.", "validates" : [ { "resource" : "Patient", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Patient", "description" : "Patient: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Patient.", "validates" : [ { "resource" : "Patient", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Patient", "description" : "Patient: Validate", "status" : "pass", "message" : "Patient was validated.", "validates" : [ { "resource" : "Patient", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Patient", "description" : "Patient: Validate Existing", "status" : "pass", "message" : "Existing Patient was validated.", "validates" : [ { "resource" : "Patient", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Patient", "description" : "Patient: Validate against a profile", "status" : "pass", "message" : "Patient was validated.", "validates" : [ { "resource" : "Patient", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Patient", "description" : "Patient: Delete Existing", "status" : "pass", "message" : "Existing Patient was deleted.", "validates" : [ { "resource" : "Patient", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Patient", "description" : "Patient: Get Deleted Resource", "status" : "pass", "message" : "Deleted Patient was correctly reported as gone.", "validates" : [ { "resource" : "Patient", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:46:41.037-0400" }, "created_at" : { "$date" : "2015-10-02T18:46:41.037-0400" } }
,{ "_id" : { "$oid" : "560f09594d4d3266f8e20200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04d4d4d3261a64d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_PaymentNotice", "description" : "PaymentNotice: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_PaymentNotice", "description" : "PaymentNotice: Create New", "status" : "pass", "message" : "New PaymentNotice was created.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_PaymentNotice", "description" : "PaymentNotice: Read Existing", "status" : "pass", "message" : "Successfully read preexisting PaymentNotice.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_PaymentNotice", "description" : "PaymentNotice: Update Existing", "status" : "pass", "message" : "Updated existing PaymentNotice.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_PaymentNotice", "description" : "PaymentNotice: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_PaymentNotice", "description" : "PaymentNotice: Version read existing", "status" : "pass", "message" : "Read current version of preexisting PaymentNotice.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_PaymentNotice", "description" : "PaymentNotice: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting PaymentNotice.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_PaymentNotice", "description" : "PaymentNotice: Validate", "status" : "pass", "message" : "PaymentNotice was validated.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_PaymentNotice", "description" : "PaymentNotice: Validate Existing", "status" : "pass", "message" : "Existing PaymentNotice was validated.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_PaymentNotice", "description" : "PaymentNotice: Validate against a profile", "status" : "pass", "message" : "PaymentNotice was validated.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_PaymentNotice", "description" : "PaymentNotice: Delete Existing", "status" : "pass", "message" : "Existing PaymentNotice was deleted.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_PaymentNotice", "description" : "PaymentNotice: Get Deleted Resource", "status" : "pass", "message" : "Deleted PaymentNotice was correctly reported as gone.", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:46:49.427-0400" }, "created_at" : { "$date" : "2015-10-02T18:46:49.427-0400" } }
,{ "_id" : { "$oid" : "560f09604d4d3266f8e30200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04d4d4d3261a64e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_PaymentReconciliation", "description" : "PaymentReconciliation: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_PaymentReconciliation", "description" : "PaymentReconciliation: Create New", "status" : "pass", "message" : "New PaymentReconciliation was created.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_PaymentReconciliation", "description" : "PaymentReconciliation: Read Existing", "status" : "pass", "message" : "Successfully read preexisting PaymentReconciliation.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_PaymentReconciliation", "description" : "PaymentReconciliation: Update Existing", "status" : "pass", "message" : "Updated existing PaymentReconciliation.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_PaymentReconciliation", "description" : "PaymentReconciliation: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_PaymentReconciliation", "description" : "PaymentReconciliation: Version read existing", "status" : "pass", "message" : "Read current version of preexisting PaymentReconciliation.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_PaymentReconciliation", "description" : "PaymentReconciliation: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting PaymentReconciliation.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_PaymentReconciliation", "description" : "PaymentReconciliation: Validate", "status" : "pass", "message" : "PaymentReconciliation was validated.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_PaymentReconciliation", "description" : "PaymentReconciliation: Validate Existing", "status" : "pass", "message" : "Existing PaymentReconciliation was validated.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_PaymentReconciliation", "description" : "PaymentReconciliation: Validate against a profile", "status" : "pass", "message" : "PaymentReconciliation was validated.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_PaymentReconciliation", "description" : "PaymentReconciliation: Delete Existing", "status" : "pass", "message" : "Existing PaymentReconciliation was deleted.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_PaymentReconciliation", "description" : "PaymentReconciliation: Get Deleted Resource", "status" : "pass", "message" : "Deleted PaymentReconciliation was correctly reported as gone.", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:46:56.507-0400" }, "created_at" : { "$date" : "2015-10-02T18:46:56.507-0400" } }
,{ "_id" : { "$oid" : "560f09684d4d3266f8e40200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04d4d4d3261a64f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Person", "description" : "Person: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Person", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Person", "description" : "Person: Create New", "status" : "pass", "message" : "New Person was created.", "validates" : [ { "resource" : "Person", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Person", "description" : "Person: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Person.", "validates" : [ { "resource" : "Person", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Person", "description" : "Person: Update Existing", "status" : "pass", "message" : "Updated existing Person.", "validates" : [ { "resource" : "Person", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Person", "description" : "Person: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Person", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Person", "description" : "Person: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Person.", "validates" : [ { "resource" : "Person", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Person", "description" : "Person: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Person.", "validates" : [ { "resource" : "Person", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Person", "description" : "Person: Validate", "status" : "pass", "message" : "Person was validated.", "validates" : [ { "resource" : "Person", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Person", "description" : "Person: Validate Existing", "status" : "pass", "message" : "Existing Person was validated.", "validates" : [ { "resource" : "Person", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Person", "description" : "Person: Validate against a profile", "status" : "pass", "message" : "Person was validated.", "validates" : [ { "resource" : "Person", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Person", "description" : "Person: Delete Existing", "status" : "pass", "message" : "Existing Person was deleted.", "validates" : [ { "resource" : "Person", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Person", "description" : "Person: Get Deleted Resource", "status" : "pass", "message" : "Deleted Person was correctly reported as gone.", "validates" : [ { "resource" : "Person", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:47:04.888-0400" }, "created_at" : { "$date" : "2015-10-02T18:47:04.888-0400" } }
,{ "_id" : { "$oid" : "560f09734d4d3266f8e50200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04e4d4d3261a6500000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Practitioner", "description" : "Practitioner: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Practitioner", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Practitioner", "description" : "Practitioner: Create New", "status" : "fail", "message" : [ "error: : ArgumentNullException: Value cannot be null.\r\nParameter name: uriString", "information: :    at System.Uri..ctor(String uriString, UriKind uriKind)\r\n   at Hl7.Fhir.Rest.ResourceIdentity..ctor(String uri) in C:\\src\\FHIR\\fhir-net-api-DSTU2\\src\\Hl7.Fhir.Core\\Rest\\ResourceIdentity.cs:line 53\r\n   at HealthConnex.Fhir.Models.PractitionerModel.UpdateResource(fhirstore store, Practitioner resource, PractitionerResource head, PractitionerResourceHistory ver) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\PractitionerModel.cs:line 67\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1947\r\n   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806\r\n   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672\r\n   at lambda_method(Closure , Object , Object[] )\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.<>c__DisplayClass10.<GetExecutor>b__9(Object instance, Object[] methodParameters)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)\r\n   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.<InvokeActionAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<CallOnActionExecutedAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Filters.ActionFilterAttribute.<ExecuteActionFilterAsyncCore>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.<ExecuteAsync>d__2.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ExceptionFilterResult.<ExecuteAsync>d__0.MoveNext()" ], "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"ArgumentNullException: Value cannot be null.&#xD;&#xA;Parameter name: uriString\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Uri..ctor(String uriString, UriKind uriKind)&#xD;&#xA;   at Hl7.Fhir.Rest.ResourceIdentity..ctor(String uri) in C:\\src\\FHIR\\fhir-net-api-DSTU2\\src\\Hl7.Fhir.Core\\Rest\\ResourceIdentity.cs:line 53&#xD;&#xA;   at HealthConnex.Fhir.Models.PractitionerModel.UpdateResource(fhirstore store, Practitioner resource, PractitionerResource head, PractitionerResourceHistory ver) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\PractitionerModel.cs:line 67&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(fhirstore store, TResource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1947&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Create(Resource resource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1806&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Post(String ResourceName, Resource bodyResource) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 672&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "Practitioner", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Practitioner", "description" : "Practitioner: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Practitioner.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Practitioner", "description" : "Practitioner: Update Existing", "status" : "pass", "message" : "Updated existing Practitioner.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Practitioner", "description" : "Practitioner: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Practitioner", "description" : "Practitioner: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Practitioner.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Practitioner", "description" : "Practitioner: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Practitioner.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Practitioner", "description" : "Practitioner: Validate", "status" : "pass", "message" : "Practitioner was validated.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Practitioner", "description" : "Practitioner: Validate Existing", "status" : "pass", "message" : "Existing Practitioner was validated.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Practitioner", "description" : "Practitioner: Validate against a profile", "status" : "pass", "message" : "Practitioner was validated.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Practitioner", "description" : "Practitioner: Delete Existing", "status" : "pass", "message" : "Existing Practitioner was deleted.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Practitioner", "description" : "Practitioner: Get Deleted Resource", "status" : "pass", "message" : "Deleted Practitioner was correctly reported as gone.", "validates" : [ { "resource" : "Practitioner", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:47:15.479-0400" }, "created_at" : { "$date" : "2015-10-02T18:47:15.479-0400" } }
,{ "_id" : { "$oid" : "560f097c4d4d3266f8e60200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04e4d4d3261a6510000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Procedure", "description" : "Procedure: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Procedure", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Procedure", "description" : "Procedure: Create New", "status" : "pass", "message" : "New Procedure was created.", "validates" : [ { "resource" : "Procedure", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Procedure", "description" : "Procedure: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Procedure.", "validates" : [ { "resource" : "Procedure", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Procedure", "description" : "Procedure: Update Existing", "status" : "pass", "message" : "Updated existing Procedure.", "validates" : [ { "resource" : "Procedure", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Procedure", "description" : "Procedure: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Procedure", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Procedure", "description" : "Procedure: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Procedure.", "validates" : [ { "resource" : "Procedure", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Procedure", "description" : "Procedure: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Procedure.", "validates" : [ { "resource" : "Procedure", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Procedure", "description" : "Procedure: Validate", "status" : "pass", "message" : "Procedure was validated.", "validates" : [ { "resource" : "Procedure", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Procedure", "description" : "Procedure: Validate Existing", "status" : "pass", "message" : "Existing Procedure was validated.", "validates" : [ { "resource" : "Procedure", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Procedure", "description" : "Procedure: Validate against a profile", "status" : "pass", "message" : "Procedure was validated.", "validates" : [ { "resource" : "Procedure", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Procedure", "description" : "Procedure: Delete Existing", "status" : "pass", "message" : "Existing Procedure was deleted.", "validates" : [ { "resource" : "Procedure", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Procedure", "description" : "Procedure: Get Deleted Resource", "status" : "pass", "message" : "Deleted Procedure was correctly reported as gone.", "validates" : [ { "resource" : "Procedure", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:47:24.380-0400" }, "created_at" : { "$date" : "2015-10-02T18:47:24.380-0400" } }
,{ "_id" : { "$oid" : "560f09834d4d3266f8e70200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04e4d4d3261a6520000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ProcedureRequest", "description" : "ProcedureRequest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ProcedureRequest", "description" : "ProcedureRequest: Create New", "status" : "pass", "message" : "New ProcedureRequest was created.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ProcedureRequest", "description" : "ProcedureRequest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ProcedureRequest.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ProcedureRequest", "description" : "ProcedureRequest: Update Existing", "status" : "pass", "message" : "Updated existing ProcedureRequest.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ProcedureRequest", "description" : "ProcedureRequest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ProcedureRequest", "description" : "ProcedureRequest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ProcedureRequest.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ProcedureRequest", "description" : "ProcedureRequest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ProcedureRequest.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ProcedureRequest", "description" : "ProcedureRequest: Validate", "status" : "pass", "message" : "ProcedureRequest was validated.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ProcedureRequest", "description" : "ProcedureRequest: Validate Existing", "status" : "pass", "message" : "Existing ProcedureRequest was validated.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ProcedureRequest", "description" : "ProcedureRequest: Validate against a profile", "status" : "pass", "message" : "ProcedureRequest was validated.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ProcedureRequest", "description" : "ProcedureRequest: Delete Existing", "status" : "pass", "message" : "Existing ProcedureRequest was deleted.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ProcedureRequest", "description" : "ProcedureRequest: Get Deleted Resource", "status" : "pass", "message" : "Deleted ProcedureRequest was correctly reported as gone.", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:47:31.149-0400" }, "created_at" : { "$date" : "2015-10-02T18:47:31.149-0400" } }
,{ "_id" : { "$oid" : "560f098a4d4d3266f8e80200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04e4d4d3261a6530000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ProcessRequest", "description" : "ProcessRequest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ProcessRequest", "description" : "ProcessRequest: Create New", "status" : "pass", "message" : "New ProcessRequest was created.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ProcessRequest", "description" : "ProcessRequest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ProcessRequest.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ProcessRequest", "description" : "ProcessRequest: Update Existing", "status" : "pass", "message" : "Updated existing ProcessRequest.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ProcessRequest", "description" : "ProcessRequest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ProcessRequest", "description" : "ProcessRequest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ProcessRequest.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ProcessRequest", "description" : "ProcessRequest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ProcessRequest.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ProcessRequest", "description" : "ProcessRequest: Validate", "status" : "pass", "message" : "ProcessRequest was validated.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ProcessRequest", "description" : "ProcessRequest: Validate Existing", "status" : "pass", "message" : "Existing ProcessRequest was validated.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ProcessRequest", "description" : "ProcessRequest: Validate against a profile", "status" : "pass", "message" : "ProcessRequest was validated.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ProcessRequest", "description" : "ProcessRequest: Delete Existing", "status" : "pass", "message" : "Existing ProcessRequest was deleted.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ProcessRequest", "description" : "ProcessRequest: Get Deleted Resource", "status" : "pass", "message" : "Deleted ProcessRequest was correctly reported as gone.", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:47:38.104-0400" }, "created_at" : { "$date" : "2015-10-02T18:47:38.104-0400" } }
,{ "_id" : { "$oid" : "560f09914d4d3266f8e90200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04e4d4d3261a6540000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ProcessResponse", "description" : "ProcessResponse: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ProcessResponse", "description" : "ProcessResponse: Create New", "status" : "pass", "message" : "New ProcessResponse was created.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ProcessResponse", "description" : "ProcessResponse: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ProcessResponse.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ProcessResponse", "description" : "ProcessResponse: Update Existing", "status" : "pass", "message" : "Updated existing ProcessResponse.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ProcessResponse", "description" : "ProcessResponse: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ProcessResponse", "description" : "ProcessResponse: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ProcessResponse.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ProcessResponse", "description" : "ProcessResponse: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ProcessResponse.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ProcessResponse", "description" : "ProcessResponse: Validate", "status" : "pass", "message" : "ProcessResponse was validated.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ProcessResponse", "description" : "ProcessResponse: Validate Existing", "status" : "pass", "message" : "Existing ProcessResponse was validated.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ProcessResponse", "description" : "ProcessResponse: Validate against a profile", "status" : "pass", "message" : "ProcessResponse was validated.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ProcessResponse", "description" : "ProcessResponse: Delete Existing", "status" : "pass", "message" : "Existing ProcessResponse was deleted.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ProcessResponse", "description" : "ProcessResponse: Get Deleted Resource", "status" : "pass", "message" : "Deleted ProcessResponse was correctly reported as gone.", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:47:45.019-0400" }, "created_at" : { "$date" : "2015-10-02T18:47:45.019-0400" } }
,{ "_id" : { "$oid" : "560f09994d4d3266f8ea0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04e4d4d3261a6550000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Provenance", "description" : "Provenance: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Provenance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Provenance", "description" : "Provenance: Create New", "status" : "pass", "message" : "New Provenance was created.", "validates" : [ { "resource" : "Provenance", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Provenance", "description" : "Provenance: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Provenance.", "validates" : [ { "resource" : "Provenance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Provenance", "description" : "Provenance: Update Existing", "status" : "pass", "message" : "Updated existing Provenance.", "validates" : [ { "resource" : "Provenance", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Provenance", "description" : "Provenance: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Provenance", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Provenance", "description" : "Provenance: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Provenance.", "validates" : [ { "resource" : "Provenance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Provenance", "description" : "Provenance: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Provenance.", "validates" : [ { "resource" : "Provenance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Provenance", "description" : "Provenance: Validate", "status" : "pass", "message" : "Provenance was validated.", "validates" : [ { "resource" : "Provenance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Provenance", "description" : "Provenance: Validate Existing", "status" : "pass", "message" : "Existing Provenance was validated.", "validates" : [ { "resource" : "Provenance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Provenance", "description" : "Provenance: Validate against a profile", "status" : "pass", "message" : "Provenance was validated.", "validates" : [ { "resource" : "Provenance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Provenance", "description" : "Provenance: Delete Existing", "status" : "pass", "message" : "Existing Provenance was deleted.", "validates" : [ { "resource" : "Provenance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Provenance", "description" : "Provenance: Get Deleted Resource", "status" : "pass", "message" : "Deleted Provenance was correctly reported as gone.", "validates" : [ { "resource" : "Provenance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:47:53.350-0400" }, "created_at" : { "$date" : "2015-10-02T18:47:53.350-0400" } }
,{ "_id" : { "$oid" : "560f09b14d4d3266f8eb0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04f4d4d3261a6560000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Questionnaire", "description" : "Questionnaire: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Questionnaire", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Questionnaire", "description" : "Questionnaire: Create New", "status" : "pass", "message" : "New Questionnaire was created.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Questionnaire", "description" : "Questionnaire: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Questionnaire.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Questionnaire", "description" : "Questionnaire: Update Existing", "status" : "pass", "message" : "Updated existing Questionnaire.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Questionnaire", "description" : "Questionnaire: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Questionnaire", "description" : "Questionnaire: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Questionnaire.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Questionnaire", "description" : "Questionnaire: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Questionnaire.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Questionnaire", "description" : "Questionnaire: Validate", "status" : "pass", "message" : "Questionnaire was validated.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Questionnaire", "description" : "Questionnaire: Validate Existing", "status" : "pass", "message" : "Existing Questionnaire was validated.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Questionnaire", "description" : "Questionnaire: Validate against a profile", "status" : "pass", "message" : "Questionnaire was validated.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Questionnaire", "description" : "Questionnaire: Delete Existing", "status" : "pass", "message" : "Existing Questionnaire was deleted.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Questionnaire", "description" : "Questionnaire: Get Deleted Resource", "status" : "pass", "message" : "Deleted Questionnaire was correctly reported as gone.", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:48:17.478-0400" }, "created_at" : { "$date" : "2015-10-02T18:48:17.478-0400" } }
,{ "_id" : { "$oid" : "560f09cc4d4d3266f8ec0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04f4d4d3261a6570000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_QuestionnaireResponse", "description" : "QuestionnaireResponse: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_QuestionnaireResponse", "description" : "QuestionnaireResponse: Create New", "status" : "pass", "message" : "New QuestionnaireResponse was created.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_QuestionnaireResponse", "description" : "QuestionnaireResponse: Read Existing", "status" : "pass", "message" : "Successfully read preexisting QuestionnaireResponse.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_QuestionnaireResponse", "description" : "QuestionnaireResponse: Update Existing", "status" : "pass", "message" : "Updated existing QuestionnaireResponse.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_QuestionnaireResponse", "description" : "QuestionnaireResponse: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_QuestionnaireResponse", "description" : "QuestionnaireResponse: Version read existing", "status" : "pass", "message" : "Read current version of preexisting QuestionnaireResponse.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_QuestionnaireResponse", "description" : "QuestionnaireResponse: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting QuestionnaireResponse.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_QuestionnaireResponse", "description" : "QuestionnaireResponse: Validate", "status" : "pass", "message" : "QuestionnaireResponse was validated.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_QuestionnaireResponse", "description" : "QuestionnaireResponse: Validate Existing", "status" : "pass", "message" : "Existing QuestionnaireResponse was validated.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_QuestionnaireResponse", "description" : "QuestionnaireResponse: Validate against a profile", "status" : "pass", "message" : "QuestionnaireResponse was validated.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_QuestionnaireResponse", "description" : "QuestionnaireResponse: Delete Existing", "status" : "pass", "message" : "Existing QuestionnaireResponse was deleted.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_QuestionnaireResponse", "description" : "QuestionnaireResponse: Get Deleted Resource", "status" : "pass", "message" : "Deleted QuestionnaireResponse was correctly reported as gone.", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:48:44.730-0400" }, "created_at" : { "$date" : "2015-10-02T18:48:44.730-0400" } }
,{ "_id" : { "$oid" : "560f09d44d4d3266f8ed0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04f4d4d3261a6580000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ReferralRequest", "description" : "ReferralRequest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ReferralRequest", "description" : "ReferralRequest: Create New", "status" : "pass", "message" : "New ReferralRequest was created.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ReferralRequest", "description" : "ReferralRequest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ReferralRequest.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ReferralRequest", "description" : "ReferralRequest: Update Existing", "status" : "pass", "message" : "Updated existing ReferralRequest.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ReferralRequest", "description" : "ReferralRequest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ReferralRequest", "description" : "ReferralRequest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ReferralRequest.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ReferralRequest", "description" : "ReferralRequest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ReferralRequest.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ReferralRequest", "description" : "ReferralRequest: Validate", "status" : "pass", "message" : "ReferralRequest was validated.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ReferralRequest", "description" : "ReferralRequest: Validate Existing", "status" : "pass", "message" : "Existing ReferralRequest was validated.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ReferralRequest", "description" : "ReferralRequest: Validate against a profile", "status" : "pass", "message" : "ReferralRequest was validated.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ReferralRequest", "description" : "ReferralRequest: Delete Existing", "status" : "pass", "message" : "Existing ReferralRequest was deleted.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ReferralRequest", "description" : "ReferralRequest: Get Deleted Resource", "status" : "pass", "message" : "Deleted ReferralRequest was correctly reported as gone.", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:48:52.923-0400" }, "created_at" : { "$date" : "2015-10-02T18:48:52.923-0400" } }
,{ "_id" : { "$oid" : "560f09dc4d4d3266f8ee0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04f4d4d3261a6590000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_RelatedPerson", "description" : "RelatedPerson: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_RelatedPerson", "description" : "RelatedPerson: Create New", "status" : "pass", "message" : "New RelatedPerson was created.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_RelatedPerson", "description" : "RelatedPerson: Read Existing", "status" : "pass", "message" : "Successfully read preexisting RelatedPerson.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_RelatedPerson", "description" : "RelatedPerson: Update Existing", "status" : "pass", "message" : "Updated existing RelatedPerson.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_RelatedPerson", "description" : "RelatedPerson: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_RelatedPerson", "description" : "RelatedPerson: Version read existing", "status" : "pass", "message" : "Read current version of preexisting RelatedPerson.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_RelatedPerson", "description" : "RelatedPerson: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting RelatedPerson.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_RelatedPerson", "description" : "RelatedPerson: Validate", "status" : "pass", "message" : "RelatedPerson was validated.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_RelatedPerson", "description" : "RelatedPerson: Validate Existing", "status" : "pass", "message" : "Existing RelatedPerson was validated.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_RelatedPerson", "description" : "RelatedPerson: Validate against a profile", "status" : "pass", "message" : "RelatedPerson was validated.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_RelatedPerson", "description" : "RelatedPerson: Delete Existing", "status" : "pass", "message" : "Existing RelatedPerson was deleted.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_RelatedPerson", "description" : "RelatedPerson: Get Deleted Resource", "status" : "pass", "message" : "Deleted RelatedPerson was correctly reported as gone.", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:49:00.918-0400" }, "created_at" : { "$date" : "2015-10-02T18:49:00.918-0400" } }
,{ "_id" : { "$oid" : "560f09e44d4d3266f8ef0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04f4d4d3261a65a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_RiskAssessment", "description" : "RiskAssessment: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_RiskAssessment", "description" : "RiskAssessment: Create New", "status" : "pass", "message" : "New RiskAssessment was created.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_RiskAssessment", "description" : "RiskAssessment: Read Existing", "status" : "pass", "message" : "Successfully read preexisting RiskAssessment.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_RiskAssessment", "description" : "RiskAssessment: Update Existing", "status" : "pass", "message" : "Updated existing RiskAssessment.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_RiskAssessment", "description" : "RiskAssessment: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_RiskAssessment", "description" : "RiskAssessment: Version read existing", "status" : "pass", "message" : "Read current version of preexisting RiskAssessment.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_RiskAssessment", "description" : "RiskAssessment: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting RiskAssessment.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_RiskAssessment", "description" : "RiskAssessment: Validate", "status" : "pass", "message" : "RiskAssessment was validated.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_RiskAssessment", "description" : "RiskAssessment: Validate Existing", "status" : "pass", "message" : "Existing RiskAssessment was validated.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_RiskAssessment", "description" : "RiskAssessment: Validate against a profile", "status" : "pass", "message" : "RiskAssessment was validated.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_RiskAssessment", "description" : "RiskAssessment: Delete Existing", "status" : "pass", "message" : "Existing RiskAssessment was deleted.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_RiskAssessment", "description" : "RiskAssessment: Get Deleted Resource", "status" : "pass", "message" : "Deleted RiskAssessment was correctly reported as gone.", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:49:08.385-0400" }, "created_at" : { "$date" : "2015-10-02T18:49:08.385-0400" } }
,{ "_id" : { "$oid" : "560f09ec4d4d3266f8f00200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04f4d4d3261a65b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Schedule", "description" : "Schedule: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Schedule", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Schedule", "description" : "Schedule: Create New", "status" : "pass", "message" : "New Schedule was created.", "validates" : [ { "resource" : "Schedule", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Schedule", "description" : "Schedule: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Schedule.", "validates" : [ { "resource" : "Schedule", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Schedule", "description" : "Schedule: Update Existing", "status" : "pass", "message" : "Updated existing Schedule.", "validates" : [ { "resource" : "Schedule", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Schedule", "description" : "Schedule: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Schedule", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Schedule", "description" : "Schedule: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Schedule.", "validates" : [ { "resource" : "Schedule", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Schedule", "description" : "Schedule: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Schedule.", "validates" : [ { "resource" : "Schedule", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Schedule", "description" : "Schedule: Validate", "status" : "pass", "message" : "Schedule was validated.", "validates" : [ { "resource" : "Schedule", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Schedule", "description" : "Schedule: Validate Existing", "status" : "pass", "message" : "Existing Schedule was validated.", "validates" : [ { "resource" : "Schedule", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Schedule", "description" : "Schedule: Validate against a profile", "status" : "pass", "message" : "Schedule was validated.", "validates" : [ { "resource" : "Schedule", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Schedule", "description" : "Schedule: Delete Existing", "status" : "pass", "message" : "Existing Schedule was deleted.", "validates" : [ { "resource" : "Schedule", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Schedule", "description" : "Schedule: Get Deleted Resource", "status" : "pass", "message" : "Deleted Schedule was correctly reported as gone.", "validates" : [ { "resource" : "Schedule", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:49:16.172-0400" }, "created_at" : { "$date" : "2015-10-02T18:49:16.172-0400" } }
,{ "_id" : { "$oid" : "560f09f54d4d3266f8f10200" }, "has_run" : true, "test_id" : { "$oid" : "560ef04f4d4d3261a65c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_SearchParameter", "description" : "SearchParameter: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SearchParameter", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_SearchParameter", "description" : "SearchParameter: Create New", "status" : "pass", "message" : "New SearchParameter was created.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_SearchParameter", "description" : "SearchParameter: Read Existing", "status" : "pass", "message" : "Successfully read preexisting SearchParameter.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_SearchParameter", "description" : "SearchParameter: Update Existing", "status" : "pass", "message" : "Updated existing SearchParameter.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_SearchParameter", "description" : "SearchParameter: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_SearchParameter", "description" : "SearchParameter: Version read existing", "status" : "pass", "message" : "Read current version of preexisting SearchParameter.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_SearchParameter", "description" : "SearchParameter: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting SearchParameter.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_SearchParameter", "description" : "SearchParameter: Validate", "status" : "pass", "message" : "SearchParameter was validated.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_SearchParameter", "description" : "SearchParameter: Validate Existing", "status" : "pass", "message" : "Existing SearchParameter was validated.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_SearchParameter", "description" : "SearchParameter: Validate against a profile", "status" : "pass", "message" : "SearchParameter was validated.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_SearchParameter", "description" : "SearchParameter: Delete Existing", "status" : "pass", "message" : "Existing SearchParameter was deleted.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_SearchParameter", "description" : "SearchParameter: Get Deleted Resource", "status" : "pass", "message" : "Deleted SearchParameter was correctly reported as gone.", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:49:25.588-0400" }, "created_at" : { "$date" : "2015-10-02T18:49:25.588-0400" } }
,{ "_id" : { "$oid" : "560f09fd4d4d3266f8f20200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0504d4d3261a65d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Slot", "description" : "Slot: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Slot", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Slot", "description" : "Slot: Create New", "status" : "pass", "message" : "New Slot was created.", "validates" : [ { "resource" : "Slot", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Slot", "description" : "Slot: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Slot.", "validates" : [ { "resource" : "Slot", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Slot", "description" : "Slot: Update Existing", "status" : "pass", "message" : "Updated existing Slot.", "validates" : [ { "resource" : "Slot", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Slot", "description" : "Slot: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Slot", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Slot", "description" : "Slot: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Slot.", "validates" : [ { "resource" : "Slot", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Slot", "description" : "Slot: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Slot.", "validates" : [ { "resource" : "Slot", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Slot", "description" : "Slot: Validate", "status" : "pass", "message" : "Slot was validated.", "validates" : [ { "resource" : "Slot", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Slot", "description" : "Slot: Validate Existing", "status" : "pass", "message" : "Existing Slot was validated.", "validates" : [ { "resource" : "Slot", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Slot", "description" : "Slot: Validate against a profile", "status" : "pass", "message" : "Slot was validated.", "validates" : [ { "resource" : "Slot", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Slot", "description" : "Slot: Delete Existing", "status" : "pass", "message" : "Existing Slot was deleted.", "validates" : [ { "resource" : "Slot", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Slot", "description" : "Slot: Get Deleted Resource", "status" : "pass", "message" : "Deleted Slot was correctly reported as gone.", "validates" : [ { "resource" : "Slot", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:49:33.064-0400" }, "created_at" : { "$date" : "2015-10-02T18:49:33.064-0400" } }
,{ "_id" : { "$oid" : "560f0a044d4d3266f8f30200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0504d4d3261a65e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Specimen", "description" : "Specimen: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Specimen", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Specimen", "description" : "Specimen: Create New", "status" : "pass", "message" : "New Specimen was created.", "validates" : [ { "resource" : "Specimen", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Specimen", "description" : "Specimen: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Specimen.", "validates" : [ { "resource" : "Specimen", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Specimen", "description" : "Specimen: Update Existing", "status" : "pass", "message" : "Updated existing Specimen.", "validates" : [ { "resource" : "Specimen", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Specimen", "description" : "Specimen: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Specimen", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Specimen", "description" : "Specimen: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Specimen.", "validates" : [ { "resource" : "Specimen", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Specimen", "description" : "Specimen: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Specimen.", "validates" : [ { "resource" : "Specimen", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Specimen", "description" : "Specimen: Validate", "status" : "pass", "message" : "Specimen was validated.", "validates" : [ { "resource" : "Specimen", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Specimen", "description" : "Specimen: Validate Existing", "status" : "pass", "message" : "Existing Specimen was validated.", "validates" : [ { "resource" : "Specimen", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Specimen", "description" : "Specimen: Validate against a profile", "status" : "pass", "message" : "Specimen was validated.", "validates" : [ { "resource" : "Specimen", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Specimen", "description" : "Specimen: Delete Existing", "status" : "pass", "message" : "Existing Specimen was deleted.", "validates" : [ { "resource" : "Specimen", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Specimen", "description" : "Specimen: Get Deleted Resource", "status" : "pass", "message" : "Deleted Specimen was correctly reported as gone.", "validates" : [ { "resource" : "Specimen", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:49:40.899-0400" }, "created_at" : { "$date" : "2015-10-02T18:49:40.899-0400" } }
,{ "_id" : { "$oid" : "560f0a3f4d4d3266f8f40200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0504d4d3261a65f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_StructureDefinition", "description" : "StructureDefinition: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_StructureDefinition", "description" : "StructureDefinition: Create New", "status" : "pass", "message" : "New StructureDefinition was created.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_StructureDefinition", "description" : "StructureDefinition: Read Existing", "status" : "pass", "message" : "Successfully read preexisting StructureDefinition.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_StructureDefinition", "description" : "StructureDefinition: Update Existing", "status" : "pass", "message" : "Updated existing StructureDefinition.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_StructureDefinition", "description" : "StructureDefinition: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_StructureDefinition", "description" : "StructureDefinition: Version read existing", "status" : "pass", "message" : "Read current version of preexisting StructureDefinition.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_StructureDefinition", "description" : "StructureDefinition: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting StructureDefinition.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_StructureDefinition", "description" : "StructureDefinition: Validate", "status" : "pass", "message" : "StructureDefinition was validated.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_StructureDefinition", "description" : "StructureDefinition: Validate Existing", "status" : "pass", "message" : "Existing StructureDefinition was validated.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_StructureDefinition", "description" : "StructureDefinition: Validate against a profile", "status" : "pass", "message" : "StructureDefinition was validated.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_StructureDefinition", "description" : "StructureDefinition: Delete Existing", "status" : "pass", "message" : "Existing StructureDefinition was deleted.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_StructureDefinition", "description" : "StructureDefinition: Get Deleted Resource", "status" : "pass", "message" : "Deleted StructureDefinition was correctly reported as gone.", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:50:39.111-0400" }, "created_at" : { "$date" : "2015-10-02T18:50:39.111-0400" } }
,{ "_id" : { "$oid" : "560f0a444d4d3266f8f50200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0504d4d3261a6600000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Subscription", "description" : "Subscription: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Subscription", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Subscription", "description" : "Subscription: Create New", "status" : "pass", "message" : "New Subscription was created.", "validates" : [ { "resource" : "Subscription", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Subscription", "description" : "Subscription: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Subscription.", "validates" : [ { "resource" : "Subscription", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Subscription", "description" : "Subscription: Update Existing", "status" : "pass", "message" : "Updated existing Subscription.", "validates" : [ { "resource" : "Subscription", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Subscription", "description" : "Subscription: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Subscription", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Subscription", "description" : "Subscription: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Subscription.", "validates" : [ { "resource" : "Subscription", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Subscription", "description" : "Subscription: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Subscription.", "validates" : [ { "resource" : "Subscription", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Subscription", "description" : "Subscription: Validate", "status" : "pass", "message" : "Subscription was validated.", "validates" : [ { "resource" : "Subscription", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Subscription", "description" : "Subscription: Validate Existing", "status" : "pass", "message" : "Existing Subscription was validated.", "validates" : [ { "resource" : "Subscription", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Subscription", "description" : "Subscription: Validate against a profile", "status" : "pass", "message" : "Subscription was validated.", "validates" : [ { "resource" : "Subscription", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Subscription", "description" : "Subscription: Delete Existing", "status" : "pass", "message" : "Existing Subscription was deleted.", "validates" : [ { "resource" : "Subscription", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Subscription", "description" : "Subscription: Get Deleted Resource", "status" : "pass", "message" : "Deleted Subscription was correctly reported as gone.", "validates" : [ { "resource" : "Subscription", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:50:44.846-0400" }, "created_at" : { "$date" : "2015-10-02T18:50:44.846-0400" } }
,{ "_id" : { "$oid" : "560f0a4b4d4d3266f8f60200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0504d4d3261a6610000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Substance", "description" : "Substance: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Substance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Substance", "description" : "Substance: Create New", "status" : "pass", "message" : "New Substance was created.", "validates" : [ { "resource" : "Substance", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Substance", "description" : "Substance: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Substance.", "validates" : [ { "resource" : "Substance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Substance", "description" : "Substance: Update Existing", "status" : "pass", "message" : "Updated existing Substance.", "validates" : [ { "resource" : "Substance", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Substance", "description" : "Substance: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Substance", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Substance", "description" : "Substance: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Substance.", "validates" : [ { "resource" : "Substance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Substance", "description" : "Substance: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Substance.", "validates" : [ { "resource" : "Substance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Substance", "description" : "Substance: Validate", "status" : "pass", "message" : "Substance was validated.", "validates" : [ { "resource" : "Substance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Substance", "description" : "Substance: Validate Existing", "status" : "pass", "message" : "Existing Substance was validated.", "validates" : [ { "resource" : "Substance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Substance", "description" : "Substance: Validate against a profile", "status" : "pass", "message" : "Substance was validated.", "validates" : [ { "resource" : "Substance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Substance", "description" : "Substance: Delete Existing", "status" : "pass", "message" : "Existing Substance was deleted.", "validates" : [ { "resource" : "Substance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Substance", "description" : "Substance: Get Deleted Resource", "status" : "pass", "message" : "Deleted Substance was correctly reported as gone.", "validates" : [ { "resource" : "Substance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:50:51.061-0400" }, "created_at" : { "$date" : "2015-10-02T18:50:51.061-0400" } }
,{ "_id" : { "$oid" : "560f0a514d4d3266f8f70200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0504d4d3261a6620000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_SupplyDelivery", "description" : "SupplyDelivery: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_SupplyDelivery", "description" : "SupplyDelivery: Create New", "status" : "pass", "message" : "New SupplyDelivery was created.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_SupplyDelivery", "description" : "SupplyDelivery: Read Existing", "status" : "pass", "message" : "Successfully read preexisting SupplyDelivery.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_SupplyDelivery", "description" : "SupplyDelivery: Update Existing", "status" : "pass", "message" : "Updated existing SupplyDelivery.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_SupplyDelivery", "description" : "SupplyDelivery: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_SupplyDelivery", "description" : "SupplyDelivery: Version read existing", "status" : "pass", "message" : "Read current version of preexisting SupplyDelivery.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_SupplyDelivery", "description" : "SupplyDelivery: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting SupplyDelivery.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_SupplyDelivery", "description" : "SupplyDelivery: Validate", "status" : "pass", "message" : "SupplyDelivery was validated.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_SupplyDelivery", "description" : "SupplyDelivery: Validate Existing", "status" : "pass", "message" : "Existing SupplyDelivery was validated.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_SupplyDelivery", "description" : "SupplyDelivery: Validate against a profile", "status" : "pass", "message" : "SupplyDelivery was validated.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_SupplyDelivery", "description" : "SupplyDelivery: Delete Existing", "status" : "pass", "message" : "Existing SupplyDelivery was deleted.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_SupplyDelivery", "description" : "SupplyDelivery: Get Deleted Resource", "status" : "pass", "message" : "Deleted SupplyDelivery was correctly reported as gone.", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:50:57.646-0400" }, "created_at" : { "$date" : "2015-10-02T18:50:57.646-0400" } }
,{ "_id" : { "$oid" : "560f0a594d4d3266f8f80200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0504d4d3261a6630000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_SupplyRequest", "description" : "SupplyRequest: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_SupplyRequest", "description" : "SupplyRequest: Create New", "status" : "pass", "message" : "New SupplyRequest was created.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_SupplyRequest", "description" : "SupplyRequest: Read Existing", "status" : "pass", "message" : "Successfully read preexisting SupplyRequest.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_SupplyRequest", "description" : "SupplyRequest: Update Existing", "status" : "pass", "message" : "Updated existing SupplyRequest.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_SupplyRequest", "description" : "SupplyRequest: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_SupplyRequest", "description" : "SupplyRequest: Version read existing", "status" : "pass", "message" : "Read current version of preexisting SupplyRequest.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_SupplyRequest", "description" : "SupplyRequest: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting SupplyRequest.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_SupplyRequest", "description" : "SupplyRequest: Validate", "status" : "pass", "message" : "SupplyRequest was validated.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_SupplyRequest", "description" : "SupplyRequest: Validate Existing", "status" : "pass", "message" : "Existing SupplyRequest was validated.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_SupplyRequest", "description" : "SupplyRequest: Validate against a profile", "status" : "pass", "message" : "SupplyRequest was validated.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_SupplyRequest", "description" : "SupplyRequest: Delete Existing", "status" : "pass", "message" : "Existing SupplyRequest was deleted.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_SupplyRequest", "description" : "SupplyRequest: Get Deleted Resource", "status" : "pass", "message" : "Deleted SupplyRequest was correctly reported as gone.", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:51:05.940-0400" }, "created_at" : { "$date" : "2015-10-02T18:51:05.940-0400" } }
,{ "_id" : { "$oid" : "560f0a654d4d3266f8f90200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6640000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_TestScript", "description" : "TestScript: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "TestScript", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_TestScript", "description" : "TestScript: Create New", "status" : "pass", "message" : "New TestScript was created.", "validates" : [ { "resource" : "TestScript", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_TestScript", "description" : "TestScript: Read Existing", "status" : "pass", "message" : "Successfully read preexisting TestScript.", "validates" : [ { "resource" : "TestScript", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_TestScript", "description" : "TestScript: Update Existing", "status" : "pass", "message" : "Updated existing TestScript.", "validates" : [ { "resource" : "TestScript", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_TestScript", "description" : "TestScript: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "TestScript", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_TestScript", "description" : "TestScript: Version read existing", "status" : "pass", "message" : "Read current version of preexisting TestScript.", "validates" : [ { "resource" : "TestScript", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_TestScript", "description" : "TestScript: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting TestScript.", "validates" : [ { "resource" : "TestScript", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_TestScript", "description" : "TestScript: Validate", "status" : "pass", "message" : "TestScript was validated.", "validates" : [ { "resource" : "TestScript", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_TestScript", "description" : "TestScript: Validate Existing", "status" : "pass", "message" : "Existing TestScript was validated.", "validates" : [ { "resource" : "TestScript", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_TestScript", "description" : "TestScript: Validate against a profile", "status" : "pass", "message" : "TestScript was validated.", "validates" : [ { "resource" : "TestScript", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_TestScript", "description" : "TestScript: Delete Existing", "status" : "pass", "message" : "Existing TestScript was deleted.", "validates" : [ { "resource" : "TestScript", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_TestScript", "description" : "TestScript: Get Deleted Resource", "status" : "pass", "message" : "Deleted TestScript was correctly reported as gone.", "validates" : [ { "resource" : "TestScript", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:51:17.907-0400" }, "created_at" : { "$date" : "2015-10-02T18:51:17.907-0400" } }
,{ "_id" : { "$oid" : "560f0a734d4d3266f8fa0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6650000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_ValueSet", "description" : "ValueSet: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ValueSet", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_ValueSet", "description" : "ValueSet: Create New", "status" : "pass", "message" : "New ValueSet was created.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_ValueSet", "description" : "ValueSet: Read Existing", "status" : "pass", "message" : "Successfully read preexisting ValueSet.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_ValueSet", "description" : "ValueSet: Update Existing", "status" : "pass", "message" : "Updated existing ValueSet.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_ValueSet", "description" : "ValueSet: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_ValueSet", "description" : "ValueSet: Version read existing", "status" : "pass", "message" : "Read current version of preexisting ValueSet.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_ValueSet", "description" : "ValueSet: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting ValueSet.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_ValueSet", "description" : "ValueSet: Validate", "status" : "pass", "message" : "ValueSet was validated.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_ValueSet", "description" : "ValueSet: Validate Existing", "status" : "pass", "message" : "Existing ValueSet was validated.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_ValueSet", "description" : "ValueSet: Validate against a profile", "status" : "pass", "message" : "ValueSet was validated.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_ValueSet", "description" : "ValueSet: Delete Existing", "status" : "pass", "message" : "Existing ValueSet was deleted.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_ValueSet", "description" : "ValueSet: Get Deleted Resource", "status" : "pass", "message" : "Deleted ValueSet was correctly reported as gone.", "validates" : [ { "resource" : "ValueSet", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:51:31.238-0400" }, "created_at" : { "$date" : "2015-10-02T18:51:31.238-0400" } }
,{ "_id" : { "$oid" : "560f0a7b4d4d3266f8fb0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6660000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_VisionPrescription", "description" : "VisionPrescription: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_VisionPrescription", "description" : "VisionPrescription: Create New", "status" : "pass", "message" : "New VisionPrescription was created.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_VisionPrescription", "description" : "VisionPrescription: Read Existing", "status" : "pass", "message" : "Successfully read preexisting VisionPrescription.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_VisionPrescription", "description" : "VisionPrescription: Update Existing", "status" : "pass", "message" : "Updated existing VisionPrescription.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_VisionPrescription", "description" : "VisionPrescription: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_VisionPrescription", "description" : "VisionPrescription: Version read existing", "status" : "pass", "message" : "Read current version of preexisting VisionPrescription.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_VisionPrescription", "description" : "VisionPrescription: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting VisionPrescription.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_VisionPrescription", "description" : "VisionPrescription: Validate", "status" : "pass", "message" : "VisionPrescription was validated.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_VisionPrescription", "description" : "VisionPrescription: Validate Existing", "status" : "pass", "message" : "Existing VisionPrescription was validated.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_VisionPrescription", "description" : "VisionPrescription: Validate against a profile", "status" : "pass", "message" : "VisionPrescription was validated.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_VisionPrescription", "description" : "VisionPrescription: Delete Existing", "status" : "pass", "message" : "Existing VisionPrescription was deleted.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_VisionPrescription", "description" : "VisionPrescription: Get Deleted Resource", "status" : "pass", "message" : "Deleted VisionPrescription was correctly reported as gone.", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:51:39.730-0400" }, "created_at" : { "$date" : "2015-10-02T18:51:39.730-0400" } }
,{ "_id" : { "$oid" : "560f0a984d4d3266f8fe0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0554d4d3261a6c40000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "SR01P", "id" : "SR01P", "description" : "Patient Matching using an MPI (POST)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] }, { "extensions" : [ "extensions" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient.html#match" ], "code" : "      test \"SR01#{action[0]}\",\"Patient Matching using an MPI (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient.html#match\"\n          validates resource: 'Patient', methods: ['search']\n          validates extensions: ['extensions']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_query' => 'mpi',\n              'given' => @patient.name[0].given[0]\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)        \n \n        has_mpi_data = true\n        has_score = true\n        reply.resource.entry.each do |entry|\n          has_score = has_score && entry.try(:search).try(:score)\n          entry_has_mpi_data = false\n          if entry.search\n            entry.search.extension.each do |e|\n              if (e.url=='http://hl7.org/fhir/StructureDefinition/patient-mpi-match' && e.value && e.value.type=='code' && ['certain','probable','possible','certainly-not'].include?(e.value.value))\n                entry_has_mpi_data = true\n              end\n            end\n          end\n          has_mpi_data = has_mpi_data && entry_has_mpi_data\n        end\n        assert( has_score && has_mpi_data, \"Every Patient Matching result requires a score and 'patient-mpi-match' extension.\", reply.body)\n      end\n", "test_method" : "sr01p_patient_matching_using_an_mpi_(post)_test" }, { "key" : "SR01G", "id" : "SR01G", "description" : "Patient Matching using an MPI (GET)", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] }, { "extensions" : [ "extensions" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient.html#match" ], "code" : "      test \"SR01#{action[0]}\",\"Patient Matching using an MPI (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/patient.html#match\"\n          validates resource: 'Patient', methods: ['search']\n          validates extensions: ['extensions']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_query' => 'mpi',\n              'given' => @patient.name[0].given[0]\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)        \n \n        has_mpi_data = true\n        has_score = true\n        reply.resource.entry.each do |entry|\n          has_score = has_score && entry.try(:search).try(:score)\n          entry_has_mpi_data = false\n          if entry.search\n            entry.search.extension.each do |e|\n              if (e.url=='http://hl7.org/fhir/StructureDefinition/patient-mpi-match' && e.value && e.value.type=='code' && ['certain','probable','possible','certainly-not'].include?(e.value.value))\n                entry_has_mpi_data = true\n              end\n            end\n          end\n          has_mpi_data = has_mpi_data && entry_has_mpi_data\n        end\n        assert( has_score && has_mpi_data, \"Every Patient Matching result requires a score and 'patient-mpi-match' extension.\", reply.body)\n      end\n", "test_method" : "sr01g_patient_matching_using_an_mpi_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:08.973-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:08.973-0400" } }
,{ "_id" : { "$oid" : "560f0aa14d4d3266f8ff0200" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6670000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Account", "description" : "Compare supported search parameters with specification Account", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Account", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Account", "description" : "Search by ID (POST) Account", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Account", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Account", "description" : "Search limit by _count (POST) Account", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Account", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Account", "description" : "Search without criteria (POST) Account", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Account", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/account.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Account", "description" : "Search by ID (GET) Account", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Account", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Account", "description" : "Search limit by _count (GET) Account", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Account", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Account", "description" : "Search without criteria (GET) Account", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Account", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/account.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:17.776-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:17.776-0400" } }
,{ "_id" : { "$oid" : "560f0aa54d4d3266f8000300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6680000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_AllergyIntolerance", "description" : "Compare supported search parameters with specification AllergyIntolerance", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_AllergyIntolerance", "description" : "Search by ID (POST) AllergyIntolerance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_AllergyIntolerance", "description" : "Search limit by _count (POST) AllergyIntolerance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_AllergyIntolerance", "description" : "Search without criteria (POST) AllergyIntolerance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/allergyintolerance.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_AllergyIntolerance", "description" : "Search by ID (GET) AllergyIntolerance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_AllergyIntolerance", "description" : "Search limit by _count (GET) AllergyIntolerance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_AllergyIntolerance", "description" : "Search without criteria (GET) AllergyIntolerance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/allergyintolerance.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:21.321-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:21.321-0400" } }
,{ "_id" : { "$oid" : "560f0aa84d4d3266f8010300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6690000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Appointment", "description" : "Compare supported search parameters with specification Appointment", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Appointment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Appointment", "description" : "Search by ID (POST) Appointment", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Appointment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Appointment", "description" : "Search limit by _count (POST) Appointment", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Appointment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Appointment", "description" : "Search without criteria (POST) Appointment", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Appointment", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/appointment.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Appointment", "description" : "Search by ID (GET) Appointment", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Appointment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Appointment", "description" : "Search limit by _count (GET) Appointment", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Appointment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Appointment", "description" : "Search without criteria (GET) Appointment", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Appointment", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/appointment.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:24.255-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:24.255-0400" } }
,{ "_id" : { "$oid" : "560f0aaa4d4d3266f8020300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a66a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_AppointmentResponse", "description" : "Compare supported search parameters with specification AppointmentResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_AppointmentResponse", "description" : "Search by ID (POST) AppointmentResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_AppointmentResponse", "description" : "Search limit by _count (POST) AppointmentResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_AppointmentResponse", "description" : "Search without criteria (POST) AppointmentResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/appointmentresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_AppointmentResponse", "description" : "Search by ID (GET) AppointmentResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_AppointmentResponse", "description" : "Search limit by _count (GET) AppointmentResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_AppointmentResponse", "description" : "Search without criteria (GET) AppointmentResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/appointmentresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:26.911-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:26.911-0400" } }
,{ "_id" : { "$oid" : "560f0ab14d4d3266f8030300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a66b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_AuditEvent", "description" : "Compare supported search parameters with specification AuditEvent", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_AuditEvent", "description" : "Search by ID (POST) AuditEvent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_AuditEvent", "description" : "Search limit by _count (POST) AuditEvent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_AuditEvent", "description" : "Search without criteria (POST) AuditEvent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/auditevent.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_AuditEvent", "description" : "Search by ID (GET) AuditEvent", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_AuditEvent", "description" : "Search limit by _count (GET) AuditEvent", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AuditEvent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_AuditEvent", "description" : "Search without criteria (GET) AuditEvent", "status" : "fail", "message" : "Searching without criteria did not return all the results. Expected: 5831, but found: 5830.", "data" : null, "validates" : [ { "resource" : "AuditEvent", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/auditevent.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:33.833-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:33.833-0400" } }
,{ "_id" : { "$oid" : "560f0ab74d4d3266f8040300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a66c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Basic", "description" : "Compare supported search parameters with specification Basic", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Basic", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Basic", "description" : "Search by ID (POST) Basic", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Basic", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Basic", "description" : "Search limit by _count (POST) Basic", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Basic", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Basic", "description" : "Search without criteria (POST) Basic", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Basic", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/basic.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Basic", "description" : "Search by ID (GET) Basic", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Basic", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Basic", "description" : "Search limit by _count (GET) Basic", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Basic", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Basic", "description" : "Search without criteria (GET) Basic", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Basic", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/basic.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:39.459-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:39.459-0400" } }
,{ "_id" : { "$oid" : "560f0ab94d4d3266f8050300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a66d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Binary", "description" : "Compare supported search parameters with specification Binary", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Binary", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Binary", "description" : "Search by ID (POST) Binary", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Binary", "description" : "Search limit by _count (POST) Binary", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Binary", "description" : "Search without criteria (POST) Binary", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/binary.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Binary", "description" : "Search by ID (GET) Binary", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "Binary", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Binary", "description" : "Search limit by _count (GET) Binary", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "Binary", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Binary", "description" : "Search without criteria (GET) Binary", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 400. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "Binary", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/binary.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:41.993-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:41.993-0400" } }
,{ "_id" : { "$oid" : "560f0abd4d4d3266f8060300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a66e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_BodySite", "description" : "Compare supported search parameters with specification BodySite", "status" : "pass", "message" : null, "validates" : [ { "resource" : "BodySite", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_BodySite", "description" : "Search by ID (POST) BodySite", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "BodySite", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_BodySite", "description" : "Search limit by _count (POST) BodySite", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "BodySite", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_BodySite", "description" : "Search without criteria (POST) BodySite", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "BodySite", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/bodysite.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_BodySite", "description" : "Search by ID (GET) BodySite", "status" : "pass", "message" : null, "validates" : [ { "resource" : "BodySite", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_BodySite", "description" : "Search limit by _count (GET) BodySite", "status" : "pass", "message" : null, "validates" : [ { "resource" : "BodySite", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bodysite.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_BodySite", "description" : "Search without criteria (GET) BodySite", "status" : "pass", "message" : null, "validates" : [ { "resource" : "BodySite", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/bodysite.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:45.662-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:45.662-0400" } }
,{ "_id" : { "$oid" : "560f0ac04d4d3266f8070300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a66f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Bundle", "description" : "Compare supported search parameters with specification Bundle", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Bundle", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Bundle", "description" : "Search by ID (POST) Bundle", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Bundle", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Bundle", "description" : "Search limit by _count (POST) Bundle", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Bundle", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Bundle", "description" : "Search without criteria (POST) Bundle", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Bundle", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/bundle.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Bundle", "description" : "Search by ID (GET) Bundle", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Bundle", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Bundle", "description" : "Search limit by _count (GET) Bundle", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Bundle", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/bundle.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Bundle", "description" : "Search without criteria (GET) Bundle", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Bundle", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/bundle.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:48.513-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:48.513-0400" } }
,{ "_id" : { "$oid" : "560f0ac84d4d3266f8080300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6700000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_CarePlan", "description" : "Compare supported search parameters with specification CarePlan", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "CarePlan", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_CarePlan", "description" : "Search by ID (POST) CarePlan", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "CarePlan", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_CarePlan", "description" : "Search limit by _count (POST) CarePlan", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "CarePlan", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_CarePlan", "description" : "Search without criteria (POST) CarePlan", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "CarePlan", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/careplan.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_CarePlan", "description" : "Search by ID (GET) CarePlan", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CarePlan", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_CarePlan", "description" : "Search limit by _count (GET) CarePlan", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CarePlan", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/careplan.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_CarePlan", "description" : "Search without criteria (GET) CarePlan", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CarePlan", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/careplan.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:52:56.512-0400" }, "created_at" : { "$date" : "2015-10-02T18:52:56.512-0400" } }
,{ "_id" : { "$oid" : "560f0ace4d4d3266f8090300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6710000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Claim", "description" : "Compare supported search parameters with specification Claim", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Claim", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Claim", "description" : "Search by ID (POST) Claim", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Claim", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Claim", "description" : "Search limit by _count (POST) Claim", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Claim", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Claim", "description" : "Search without criteria (POST) Claim", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Claim", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/claim.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Claim", "description" : "Search by ID (GET) Claim", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Claim", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Claim", "description" : "Search limit by _count (GET) Claim", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Claim", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claim.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Claim", "description" : "Search without criteria (GET) Claim", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Claim", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/claim.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:02.518-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:02.518-0400" } }
,{ "_id" : { "$oid" : "560f0ad14d4d3266f80a0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6720000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ClaimResponse", "description" : "Compare supported search parameters with specification ClaimResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ClaimResponse", "description" : "Search by ID (POST) ClaimResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ClaimResponse", "description" : "Search limit by _count (POST) ClaimResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ClaimResponse", "description" : "Search without criteria (POST) ClaimResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/claimresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ClaimResponse", "description" : "Search by ID (GET) ClaimResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ClaimResponse", "description" : "Search limit by _count (GET) ClaimResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/claimresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ClaimResponse", "description" : "Search without criteria (GET) ClaimResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClaimResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/claimresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:05.455-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:05.455-0400" } }
,{ "_id" : { "$oid" : "560f0ad44d4d3266f80b0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6730000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ClinicalImpression", "description" : "Compare supported search parameters with specification ClinicalImpression", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ClinicalImpression", "description" : "Search by ID (POST) ClinicalImpression", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ClinicalImpression", "description" : "Search limit by _count (POST) ClinicalImpression", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ClinicalImpression", "description" : "Search without criteria (POST) ClinicalImpression", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/clinicalimpression.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ClinicalImpression", "description" : "Search by ID (GET) ClinicalImpression", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ClinicalImpression", "description" : "Search limit by _count (GET) ClinicalImpression", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/clinicalimpression.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ClinicalImpression", "description" : "Search without criteria (GET) ClinicalImpression", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ClinicalImpression", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/clinicalimpression.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:08.932-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:08.932-0400" } }
,{ "_id" : { "$oid" : "560f0ad84d4d3266f80c0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6740000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Communication", "description" : "Compare supported search parameters with specification Communication", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Communication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Communication", "description" : "Search by ID (POST) Communication", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Communication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Communication", "description" : "Search limit by _count (POST) Communication", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Communication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Communication", "description" : "Search without criteria (POST) Communication", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Communication", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/communication.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Communication", "description" : "Search by ID (GET) Communication", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Communication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Communication", "description" : "Search limit by _count (GET) Communication", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Communication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communication.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Communication", "description" : "Search without criteria (GET) Communication", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Communication", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/communication.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:12.143-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:12.143-0400" } }
,{ "_id" : { "$oid" : "560f0adb4d4d3266f80d0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0514d4d3261a6750000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_CommunicationRequest", "description" : "Compare supported search parameters with specification CommunicationRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_CommunicationRequest", "description" : "Search by ID (POST) CommunicationRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_CommunicationRequest", "description" : "Search limit by _count (POST) CommunicationRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_CommunicationRequest", "description" : "Search without criteria (POST) CommunicationRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/communicationrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_CommunicationRequest", "description" : "Search by ID (GET) CommunicationRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_CommunicationRequest", "description" : "Search limit by _count (GET) CommunicationRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/communicationrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_CommunicationRequest", "description" : "Search without criteria (GET) CommunicationRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "CommunicationRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/communicationrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:15.403-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:15.403-0400" } }
,{ "_id" : { "$oid" : "560f0ade4d4d3266f80e0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6760000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Composition", "description" : "Compare supported search parameters with specification Composition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Composition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Composition", "description" : "Search by ID (POST) Composition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Composition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Composition", "description" : "Search limit by _count (POST) Composition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Composition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Composition", "description" : "Search without criteria (POST) Composition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Composition", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/composition.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Composition", "description" : "Search by ID (GET) Composition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Composition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Composition", "description" : "Search limit by _count (GET) Composition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Composition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/composition.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Composition", "description" : "Search without criteria (GET) Composition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Composition", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/composition.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:18.317-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:18.317-0400" } }
,{ "_id" : { "$oid" : "560f0ae94d4d3266f80f0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6770000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ConceptMap", "description" : "Compare supported search parameters with specification ConceptMap", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ConceptMap", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ConceptMap", "description" : "Search by ID (POST) ConceptMap", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ConceptMap", "description" : "Search limit by _count (POST) ConceptMap", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ConceptMap", "description" : "Search without criteria (POST) ConceptMap", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ConceptMap", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/conceptmap.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ConceptMap", "description" : "Search by ID (GET) ConceptMap", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ConceptMap", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ConceptMap", "description" : "Search limit by _count (GET) ConceptMap", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ConceptMap", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conceptmap.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ConceptMap", "description" : "Search without criteria (GET) ConceptMap", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ConceptMap", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/conceptmap.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:29.936-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:29.936-0400" } }
,{ "_id" : { "$oid" : "560f0aee4d4d3266f8100300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6780000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Condition", "description" : "Compare supported search parameters with specification Condition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Condition", "description" : "Search by ID (POST) Condition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Condition", "description" : "Search limit by _count (POST) Condition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Condition", "description" : "Search without criteria (POST) Condition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/condition.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Condition", "description" : "Search by ID (GET) Condition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Condition", "description" : "Search limit by _count (GET) Condition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/condition.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Condition", "description" : "Search without criteria (GET) Condition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/condition.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:34.868-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:34.868-0400" } }
,{ "_id" : { "$oid" : "560f0af14d4d3266f8110300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6790000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Conformance", "description" : "Compare supported search parameters with specification Conformance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Conformance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Conformance", "description" : "Search by ID (POST) Conformance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Conformance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Conformance", "description" : "Search limit by _count (POST) Conformance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Conformance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Conformance", "description" : "Search without criteria (POST) Conformance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Conformance", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/conformance.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Conformance", "description" : "Search by ID (GET) Conformance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Conformance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Conformance", "description" : "Search limit by _count (GET) Conformance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Conformance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/conformance.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Conformance", "description" : "Search without criteria (GET) Conformance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Conformance", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/conformance.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:37.698-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:37.698-0400" } }
,{ "_id" : { "$oid" : "560f0af44d4d3266f8120300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a67a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Contract", "description" : "Compare supported search parameters with specification Contract", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Contract", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Contract", "description" : "Search by ID (POST) Contract", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Contract", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Contract", "description" : "Search limit by _count (POST) Contract", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Contract", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Contract", "description" : "Search without criteria (POST) Contract", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Contract", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/contract.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Contract", "description" : "Search by ID (GET) Contract", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Contract", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Contract", "description" : "Search limit by _count (GET) Contract", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Contract", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/contract.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Contract", "description" : "Search without criteria (GET) Contract", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Contract", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/contract.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:40.772-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:40.772-0400" } }
,{ "_id" : { "$oid" : "560f0af84d4d3266f8130300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a67b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Coverage", "description" : "Compare supported search parameters with specification Coverage", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Coverage", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Coverage", "description" : "Search by ID (POST) Coverage", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Coverage", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Coverage", "description" : "Search limit by _count (POST) Coverage", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Coverage", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Coverage", "description" : "Search without criteria (POST) Coverage", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Coverage", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/coverage.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Coverage", "description" : "Search by ID (GET) Coverage", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Coverage", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Coverage", "description" : "Search limit by _count (GET) Coverage", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Coverage", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/coverage.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Coverage", "description" : "Search without criteria (GET) Coverage", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Coverage", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/coverage.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:44.061-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:44.061-0400" } }
,{ "_id" : { "$oid" : "560f0afd4d4d3266f8140300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a67c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DataElement", "description" : "Compare supported search parameters with specification DataElement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DataElement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DataElement", "description" : "Search by ID (POST) DataElement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DataElement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DataElement", "description" : "Search limit by _count (POST) DataElement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DataElement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DataElement", "description" : "Search without criteria (POST) DataElement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DataElement", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/dataelement.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DataElement", "description" : "Search by ID (GET) DataElement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DataElement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DataElement", "description" : "Search limit by _count (GET) DataElement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DataElement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/dataelement.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DataElement", "description" : "Search without criteria (GET) DataElement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DataElement", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/dataelement.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:49.856-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:49.856-0400" } }
,{ "_id" : { "$oid" : "560f0b014d4d3266f8150300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a67d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DetectedIssue", "description" : "Compare supported search parameters with specification DetectedIssue", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DetectedIssue", "description" : "Search by ID (POST) DetectedIssue", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DetectedIssue", "description" : "Search limit by _count (POST) DetectedIssue", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DetectedIssue", "description" : "Search without criteria (POST) DetectedIssue", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/detectedissue.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DetectedIssue", "description" : "Search by ID (GET) DetectedIssue", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DetectedIssue", "description" : "Search limit by _count (GET) DetectedIssue", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/detectedissue.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DetectedIssue", "description" : "Search without criteria (GET) DetectedIssue", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DetectedIssue", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/detectedissue.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:53.414-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:53.414-0400" } }
,{ "_id" : { "$oid" : "560f0b044d4d3266f8160300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a67e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Device", "description" : "Compare supported search parameters with specification Device", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Device", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Device", "description" : "Search by ID (POST) Device", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Device", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Device", "description" : "Search limit by _count (POST) Device", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Device", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Device", "description" : "Search without criteria (POST) Device", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Device", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/device.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Device", "description" : "Search by ID (GET) Device", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Device", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Device", "description" : "Search limit by _count (GET) Device", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Device", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/device.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Device", "description" : "Search without criteria (GET) Device", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Device", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/device.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:56.604-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:56.604-0400" } }
,{ "_id" : { "$oid" : "560f0b074d4d3266f8170300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a67f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DeviceComponent", "description" : "Compare supported search parameters with specification DeviceComponent", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DeviceComponent", "description" : "Search by ID (POST) DeviceComponent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DeviceComponent", "description" : "Search limit by _count (POST) DeviceComponent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DeviceComponent", "description" : "Search without criteria (POST) DeviceComponent", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/devicecomponent.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DeviceComponent", "description" : "Search by ID (GET) DeviceComponent", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DeviceComponent", "description" : "Search limit by _count (GET) DeviceComponent", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicecomponent.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DeviceComponent", "description" : "Search without criteria (GET) DeviceComponent", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceComponent", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/devicecomponent.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:53:59.906-0400" }, "created_at" : { "$date" : "2015-10-02T18:53:59.906-0400" } }
,{ "_id" : { "$oid" : "560f0b0b4d4d3266f8180300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6800000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DeviceMetric", "description" : "Compare supported search parameters with specification DeviceMetric", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DeviceMetric", "description" : "Search by ID (POST) DeviceMetric", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DeviceMetric", "description" : "Search limit by _count (POST) DeviceMetric", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DeviceMetric", "description" : "Search without criteria (POST) DeviceMetric", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/devicemetric.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DeviceMetric", "description" : "Search by ID (GET) DeviceMetric", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DeviceMetric", "description" : "Search limit by _count (GET) DeviceMetric", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/devicemetric.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DeviceMetric", "description" : "Search without criteria (GET) DeviceMetric", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceMetric", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/devicemetric.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:03.100-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:03.100-0400" } }
,{ "_id" : { "$oid" : "560f0b0e4d4d3266f8190300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6810000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DeviceUseRequest", "description" : "Compare supported search parameters with specification DeviceUseRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DeviceUseRequest", "description" : "Search by ID (POST) DeviceUseRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DeviceUseRequest", "description" : "Search limit by _count (POST) DeviceUseRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DeviceUseRequest", "description" : "Search without criteria (POST) DeviceUseRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/deviceuserequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DeviceUseRequest", "description" : "Search by ID (GET) DeviceUseRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DeviceUseRequest", "description" : "Search limit by _count (GET) DeviceUseRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceuserequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DeviceUseRequest", "description" : "Search without criteria (GET) DeviceUseRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/deviceuserequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:06.175-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:06.175-0400" } }
,{ "_id" : { "$oid" : "560f0b114d4d3266f81a0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6820000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DeviceUseStatement", "description" : "Compare supported search parameters with specification DeviceUseStatement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DeviceUseStatement", "description" : "Search by ID (POST) DeviceUseStatement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DeviceUseStatement", "description" : "Search limit by _count (POST) DeviceUseStatement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DeviceUseStatement", "description" : "Search without criteria (POST) DeviceUseStatement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/deviceusestatement.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DeviceUseStatement", "description" : "Search by ID (GET) DeviceUseStatement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DeviceUseStatement", "description" : "Search limit by _count (GET) DeviceUseStatement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/deviceusestatement.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DeviceUseStatement", "description" : "Search without criteria (GET) DeviceUseStatement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DeviceUseStatement", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/deviceusestatement.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:09.652-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:09.652-0400" } }
,{ "_id" : { "$oid" : "560f0b154d4d3266f81b0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6830000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DiagnosticOrder", "description" : "Compare supported search parameters with specification DiagnosticOrder", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DiagnosticOrder", "description" : "Search by ID (POST) DiagnosticOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DiagnosticOrder", "description" : "Search limit by _count (POST) DiagnosticOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DiagnosticOrder", "description" : "Search without criteria (POST) DiagnosticOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/diagnosticorder.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DiagnosticOrder", "description" : "Search by ID (GET) DiagnosticOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DiagnosticOrder", "description" : "Search limit by _count (GET) DiagnosticOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticorder.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DiagnosticOrder", "description" : "Search without criteria (GET) DiagnosticOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticOrder", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/diagnosticorder.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:13.798-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:13.798-0400" } }
,{ "_id" : { "$oid" : "560f0b1f4d4d3266f81c0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6840000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DiagnosticReport", "description" : "Compare supported search parameters with specification DiagnosticReport", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DiagnosticReport", "description" : "Search by ID (POST) DiagnosticReport", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DiagnosticReport", "description" : "Search limit by _count (POST) DiagnosticReport", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DiagnosticReport", "description" : "Search without criteria (POST) DiagnosticReport", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/diagnosticreport.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DiagnosticReport", "description" : "Search by ID (GET) DiagnosticReport", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DiagnosticReport", "description" : "Search limit by _count (GET) DiagnosticReport", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/diagnosticreport.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DiagnosticReport", "description" : "Search without criteria (GET) DiagnosticReport", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DiagnosticReport", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/diagnosticreport.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:23.091-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:23.091-0400" } }
,{ "_id" : { "$oid" : "560f0b224d4d3266f81d0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6850000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DocumentManifest", "description" : "Compare supported search parameters with specification DocumentManifest", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DocumentManifest", "description" : "Search by ID (POST) DocumentManifest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DocumentManifest", "description" : "Search limit by _count (POST) DocumentManifest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DocumentManifest", "description" : "Search without criteria (POST) DocumentManifest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/documentmanifest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DocumentManifest", "description" : "Search by ID (GET) DocumentManifest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DocumentManifest", "description" : "Search limit by _count (GET) DocumentManifest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentmanifest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DocumentManifest", "description" : "Search without criteria (GET) DocumentManifest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DocumentManifest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/documentmanifest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:26.353-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:26.353-0400" } }
,{ "_id" : { "$oid" : "560f0b254d4d3266f81e0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6860000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_DocumentReference", "description" : "Compare supported search parameters with specification DocumentReference", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "DocumentReference", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_DocumentReference", "description" : "Search by ID (POST) DocumentReference", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_DocumentReference", "description" : "Search limit by _count (POST) DocumentReference", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_DocumentReference", "description" : "Search without criteria (POST) DocumentReference", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "DocumentReference", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/documentreference.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_DocumentReference", "description" : "Search by ID (GET) DocumentReference", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DocumentReference", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_DocumentReference", "description" : "Search limit by _count (GET) DocumentReference", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DocumentReference", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/documentreference.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_DocumentReference", "description" : "Search without criteria (GET) DocumentReference", "status" : "pass", "message" : null, "validates" : [ { "resource" : "DocumentReference", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/documentreference.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:29.802-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:29.802-0400" } }
,{ "_id" : { "$oid" : "560f0b284d4d3266f81f0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6870000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_EligibilityRequest", "description" : "Compare supported search parameters with specification EligibilityRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_EligibilityRequest", "description" : "Search by ID (POST) EligibilityRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_EligibilityRequest", "description" : "Search limit by _count (POST) EligibilityRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_EligibilityRequest", "description" : "Search without criteria (POST) EligibilityRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/eligibilityrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_EligibilityRequest", "description" : "Search by ID (GET) EligibilityRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_EligibilityRequest", "description" : "Search limit by _count (GET) EligibilityRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_EligibilityRequest", "description" : "Search without criteria (GET) EligibilityRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/eligibilityrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:32.692-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:32.692-0400" } }
,{ "_id" : { "$oid" : "560f0b2c4d4d3266f8200300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6880000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_EligibilityResponse", "description" : "Compare supported search parameters with specification EligibilityResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_EligibilityResponse", "description" : "Search by ID (POST) EligibilityResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_EligibilityResponse", "description" : "Search limit by _count (POST) EligibilityResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_EligibilityResponse", "description" : "Search without criteria (POST) EligibilityResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/eligibilityresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_EligibilityResponse", "description" : "Search by ID (GET) EligibilityResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_EligibilityResponse", "description" : "Search limit by _count (GET) EligibilityResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/eligibilityresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_EligibilityResponse", "description" : "Search without criteria (GET) EligibilityResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EligibilityResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/eligibilityresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:36.230-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:36.230-0400" } }
,{ "_id" : { "$oid" : "560f0b314d4d3266f8210300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a6890000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Encounter", "description" : "Compare supported search parameters with specification Encounter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Encounter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Encounter", "description" : "Search by ID (POST) Encounter", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Encounter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Encounter", "description" : "Search limit by _count (POST) Encounter", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Encounter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Encounter", "description" : "Search without criteria (POST) Encounter", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Encounter", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/encounter.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Encounter", "description" : "Search by ID (GET) Encounter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Encounter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Encounter", "description" : "Search limit by _count (GET) Encounter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Encounter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/encounter.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Encounter", "description" : "Search without criteria (GET) Encounter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Encounter", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/encounter.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:41.521-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:41.521-0400" } }
,{ "_id" : { "$oid" : "560f0b344d4d3266f8220300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a68a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_EnrollmentRequest", "description" : "Compare supported search parameters with specification EnrollmentRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_EnrollmentRequest", "description" : "Search by ID (POST) EnrollmentRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_EnrollmentRequest", "description" : "Search limit by _count (POST) EnrollmentRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_EnrollmentRequest", "description" : "Search without criteria (POST) EnrollmentRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/enrollmentrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_EnrollmentRequest", "description" : "Search by ID (GET) EnrollmentRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_EnrollmentRequest", "description" : "Search limit by _count (GET) EnrollmentRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_EnrollmentRequest", "description" : "Search without criteria (GET) EnrollmentRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/enrollmentrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:44.455-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:44.455-0400" } }
,{ "_id" : { "$oid" : "560f0b374d4d3266f8230300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a68b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_EnrollmentResponse", "description" : "Compare supported search parameters with specification EnrollmentResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_EnrollmentResponse", "description" : "Search by ID (POST) EnrollmentResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_EnrollmentResponse", "description" : "Search limit by _count (POST) EnrollmentResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_EnrollmentResponse", "description" : "Search without criteria (POST) EnrollmentResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/enrollmentresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_EnrollmentResponse", "description" : "Search by ID (GET) EnrollmentResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_EnrollmentResponse", "description" : "Search limit by _count (GET) EnrollmentResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/enrollmentresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_EnrollmentResponse", "description" : "Search without criteria (GET) EnrollmentResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EnrollmentResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/enrollmentresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:47.246-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:47.246-0400" } }
,{ "_id" : { "$oid" : "560f0b3a4d4d3266f8240300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0524d4d3261a68c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_EpisodeOfCare", "description" : "Compare supported search parameters with specification EpisodeOfCare", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_EpisodeOfCare", "description" : "Search by ID (POST) EpisodeOfCare", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_EpisodeOfCare", "description" : "Search limit by _count (POST) EpisodeOfCare", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_EpisodeOfCare", "description" : "Search without criteria (POST) EpisodeOfCare", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/episodeofcare.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_EpisodeOfCare", "description" : "Search by ID (GET) EpisodeOfCare", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_EpisodeOfCare", "description" : "Search limit by _count (GET) EpisodeOfCare", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/episodeofcare.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_EpisodeOfCare", "description" : "Search without criteria (GET) EpisodeOfCare", "status" : "pass", "message" : null, "validates" : [ { "resource" : "EpisodeOfCare", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/episodeofcare.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:50.212-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:50.212-0400" } }
,{ "_id" : { "$oid" : "560f0b3d4d4d3266f8250300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a68d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ExplanationOfBenefit", "description" : "Compare supported search parameters with specification ExplanationOfBenefit", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ExplanationOfBenefit", "description" : "Search by ID (POST) ExplanationOfBenefit", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ExplanationOfBenefit", "description" : "Search limit by _count (POST) ExplanationOfBenefit", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ExplanationOfBenefit", "description" : "Search without criteria (POST) ExplanationOfBenefit", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/explanationofbenefit.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ExplanationOfBenefit", "description" : "Search by ID (GET) ExplanationOfBenefit", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ExplanationOfBenefit", "description" : "Search limit by _count (GET) ExplanationOfBenefit", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/explanationofbenefit.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ExplanationOfBenefit", "description" : "Search without criteria (GET) ExplanationOfBenefit", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ExplanationOfBenefit", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/explanationofbenefit.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:53.173-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:53.173-0400" } }
,{ "_id" : { "$oid" : "560f0b404d4d3266f8260300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a68e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_FamilyMemberHistory", "description" : "Compare supported search parameters with specification FamilyMemberHistory", "status" : "pass", "message" : null, "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_FamilyMemberHistory", "description" : "Search by ID (POST) FamilyMemberHistory", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_FamilyMemberHistory", "description" : "Search limit by _count (POST) FamilyMemberHistory", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_FamilyMemberHistory", "description" : "Search without criteria (POST) FamilyMemberHistory", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/familymemberhistory.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_FamilyMemberHistory", "description" : "Search by ID (GET) FamilyMemberHistory", "status" : "pass", "message" : null, "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_FamilyMemberHistory", "description" : "Search limit by _count (GET) FamilyMemberHistory", "status" : "pass", "message" : null, "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/familymemberhistory.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_FamilyMemberHistory", "description" : "Search without criteria (GET) FamilyMemberHistory", "status" : "pass", "message" : null, "validates" : [ { "resource" : "FamilyMemberHistory", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/familymemberhistory.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:56.413-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:56.413-0400" } }
,{ "_id" : { "$oid" : "560f0b434d4d3266f8270300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a68f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Flag", "description" : "Compare supported search parameters with specification Flag", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Flag", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Flag", "description" : "Search by ID (POST) Flag", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Flag", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Flag", "description" : "Search limit by _count (POST) Flag", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Flag", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Flag", "description" : "Search without criteria (POST) Flag", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Flag", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/flag.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Flag", "description" : "Search by ID (GET) Flag", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Flag", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Flag", "description" : "Search limit by _count (GET) Flag", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Flag", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/flag.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Flag", "description" : "Search without criteria (GET) Flag", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Flag", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/flag.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:54:59.743-0400" }, "created_at" : { "$date" : "2015-10-02T18:54:59.743-0400" } }
,{ "_id" : { "$oid" : "560f0b474d4d3266f8280300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6900000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Goal", "description" : "Compare supported search parameters with specification Goal", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Goal", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Goal", "description" : "Search by ID (POST) Goal", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Goal", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Goal", "description" : "Search limit by _count (POST) Goal", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Goal", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Goal", "description" : "Search without criteria (POST) Goal", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Goal", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/goal.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Goal", "description" : "Search by ID (GET) Goal", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Goal", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Goal", "description" : "Search limit by _count (GET) Goal", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Goal", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/goal.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Goal", "description" : "Search without criteria (GET) Goal", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Goal", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/goal.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:03.269-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:03.269-0400" } }
,{ "_id" : { "$oid" : "560f0b4b4d4d3266f8290300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6910000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Group", "description" : "Compare supported search parameters with specification Group", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "Group", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Group", "description" : "Search by ID (POST) Group", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Group", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Group", "description" : "Search limit by _count (POST) Group", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Group", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Group", "description" : "Search without criteria (POST) Group", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Group", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/group.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Group", "description" : "Search by ID (GET) Group", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Group", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Group", "description" : "Search limit by _count (GET) Group", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Group", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/group.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Group", "description" : "Search without criteria (GET) Group", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Group", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/group.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:07.025-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:07.025-0400" } }
,{ "_id" : { "$oid" : "560f0b4e4d4d3266f82a0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6920000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_HealthcareService", "description" : "Compare supported search parameters with specification HealthcareService", "status" : "pass", "message" : null, "validates" : [ { "resource" : "HealthcareService", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_HealthcareService", "description" : "Search by ID (POST) HealthcareService", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_HealthcareService", "description" : "Search limit by _count (POST) HealthcareService", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_HealthcareService", "description" : "Search without criteria (POST) HealthcareService", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "HealthcareService", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/healthcareservice.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_HealthcareService", "description" : "Search by ID (GET) HealthcareService", "status" : "pass", "message" : null, "validates" : [ { "resource" : "HealthcareService", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_HealthcareService", "description" : "Search limit by _count (GET) HealthcareService", "status" : "pass", "message" : null, "validates" : [ { "resource" : "HealthcareService", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/healthcareservice.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_HealthcareService", "description" : "Search without criteria (GET) HealthcareService", "status" : "pass", "message" : null, "validates" : [ { "resource" : "HealthcareService", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/healthcareservice.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:10.501-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:10.501-0400" } }
,{ "_id" : { "$oid" : "560f0b564d4d3266f82b0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6930000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ImagingObjectSelection", "description" : "Compare supported search parameters with specification ImagingObjectSelection", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ImagingObjectSelection", "description" : "Search by ID (POST) ImagingObjectSelection", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ImagingObjectSelection", "description" : "Search limit by _count (POST) ImagingObjectSelection", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ImagingObjectSelection", "description" : "Search without criteria (POST) ImagingObjectSelection", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/imagingobjectselection.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ImagingObjectSelection", "description" : "Search by ID (GET) ImagingObjectSelection", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ImagingObjectSelection", "description" : "Search limit by _count (GET) ImagingObjectSelection", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 500. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'identifier'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingobjectselection.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ImagingObjectSelection", "description" : "Search without criteria (GET) ImagingObjectSelection", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 500. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'identifier'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ImagingObjectSelection", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/imagingobjectselection.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:18.107-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:18.107-0400" } }
,{ "_id" : { "$oid" : "560f0b5b4d4d3266f82c0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6940000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ImagingStudy", "description" : "Compare supported search parameters with specification ImagingStudy", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ImagingStudy", "description" : "Search by ID (POST) ImagingStudy", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ImagingStudy", "description" : "Search limit by _count (POST) ImagingStudy", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ImagingStudy", "description" : "Search without criteria (POST) ImagingStudy", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/imagingstudy.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ImagingStudy", "description" : "Search by ID (GET) ImagingStudy", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ImagingStudy", "description" : "Search limit by _count (GET) ImagingStudy", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 500. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'study'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/imagingstudy.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ImagingStudy", "description" : "Search without criteria (GET) ImagingStudy", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 500. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"EntityCommandExecutionException: An error occurred while executing the command definition. See the inner exception for details.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.Objects.Internal.ObjectQueryExecutionPlan.Execute[TResultType](ObjectContext context, ObjectParameterCollection parameterValues)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__6()&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectContext.ExecuteInTransaction[T](Func`1 func, IDbExecutionStrategy executionStrategy, Boolean startLocalTransaction, Boolean releaseConnectionOnSuccess)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClass7.&lt;GetResults&gt;b__5()&#xD;&#xA;   at System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)&#xD;&#xA;   at System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator&gt;b__0()&#xD;&#xA;   at System.Data.Entity.Internal.LazyEnumerator`1.MoveNext()&#xD;&#xA;   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)&#xD;&#xA;   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.PrepareBundleContents(fhirstore store, IList`1 entries, Nullable`1 Count, Nullable`1 PageNumber, IQueryable`1 bi, Nullable`1 summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1271&#xD;&#xA;   at HealthConnex.Fhir.Models.ModelBase`6.Search(IEnumerable`1 parameters, IList`1 QuestionnaireAnswers, Nullable`1 Count, Nullable`1 PageNumber, Boolean summary) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Models\\BaseModel.cs:line 1376&#xD;&#xA;   at sqlonfhir.Controllers.StandardResourceController.Search(String ResourceName) in C:\\src\\FHIR\\sqlonfhir-DSTU2\\sqlonfhir\\Controllers\\StandardResourceController.cs:line 526&#xD;&#xA;   at lambda_method(Closure , Object , Object[] )&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)&#xD;&#xA;   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Filters.ActionFilterAttribute.&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()&#xD;&#xA;--- End of stack trace from previous location where exception was thrown ---&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)&#xD;&#xA;   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)&#xD;&#xA;   at System.Web.Http.Controllers.ExceptionFilterResult.&lt;ExecuteAsync&gt;d__0.MoveNext()\" /></details></issue><issue><severity value=\"error\" /><details><coding /><text value=\"SqlException: Invalid column name 'study'.\" /></details></issue><issue><severity value=\"information\" /><details><coding /><text value=\"   at System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.ThrowExceptionAndWarning(TdsParserStateObject stateObj, Boolean callerHasConnectionLock, Boolean asyncClose)&#xD;&#xA;   at System.Data.SqlClient.TdsParser.TryRun(RunBehavior runBehavior, SqlCommand cmdHandler, SqlDataReader dataStream, BulkCopySimpleResultSet bulkCopyHandler, TdsParserStateObject stateObj, Boolean&amp; dataReady)&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlDataReader.get_MetaData()&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.FinishExecuteReader(SqlDataReader ds, RunBehavior runBehavior, String resetOptionsString)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, Boolean async, Int32 timeout, Task&amp; task, Boolean asyncWrite, SqlDataReader ds, Boolean describeParameterEncryptionRequest)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method, TaskCompletionSource`1 completion, Int32 timeout, Task&amp; task, Boolean asyncWrite)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.RunExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, Boolean returnStream, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteReader(CommandBehavior behavior, String method)&#xD;&#xA;   at System.Data.SqlClient.SqlCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.&lt;Reader&gt;b__c(DbCommand t, DbCommandInterceptionContext`1 c)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext,TResult](TTarget target, Func`3 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)&#xD;&#xA;   at System.Data.Entity.Infrastructure.Interception.DbCommandDispatcher.Reader(DbCommand command, DbCommandInterceptionContext interceptionContext)&#xD;&#xA;   at System.Data.Entity.Internal.InterceptableDbCommand.ExecuteDbDataReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Common.DbCommand.ExecuteReader(CommandBehavior behavior)&#xD;&#xA;   at System.Data.Entity.Core.EntityClient.Internal.EntityCommandDefinition.ExecuteStoreCommands(EntityCommand entityCommand, CommandBehavior behavior)\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "ImagingStudy", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/imagingstudy.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:23.942-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:23.942-0400" } }
,{ "_id" : { "$oid" : "560f0b5e4d4d3266f82d0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6950000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Immunization", "description" : "Compare supported search parameters with specification Immunization", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Immunization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Immunization", "description" : "Search by ID (POST) Immunization", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Immunization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Immunization", "description" : "Search limit by _count (POST) Immunization", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Immunization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Immunization", "description" : "Search without criteria (POST) Immunization", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Immunization", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/immunization.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Immunization", "description" : "Search by ID (GET) Immunization", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Immunization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Immunization", "description" : "Search limit by _count (GET) Immunization", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Immunization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunization.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Immunization", "description" : "Search without criteria (GET) Immunization", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Immunization", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/immunization.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:26.841-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:26.841-0400" } }
,{ "_id" : { "$oid" : "560f0b624d4d3266f82e0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6960000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ImmunizationRecommendation", "description" : "Compare supported search parameters with specification ImmunizationRecommendation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ImmunizationRecommendation", "description" : "Search by ID (POST) ImmunizationRecommendation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ImmunizationRecommendation", "description" : "Search limit by _count (POST) ImmunizationRecommendation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ImmunizationRecommendation", "description" : "Search without criteria (POST) ImmunizationRecommendation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ImmunizationRecommendation", "description" : "Search by ID (GET) ImmunizationRecommendation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ImmunizationRecommendation", "description" : "Search limit by _count (GET) ImmunizationRecommendation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ImmunizationRecommendation", "description" : "Search without criteria (GET) ImmunizationRecommendation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImmunizationRecommendation", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/immunizationrecommendation.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:30.117-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:30.117-0400" } }
,{ "_id" : { "$oid" : "560f0b644d4d3266f82f0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6970000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ImplementationGuide", "description" : "Compare supported search parameters with specification ImplementationGuide", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ImplementationGuide", "description" : "Search by ID (POST) ImplementationGuide", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ImplementationGuide", "description" : "Search limit by _count (POST) ImplementationGuide", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ImplementationGuide", "description" : "Search without criteria (POST) ImplementationGuide", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/implementationguide.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ImplementationGuide", "description" : "Search by ID (GET) ImplementationGuide", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ImplementationGuide", "description" : "Search limit by _count (GET) ImplementationGuide", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/implementationguide.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ImplementationGuide", "description" : "Search without criteria (GET) ImplementationGuide", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ImplementationGuide", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/implementationguide.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:32.599-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:32.599-0400" } }
,{ "_id" : { "$oid" : "560f0b6d4d4d3266f8300300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6980000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_List", "description" : "Compare supported search parameters with specification List", "status" : "pass", "message" : null, "validates" : [ { "resource" : "List", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_List", "description" : "Search by ID (POST) List", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "List", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_List", "description" : "Search limit by _count (POST) List", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "List", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_List", "description" : "Search without criteria (POST) List", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "List", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/list.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_List", "description" : "Search by ID (GET) List", "status" : "pass", "message" : null, "validates" : [ { "resource" : "List", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_List", "description" : "Search limit by _count (GET) List", "status" : "pass", "message" : null, "validates" : [ { "resource" : "List", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/list.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_List", "description" : "Search without criteria (GET) List", "status" : "pass", "message" : null, "validates" : [ { "resource" : "List", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/list.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:41.953-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:41.953-0400" } }
,{ "_id" : { "$oid" : "560f0b704d4d3266f8310300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6990000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Location", "description" : "Compare supported search parameters with specification Location", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Location", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Location", "description" : "Search by ID (POST) Location", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Location", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Location", "description" : "Search limit by _count (POST) Location", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Location", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Location", "description" : "Search without criteria (POST) Location", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Location", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/location.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Location", "description" : "Search by ID (GET) Location", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Location", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Location", "description" : "Search limit by _count (GET) Location", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Location", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/location.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Location", "description" : "Search without criteria (GET) Location", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Location", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/location.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:44.955-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:44.955-0400" } }
,{ "_id" : { "$oid" : "560f0b734d4d3266f8320300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a69a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Media", "description" : "Compare supported search parameters with specification Media", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Media", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Media", "description" : "Search by ID (POST) Media", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Media", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Media", "description" : "Search limit by _count (POST) Media", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Media", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Media", "description" : "Search without criteria (POST) Media", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Media", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/media.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Media", "description" : "Search by ID (GET) Media", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Media", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Media", "description" : "Search limit by _count (GET) Media", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Media", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/media.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Media", "description" : "Search without criteria (GET) Media", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Media", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/media.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:47.509-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:47.509-0400" } }
,{ "_id" : { "$oid" : "560f0b774d4d3266f8330300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a69b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Medication", "description" : "Compare supported search parameters with specification Medication", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Medication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Medication", "description" : "Search by ID (POST) Medication", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Medication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Medication", "description" : "Search limit by _count (POST) Medication", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Medication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Medication", "description" : "Search without criteria (POST) Medication", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Medication", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medication.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Medication", "description" : "Search by ID (GET) Medication", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Medication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Medication", "description" : "Search limit by _count (GET) Medication", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Medication", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medication.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Medication", "description" : "Search without criteria (GET) Medication", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Medication", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medication.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:51.932-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:51.932-0400" } }
,{ "_id" : { "$oid" : "560f0b7b4d4d3266f8340300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a69c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_MedicationAdministration", "description" : "Compare supported search parameters with specification MedicationAdministration", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_MedicationAdministration", "description" : "Search by ID (POST) MedicationAdministration", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_MedicationAdministration", "description" : "Search limit by _count (POST) MedicationAdministration", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_MedicationAdministration", "description" : "Search without criteria (POST) MedicationAdministration", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medicationadministration.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_MedicationAdministration", "description" : "Search by ID (GET) MedicationAdministration", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_MedicationAdministration", "description" : "Search limit by _count (GET) MedicationAdministration", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationadministration.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_MedicationAdministration", "description" : "Search without criteria (GET) MedicationAdministration", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationAdministration", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medicationadministration.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:55:55.106-0400" }, "created_at" : { "$date" : "2015-10-02T18:55:55.106-0400" } }
,{ "_id" : { "$oid" : "560f0b804d4d3266f8350300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a69d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_MedicationDispense", "description" : "Compare supported search parameters with specification MedicationDispense", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_MedicationDispense", "description" : "Search by ID (POST) MedicationDispense", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_MedicationDispense", "description" : "Search limit by _count (POST) MedicationDispense", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_MedicationDispense", "description" : "Search without criteria (POST) MedicationDispense", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medicationdispense.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_MedicationDispense", "description" : "Search by ID (GET) MedicationDispense", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_MedicationDispense", "description" : "Search limit by _count (GET) MedicationDispense", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationdispense.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_MedicationDispense", "description" : "Search without criteria (GET) MedicationDispense", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationDispense", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medicationdispense.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:00.217-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:00.217-0400" } }
,{ "_id" : { "$oid" : "560f0b874d4d3266f8360300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a69e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_MedicationOrder", "description" : "Compare supported search parameters with specification MedicationOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_MedicationOrder", "description" : "Search by ID (POST) MedicationOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_MedicationOrder", "description" : "Search limit by _count (POST) MedicationOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_MedicationOrder", "description" : "Search without criteria (POST) MedicationOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medicationorder.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_MedicationOrder", "description" : "Search by ID (GET) MedicationOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_MedicationOrder", "description" : "Search limit by _count (GET) MedicationOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationorder.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_MedicationOrder", "description" : "Search without criteria (GET) MedicationOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationOrder", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medicationorder.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:07.116-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:07.116-0400" } }
,{ "_id" : { "$oid" : "560f0b8b4d4d3266f8370300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a69f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_MedicationStatement", "description" : "Compare supported search parameters with specification MedicationStatement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_MedicationStatement", "description" : "Search by ID (POST) MedicationStatement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_MedicationStatement", "description" : "Search limit by _count (POST) MedicationStatement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_MedicationStatement", "description" : "Search without criteria (POST) MedicationStatement", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medicationstatement.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_MedicationStatement", "description" : "Search by ID (GET) MedicationStatement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_MedicationStatement", "description" : "Search limit by _count (GET) MedicationStatement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/medicationstatement.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_MedicationStatement", "description" : "Search without criteria (GET) MedicationStatement", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MedicationStatement", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/medicationstatement.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:11.456-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:11.456-0400" } }
,{ "_id" : { "$oid" : "560f0b8e4d4d3266f8380300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a00000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_MessageHeader", "description" : "Compare supported search parameters with specification MessageHeader", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MessageHeader", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_MessageHeader", "description" : "Search by ID (POST) MessageHeader", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_MessageHeader", "description" : "Search limit by _count (POST) MessageHeader", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_MessageHeader", "description" : "Search without criteria (POST) MessageHeader", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "MessageHeader", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/messageheader.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_MessageHeader", "description" : "Search by ID (GET) MessageHeader", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MessageHeader", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_MessageHeader", "description" : "Search limit by _count (GET) MessageHeader", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MessageHeader", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/messageheader.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_MessageHeader", "description" : "Search without criteria (GET) MessageHeader", "status" : "pass", "message" : null, "validates" : [ { "resource" : "MessageHeader", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/messageheader.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:14.156-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:14.156-0400" } }
,{ "_id" : { "$oid" : "560f0b934d4d3266f8390300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a10000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_NamingSystem", "description" : "Compare supported search parameters with specification NamingSystem", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NamingSystem", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_NamingSystem", "description" : "Search by ID (POST) NamingSystem", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_NamingSystem", "description" : "Search limit by _count (POST) NamingSystem", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_NamingSystem", "description" : "Search without criteria (POST) NamingSystem", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "NamingSystem", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/namingsystem.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_NamingSystem", "description" : "Search by ID (GET) NamingSystem", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NamingSystem", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_NamingSystem", "description" : "Search limit by _count (GET) NamingSystem", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NamingSystem", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/namingsystem.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_NamingSystem", "description" : "Search without criteria (GET) NamingSystem", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NamingSystem", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/namingsystem.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:19.352-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:19.352-0400" } }
,{ "_id" : { "$oid" : "560f0b994d4d3266f83a0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a20000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_NutritionOrder", "description" : "Compare supported search parameters with specification NutritionOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_NutritionOrder", "description" : "Search by ID (POST) NutritionOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_NutritionOrder", "description" : "Search limit by _count (POST) NutritionOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_NutritionOrder", "description" : "Search without criteria (POST) NutritionOrder", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/nutritionorder.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_NutritionOrder", "description" : "Search by ID (GET) NutritionOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_NutritionOrder", "description" : "Search limit by _count (GET) NutritionOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/nutritionorder.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_NutritionOrder", "description" : "Search without criteria (GET) NutritionOrder", "status" : "pass", "message" : null, "validates" : [ { "resource" : "NutritionOrder", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/nutritionorder.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:25.532-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:25.532-0400" } }
,{ "_id" : { "$oid" : "560f0ba04d4d3266f83b0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a30000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Observation", "description" : "Compare supported search parameters with specification Observation", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Observation", "description" : "Search by ID (POST) Observation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Observation", "description" : "Search limit by _count (POST) Observation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Observation", "description" : "Search without criteria (POST) Observation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Observation", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/observation.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Observation", "description" : "Search by ID (GET) Observation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Observation", "description" : "Search limit by _count (GET) Observation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/observation.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Observation", "description" : "Search without criteria (GET) Observation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/observation.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:32.396-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:32.396-0400" } }
,{ "_id" : { "$oid" : "560f0ba34d4d3266f83c0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a40000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_OperationDefinition", "description" : "Compare supported search parameters with specification OperationDefinition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_OperationDefinition", "description" : "Search by ID (POST) OperationDefinition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_OperationDefinition", "description" : "Search limit by _count (POST) OperationDefinition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_OperationDefinition", "description" : "Search without criteria (POST) OperationDefinition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operationdefinition.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_OperationDefinition", "description" : "Search by ID (GET) OperationDefinition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_OperationDefinition", "description" : "Search limit by _count (GET) OperationDefinition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationdefinition.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_OperationDefinition", "description" : "Search without criteria (GET) OperationDefinition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationDefinition", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operationdefinition.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:35.628-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:35.628-0400" } }
,{ "_id" : { "$oid" : "560f0ba64d4d3266f83d0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a50000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_OperationOutcome", "description" : "Compare supported search parameters with specification OperationOutcome", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_OperationOutcome", "description" : "Search by ID (POST) OperationOutcome", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_OperationOutcome", "description" : "Search limit by _count (POST) OperationOutcome", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_OperationOutcome", "description" : "Search without criteria (POST) OperationOutcome", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operationoutcome.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_OperationOutcome", "description" : "Search by ID (GET) OperationOutcome", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_OperationOutcome", "description" : "Search limit by _count (GET) OperationOutcome", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/operationoutcome.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_OperationOutcome", "description" : "Search without criteria (GET) OperationOutcome", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OperationOutcome", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/operationoutcome.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:38.442-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:38.442-0400" } }
,{ "_id" : { "$oid" : "560f0ba94d4d3266f83e0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a60000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Order", "description" : "Compare supported search parameters with specification Order", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Order", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Order", "description" : "Search by ID (POST) Order", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Order", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Order", "description" : "Search limit by _count (POST) Order", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Order", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Order", "description" : "Search without criteria (POST) Order", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Order", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/order.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Order", "description" : "Search by ID (GET) Order", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Order", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Order", "description" : "Search limit by _count (GET) Order", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Order", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/order.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Order", "description" : "Search without criteria (GET) Order", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Order", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/order.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:41.518-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:41.518-0400" } }
,{ "_id" : { "$oid" : "560f0bac4d4d3266f83f0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a70000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_OrderResponse", "description" : "Compare supported search parameters with specification OrderResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OrderResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_OrderResponse", "description" : "Search by ID (POST) OrderResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_OrderResponse", "description" : "Search limit by _count (POST) OrderResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_OrderResponse", "description" : "Search without criteria (POST) OrderResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "OrderResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/orderresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_OrderResponse", "description" : "Search by ID (GET) OrderResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OrderResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_OrderResponse", "description" : "Search limit by _count (GET) OrderResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OrderResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/orderresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_OrderResponse", "description" : "Search without criteria (GET) OrderResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "OrderResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/orderresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:44.581-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:44.581-0400" } }
,{ "_id" : { "$oid" : "560f0bb14d4d3266f8400300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a80000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Organization", "description" : "Compare supported search parameters with specification Organization", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Organization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Organization", "description" : "Search by ID (POST) Organization", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Organization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Organization", "description" : "Search limit by _count (POST) Organization", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Organization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Organization", "description" : "Search without criteria (POST) Organization", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Organization", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/organization.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Organization", "description" : "Search by ID (GET) Organization", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Organization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Organization", "description" : "Search limit by _count (GET) Organization", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Organization", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/organization.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Organization", "description" : "Search without criteria (GET) Organization", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Organization", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/organization.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:49.288-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:49.288-0400" } }
,{ "_id" : { "$oid" : "560f0bb64d4d3266f8410300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0534d4d3261a6a90000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Patient", "description" : "Compare supported search parameters with specification Patient", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Patient", "description" : "Search by ID (POST) Patient", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Patient", "description" : "Search limit by _count (POST) Patient", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Patient", "description" : "Search without criteria (POST) Patient", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Patient", "description" : "Search by ID (GET) Patient", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Patient", "description" : "Search limit by _count (GET) Patient", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/patient.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Patient", "description" : "Search without criteria (GET) Patient", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/patient.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:54.003-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:54.003-0400" } }
,{ "_id" : { "$oid" : "560f0bb84d4d3266f8420300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6aa0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_PaymentNotice", "description" : "Compare supported search parameters with specification PaymentNotice", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_PaymentNotice", "description" : "Search by ID (POST) PaymentNotice", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_PaymentNotice", "description" : "Search limit by _count (POST) PaymentNotice", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_PaymentNotice", "description" : "Search without criteria (POST) PaymentNotice", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/paymentnotice.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_PaymentNotice", "description" : "Search by ID (GET) PaymentNotice", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_PaymentNotice", "description" : "Search limit by _count (GET) PaymentNotice", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentnotice.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_PaymentNotice", "description" : "Search without criteria (GET) PaymentNotice", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentNotice", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/paymentnotice.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:56.816-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:56.816-0400" } }
,{ "_id" : { "$oid" : "560f0bbb4d4d3266f8430300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6ab0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_PaymentReconciliation", "description" : "Compare supported search parameters with specification PaymentReconciliation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_PaymentReconciliation", "description" : "Search by ID (POST) PaymentReconciliation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_PaymentReconciliation", "description" : "Search limit by _count (POST) PaymentReconciliation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_PaymentReconciliation", "description" : "Search without criteria (POST) PaymentReconciliation", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/paymentreconciliation.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_PaymentReconciliation", "description" : "Search by ID (GET) PaymentReconciliation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_PaymentReconciliation", "description" : "Search limit by _count (GET) PaymentReconciliation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/paymentreconciliation.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_PaymentReconciliation", "description" : "Search without criteria (GET) PaymentReconciliation", "status" : "pass", "message" : null, "validates" : [ { "resource" : "PaymentReconciliation", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/paymentreconciliation.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:56:59.444-0400" }, "created_at" : { "$date" : "2015-10-02T18:56:59.444-0400" } }
,{ "_id" : { "$oid" : "560f0bbf4d4d3266f8440300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6ac0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Person", "description" : "Compare supported search parameters with specification Person", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Person", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Person", "description" : "Search by ID (POST) Person", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Person", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Person", "description" : "Search limit by _count (POST) Person", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Person", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Person", "description" : "Search without criteria (POST) Person", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Person", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/person.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Person", "description" : "Search by ID (GET) Person", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Person", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Person", "description" : "Search limit by _count (GET) Person", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Person", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/person.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Person", "description" : "Search without criteria (GET) Person", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Person", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/person.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:57:03.329-0400" }, "created_at" : { "$date" : "2015-10-02T18:57:03.329-0400" } }
,{ "_id" : { "$oid" : "560f0bc44d4d3266f8450300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6ad0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Practitioner", "description" : "Compare supported search parameters with specification Practitioner", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Practitioner", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Practitioner", "description" : "Search by ID (POST) Practitioner", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Practitioner", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Practitioner", "description" : "Search limit by _count (POST) Practitioner", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Practitioner", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Practitioner", "description" : "Search without criteria (POST) Practitioner", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Practitioner", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/practitioner.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Practitioner", "description" : "Search by ID (GET) Practitioner", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Practitioner", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Practitioner", "description" : "Search limit by _count (GET) Practitioner", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Practitioner", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/practitioner.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Practitioner", "description" : "Search without criteria (GET) Practitioner", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Practitioner", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/practitioner.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:57:08.853-0400" }, "created_at" : { "$date" : "2015-10-02T18:57:08.853-0400" } }
,{ "_id" : { "$oid" : "560f0bc94d4d3266f8460300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6ae0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Procedure", "description" : "Compare supported search parameters with specification Procedure", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Procedure", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Procedure", "description" : "Search by ID (POST) Procedure", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Procedure", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Procedure", "description" : "Search limit by _count (POST) Procedure", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Procedure", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Procedure", "description" : "Search without criteria (POST) Procedure", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Procedure", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/procedure.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Procedure", "description" : "Search by ID (GET) Procedure", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Procedure", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Procedure", "description" : "Search limit by _count (GET) Procedure", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Procedure", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedure.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Procedure", "description" : "Search without criteria (GET) Procedure", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Procedure", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/procedure.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:57:13.500-0400" }, "created_at" : { "$date" : "2015-10-02T18:57:13.500-0400" } }
,{ "_id" : { "$oid" : "560f0bcc4d4d3266f8470300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6af0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ProcedureRequest", "description" : "Compare supported search parameters with specification ProcedureRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ProcedureRequest", "description" : "Search by ID (POST) ProcedureRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ProcedureRequest", "description" : "Search limit by _count (POST) ProcedureRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ProcedureRequest", "description" : "Search without criteria (POST) ProcedureRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/procedurerequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ProcedureRequest", "description" : "Search by ID (GET) ProcedureRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ProcedureRequest", "description" : "Search limit by _count (GET) ProcedureRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/procedurerequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ProcedureRequest", "description" : "Search without criteria (GET) ProcedureRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcedureRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/procedurerequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:57:16.542-0400" }, "created_at" : { "$date" : "2015-10-02T18:57:16.542-0400" } }
,{ "_id" : { "$oid" : "560f0bcf4d4d3266f8480300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b00000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ProcessRequest", "description" : "Compare supported search parameters with specification ProcessRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ProcessRequest", "description" : "Search by ID (POST) ProcessRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ProcessRequest", "description" : "Search limit by _count (POST) ProcessRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ProcessRequest", "description" : "Search without criteria (POST) ProcessRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/processrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ProcessRequest", "description" : "Search by ID (GET) ProcessRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ProcessRequest", "description" : "Search limit by _count (GET) ProcessRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ProcessRequest", "description" : "Search without criteria (GET) ProcessRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/processrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:57:19.703-0400" }, "created_at" : { "$date" : "2015-10-02T18:57:19.703-0400" } }
,{ "_id" : { "$oid" : "560f0bd34d4d3266f8490300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b10000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ProcessResponse", "description" : "Compare supported search parameters with specification ProcessResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ProcessResponse", "description" : "Search by ID (POST) ProcessResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ProcessResponse", "description" : "Search limit by _count (POST) ProcessResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ProcessResponse", "description" : "Search without criteria (POST) ProcessResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/processresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ProcessResponse", "description" : "Search by ID (GET) ProcessResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ProcessResponse", "description" : "Search limit by _count (GET) ProcessResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/processresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ProcessResponse", "description" : "Search without criteria (GET) ProcessResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ProcessResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/processresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:57:23.124-0400" }, "created_at" : { "$date" : "2015-10-02T18:57:23.124-0400" } }
,{ "_id" : { "$oid" : "560f0bd64d4d3266f84a0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b20000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Provenance", "description" : "Compare supported search parameters with specification Provenance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Provenance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Provenance", "description" : "Search by ID (POST) Provenance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Provenance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Provenance", "description" : "Search limit by _count (POST) Provenance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Provenance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Provenance", "description" : "Search without criteria (POST) Provenance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Provenance", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/provenance.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Provenance", "description" : "Search by ID (GET) Provenance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Provenance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Provenance", "description" : "Search limit by _count (GET) Provenance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Provenance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/provenance.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Provenance", "description" : "Search without criteria (GET) Provenance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Provenance", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/provenance.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:57:26.226-0400" }, "created_at" : { "$date" : "2015-10-02T18:57:26.226-0400" } }
,{ "_id" : { "$oid" : "560f0bf04d4d3266f84b0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b30000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Questionnaire", "description" : "Compare supported search parameters with specification Questionnaire", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Questionnaire", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Questionnaire", "description" : "Search by ID (POST) Questionnaire", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Questionnaire", "description" : "Search limit by _count (POST) Questionnaire", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Questionnaire", "description" : "Search without criteria (POST) Questionnaire", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Questionnaire", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/questionnaire.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Questionnaire", "description" : "Search by ID (GET) Questionnaire", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Questionnaire", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Questionnaire", "description" : "Search limit by _count (GET) Questionnaire", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Questionnaire", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaire.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Questionnaire", "description" : "Search without criteria (GET) Questionnaire", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Questionnaire", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/questionnaire.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:57:52.808-0400" }, "created_at" : { "$date" : "2015-10-02T18:57:52.808-0400" } }
,{ "_id" : { "$oid" : "560f0bfa4d4d3266f84c0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b40000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_QuestionnaireResponse", "description" : "Compare supported search parameters with specification QuestionnaireResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_QuestionnaireResponse", "description" : "Search by ID (POST) QuestionnaireResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_QuestionnaireResponse", "description" : "Search limit by _count (POST) QuestionnaireResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_QuestionnaireResponse", "description" : "Search without criteria (POST) QuestionnaireResponse", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/questionnaireresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_QuestionnaireResponse", "description" : "Search by ID (GET) QuestionnaireResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_QuestionnaireResponse", "description" : "Search limit by _count (GET) QuestionnaireResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/questionnaireresponse.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_QuestionnaireResponse", "description" : "Search without criteria (GET) QuestionnaireResponse", "status" : "pass", "message" : null, "validates" : [ { "resource" : "QuestionnaireResponse", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/questionnaireresponse.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:02.623-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:02.623-0400" } }
,{ "_id" : { "$oid" : "560f0bfd4d4d3266f84d0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b50000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ReferralRequest", "description" : "Compare supported search parameters with specification ReferralRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ReferralRequest", "description" : "Search by ID (POST) ReferralRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ReferralRequest", "description" : "Search limit by _count (POST) ReferralRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ReferralRequest", "description" : "Search without criteria (POST) ReferralRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/referralrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ReferralRequest", "description" : "Search by ID (GET) ReferralRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ReferralRequest", "description" : "Search limit by _count (GET) ReferralRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/referralrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ReferralRequest", "description" : "Search without criteria (GET) ReferralRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ReferralRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/referralrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:05.324-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:05.324-0400" } }
,{ "_id" : { "$oid" : "560f0c004d4d3266f84e0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b60000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_RelatedPerson", "description" : "Compare supported search parameters with specification RelatedPerson", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_RelatedPerson", "description" : "Search by ID (POST) RelatedPerson", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_RelatedPerson", "description" : "Search limit by _count (POST) RelatedPerson", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_RelatedPerson", "description" : "Search without criteria (POST) RelatedPerson", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/relatedperson.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_RelatedPerson", "description" : "Search by ID (GET) RelatedPerson", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_RelatedPerson", "description" : "Search limit by _count (GET) RelatedPerson", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/relatedperson.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_RelatedPerson", "description" : "Search without criteria (GET) RelatedPerson", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RelatedPerson", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/relatedperson.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:08.775-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:08.775-0400" } }
,{ "_id" : { "$oid" : "560f0c034d4d3266f84f0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b70000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_RiskAssessment", "description" : "Compare supported search parameters with specification RiskAssessment", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_RiskAssessment", "description" : "Search by ID (POST) RiskAssessment", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_RiskAssessment", "description" : "Search limit by _count (POST) RiskAssessment", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_RiskAssessment", "description" : "Search without criteria (POST) RiskAssessment", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/riskassessment.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_RiskAssessment", "description" : "Search by ID (GET) RiskAssessment", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_RiskAssessment", "description" : "Search limit by _count (GET) RiskAssessment", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/riskassessment.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_RiskAssessment", "description" : "Search without criteria (GET) RiskAssessment", "status" : "pass", "message" : null, "validates" : [ { "resource" : "RiskAssessment", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/riskassessment.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:11.765-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:11.765-0400" } }
,{ "_id" : { "$oid" : "560f0c064d4d3266f8500300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b80000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Schedule", "description" : "Compare supported search parameters with specification Schedule", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Schedule", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Schedule", "description" : "Search by ID (POST) Schedule", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Schedule", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Schedule", "description" : "Search limit by _count (POST) Schedule", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Schedule", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Schedule", "description" : "Search without criteria (POST) Schedule", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Schedule", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/schedule.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Schedule", "description" : "Search by ID (GET) Schedule", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Schedule", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Schedule", "description" : "Search limit by _count (GET) Schedule", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Schedule", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/schedule.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Schedule", "description" : "Search without criteria (GET) Schedule", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Schedule", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/schedule.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:14.391-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:14.391-0400" } }
,{ "_id" : { "$oid" : "560f0c0b4d4d3266f8510300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6b90000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_SearchParameter", "description" : "Compare supported search parameters with specification SearchParameter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SearchParameter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_SearchParameter", "description" : "Search by ID (POST) SearchParameter", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_SearchParameter", "description" : "Search limit by _count (POST) SearchParameter", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_SearchParameter", "description" : "Search without criteria (POST) SearchParameter", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SearchParameter", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/searchparameter.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_SearchParameter", "description" : "Search by ID (GET) SearchParameter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SearchParameter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_SearchParameter", "description" : "Search limit by _count (GET) SearchParameter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SearchParameter", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/searchparameter.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_SearchParameter", "description" : "Search without criteria (GET) SearchParameter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SearchParameter", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/searchparameter.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:19.265-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:19.265-0400" } }
,{ "_id" : { "$oid" : "560f0c0e4d4d3266f8520300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6ba0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Slot", "description" : "Compare supported search parameters with specification Slot", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Slot", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Slot", "description" : "Search by ID (POST) Slot", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Slot", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Slot", "description" : "Search limit by _count (POST) Slot", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Slot", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Slot", "description" : "Search without criteria (POST) Slot", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Slot", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/slot.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Slot", "description" : "Search by ID (GET) Slot", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Slot", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Slot", "description" : "Search limit by _count (GET) Slot", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Slot", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/slot.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Slot", "description" : "Search without criteria (GET) Slot", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Slot", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/slot.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:22.525-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:22.525-0400" } }
,{ "_id" : { "$oid" : "560f0c124d4d3266f8530300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6bb0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Specimen", "description" : "Compare supported search parameters with specification Specimen", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Specimen", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Specimen", "description" : "Search by ID (POST) Specimen", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Specimen", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Specimen", "description" : "Search limit by _count (POST) Specimen", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Specimen", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Specimen", "description" : "Search without criteria (POST) Specimen", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Specimen", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/specimen.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Specimen", "description" : "Search by ID (GET) Specimen", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Specimen", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Specimen", "description" : "Search limit by _count (GET) Specimen", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Specimen", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/specimen.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Specimen", "description" : "Search without criteria (GET) Specimen", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Specimen", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/specimen.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:26.541-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:26.541-0400" } }
,{ "_id" : { "$oid" : "560f0c324d4d3266f8540300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6bc0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_StructureDefinition", "description" : "Compare supported search parameters with specification StructureDefinition", "status" : "fail", "message" : "The server does not support searching all the parameters specified by the specification.", "data" : null, "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_StructureDefinition", "description" : "Search by ID (POST) StructureDefinition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_StructureDefinition", "description" : "Search limit by _count (POST) StructureDefinition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_StructureDefinition", "description" : "Search without criteria (POST) StructureDefinition", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/structuredefinition.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_StructureDefinition", "description" : "Search by ID (GET) StructureDefinition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_StructureDefinition", "description" : "Search limit by _count (GET) StructureDefinition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/structuredefinition.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_StructureDefinition", "description" : "Search without criteria (GET) StructureDefinition", "status" : "pass", "message" : null, "validates" : [ { "resource" : "StructureDefinition", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/structuredefinition.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:58:58.176-0400" }, "created_at" : { "$date" : "2015-10-02T18:58:58.176-0400" } }
,{ "_id" : { "$oid" : "560f0c354d4d3266f8550300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6bd0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Subscription", "description" : "Compare supported search parameters with specification Subscription", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Subscription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Subscription", "description" : "Search by ID (POST) Subscription", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Subscription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Subscription", "description" : "Search limit by _count (POST) Subscription", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Subscription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Subscription", "description" : "Search without criteria (POST) Subscription", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Subscription", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/subscription.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Subscription", "description" : "Search by ID (GET) Subscription", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Subscription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Subscription", "description" : "Search limit by _count (GET) Subscription", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Subscription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/subscription.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Subscription", "description" : "Search without criteria (GET) Subscription", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Subscription", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/subscription.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:59:01.353-0400" }, "created_at" : { "$date" : "2015-10-02T18:59:01.353-0400" } }
,{ "_id" : { "$oid" : "560f0c384d4d3266f8560300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6be0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_Substance", "description" : "Compare supported search parameters with specification Substance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Substance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_Substance", "description" : "Search by ID (POST) Substance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Substance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_Substance", "description" : "Search limit by _count (POST) Substance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Substance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_Substance", "description" : "Search without criteria (POST) Substance", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Substance", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/substance.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_Substance", "description" : "Search by ID (GET) Substance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Substance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_Substance", "description" : "Search limit by _count (GET) Substance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Substance", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/substance.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_Substance", "description" : "Search without criteria (GET) Substance", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Substance", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/substance.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:59:04.369-0400" }, "created_at" : { "$date" : "2015-10-02T18:59:04.369-0400" } }
,{ "_id" : { "$oid" : "560f0c3b4d4d3266f8570300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6bf0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_SupplyDelivery", "description" : "Compare supported search parameters with specification SupplyDelivery", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_SupplyDelivery", "description" : "Search by ID (POST) SupplyDelivery", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_SupplyDelivery", "description" : "Search limit by _count (POST) SupplyDelivery", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_SupplyDelivery", "description" : "Search without criteria (POST) SupplyDelivery", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/supplydelivery.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_SupplyDelivery", "description" : "Search by ID (GET) SupplyDelivery", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_SupplyDelivery", "description" : "Search limit by _count (GET) SupplyDelivery", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplydelivery.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_SupplyDelivery", "description" : "Search without criteria (GET) SupplyDelivery", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyDelivery", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/supplydelivery.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:59:07.215-0400" }, "created_at" : { "$date" : "2015-10-02T18:59:07.215-0400" } }
,{ "_id" : { "$oid" : "560f0c3d4d4d3266f8580300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6c00000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_SupplyRequest", "description" : "Compare supported search parameters with specification SupplyRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_SupplyRequest", "description" : "Search by ID (POST) SupplyRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_SupplyRequest", "description" : "Search limit by _count (POST) SupplyRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_SupplyRequest", "description" : "Search without criteria (POST) SupplyRequest", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/supplyrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_SupplyRequest", "description" : "Search by ID (GET) SupplyRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_SupplyRequest", "description" : "Search limit by _count (GET) SupplyRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/supplyrequest.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_SupplyRequest", "description" : "Search without criteria (GET) SupplyRequest", "status" : "pass", "message" : null, "validates" : [ { "resource" : "SupplyRequest", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/supplyrequest.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:59:09.771-0400" }, "created_at" : { "$date" : "2015-10-02T18:59:09.771-0400" } }
,{ "_id" : { "$oid" : "560f0c434d4d3266f8590300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6c10000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_TestScript", "description" : "Compare supported search parameters with specification TestScript", "status" : "pass", "message" : null, "validates" : [ { "resource" : "TestScript", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_TestScript", "description" : "Search by ID (POST) TestScript", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "TestScript", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_TestScript", "description" : "Search limit by _count (POST) TestScript", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "TestScript", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_TestScript", "description" : "Search without criteria (POST) TestScript", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "TestScript", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/testscript.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_TestScript", "description" : "Search by ID (GET) TestScript", "status" : "pass", "message" : null, "validates" : [ { "resource" : "TestScript", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_TestScript", "description" : "Search limit by _count (GET) TestScript", "status" : "pass", "message" : null, "validates" : [ { "resource" : "TestScript", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/testscript.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_TestScript", "description" : "Search without criteria (GET) TestScript", "status" : "pass", "message" : null, "validates" : [ { "resource" : "TestScript", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/testscript.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:59:15.382-0400" }, "created_at" : { "$date" : "2015-10-02T18:59:15.382-0400" } }
,{ "_id" : { "$oid" : "560f0c504d4d3266f85a0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0544d4d3261a6c20000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_ValueSet", "description" : "Compare supported search parameters with specification ValueSet", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ValueSet", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_ValueSet", "description" : "Search by ID (POST) ValueSet", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ValueSet", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_ValueSet", "description" : "Search limit by _count (POST) ValueSet", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ValueSet", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_ValueSet", "description" : "Search without criteria (POST) ValueSet", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "ValueSet", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/valueset.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_ValueSet", "description" : "Search by ID (GET) ValueSet", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ValueSet", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_ValueSet", "description" : "Search limit by _count (GET) ValueSet", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ValueSet", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/valueset.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_ValueSet", "description" : "Search without criteria (GET) ValueSet", "status" : "pass", "message" : null, "validates" : [ { "resource" : "ValueSet", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/valueset.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:59:28.518-0400" }, "created_at" : { "$date" : "2015-10-02T18:59:28.518-0400" } }
,{ "_id" : { "$oid" : "560f0c534d4d3266f85b0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0554d4d3261a6c30000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "S000", "id" : "S000_VisionPrescription", "description" : "Compare supported search parameters with specification VisionPrescription", "status" : "pass", "message" : null, "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test 'S000', 'Compare supported search parameters with specification' do\n        metadata {\n          define_metadata('search')\n        }\n        searchParamNames = []\n        searchParamNames = @searchParams.map { |item| item.name } if !@searchParams.nil?\n        assert ((@resource_class::SEARCH_PARAMS-searchParamNames).size <= 0), 'The server does not support searching all the parameters specified by the specification.'\n      end\n", "test_method" : "s000_compare_supported_search_parameters_with_specification_test" }, { "key" : "S001P", "id" : "S001P_VisionPrescription", "description" : "Search by ID (POST) VisionPrescription", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001p_search_by_id_(post)_test" }, { "key" : "S003P", "id" : "S003P_VisionPrescription", "description" : "Search limit by _count (POST) VisionPrescription", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003p_search_limit_by__count_(post)_test" }, { "key" : "SE01P", "id" : "SE01P_VisionPrescription", "description" : "Search without criteria (POST) VisionPrescription", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/visionprescription.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01p_search_without_criteria_(post)_test" }, { "key" : "S001G", "id" : "S001G_VisionPrescription", "description" : "Search by ID (GET) VisionPrescription", "status" : "pass", "message" : null, "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test \"S001#{action[0]}\", \"Search by ID (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_id' => '0'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "s001g_search_by_id_(get)_test" }, { "key" : "S003G", "id" : "S003G_VisionPrescription", "description" : "Search limit by _count (GET) VisionPrescription", "status" : "pass", "message" : null, "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/visionprescription.html" ], "code" : "      test \"S003#{action[0]}\", \"Search limit by _count (#{action})\" do\n        metadata {\n          define_metadata('search')\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert (1 >= reply.resource.entry.size), 'The server did not return the correct number of results.'\n      end\n", "test_method" : "s003g_search_limit_by__count_(get)_test" }, { "key" : "SE01G", "id" : "SE01G_VisionPrescription", "description" : "Search without criteria (GET) VisionPrescription", "status" : "pass", "message" : null, "validates" : [ { "resource" : "VisionPrescription", "methods" : [ "read", "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/visionprescription.html", "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test \"SE01#{action[0]}\", \"Search without criteria (#{action})\" do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/#{resource_class.name.demodulize.downcase}.html\"\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{REST_SPEC_LINK}#read\"\n          validates resource: resource_class.name.demodulize, methods: ['read', 'search']\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search(@resource_class, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n\n        replyB = @client.read_feed(@resource_class)\n        assert_equal replyB.resource.total, reply.resource.total, 'Searching without criteria did not return all the results.'\n      end\n", "test_method" : "se01g_search_without_criteria_(get)_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T18:59:31.919-0400" }, "created_at" : { "$date" : "2015-10-02T18:59:31.919-0400" } }
,{ "_id" : { "$oid" : "560f0c854d4d3266f85e0300" }, "has_run" : true, "test_id" : { "$oid" : "560ef0554d4d3261a6c50000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "SE01P", "id" : "SE01P", "description" : "Search patients without criteria (except _count)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html" ], "code" : "      test \"SE01#{action[0]}\",'Search patients without criteria (except _count)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.entry.size, 'The server did not return the correct number of results.'\n        warning { assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.' }\n      end\n", "test_method" : "se01p_search_patients_without_criteria_(except__count)_test" }, { "key" : "SE02P", "id" : "SE02P", "description" : "Search on non-existing resource", "status" : "pass", "message" : null, "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html" ], "code" : "      test \"SE02#{action[0]}\", 'Search on non-existing resource' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n        }\n        options = {\n          :resource => Crucible::Tests::SprinklerSearchTest,\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search_all(options)\n        assert( (reply.code >= 400 && reply.code < 600), 'If the search fails, the return value should be status code 4xx or 5xx.', reply)\n      end\n", "test_method" : "se02p_search_on_non-existing_resource_test" }, { "key" : "SE03P", "id" : "SE03P", "description" : "Search patient resource on partial family surname", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE03#{action[0]}\",'Search patient resource on partial family surname' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        search_string = @patient.name[0].family[0][0..2]\n        search_regex = Regexp.new(search_string)\n        # how many patients in the bundle have matching names?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          isMatch = false\n          if !patient.nil? && !patient.name.nil?\n            patient.name.each do |name|\n              if !name.family.nil?\n                name.family.each do |family|\n                  if !(family =~ search_regex).nil?\n                    isMatch = true\n                  end\n                end\n              end\n            end\n          end\n          expected += 1 if isMatch\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'family' => search_string\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se03p_search_patient_resource_on_partial_family_surname_test" }, { "key" : "SE04P", "id" : "SE04P", "description" : "Search patient resource on given name", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE04#{action[0]}\", 'Search patient resource on given name' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        search_string = @patient.name[0].given[0]\n        search_regex = Regexp.new(search_string)\n        # how many patients in the bundle have matching names?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          isMatch = false\n          if !patient.nil? && !patient.name.nil?\n            patient.name.each do |name|\n              if !name.given.nil?\n                name.given.each do |given|\n                  if !(given =~ search_regex).nil?\n                    isMatch = true\n                  end\n                end\n              end\n            end\n          end\n          expected += 1 if isMatch\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'given' => search_string\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se04p_search_patient_resource_on_given_name_test" }, { "key" : "SE05.0P", "id" : "SE05.0P", "description" : "Search condition by patient reference url (partial)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.0#{action[0]}\", 'Search condition by patient reference url (partial)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.resource_url(options)\n        patient_url = patient_url[1..-1] if patient_url[0]=='/'\n        @client.use_format_param = temp\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.0p_search_condition_by_patient_reference_url_(partial)_test" }, { "key" : "SE05.0FP", "id" : "SE05.0FP", "description" : "Search condition by patient reference url (full)", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.0F#{action[0]}\", 'Search condition by patient reference url (full)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.full_resource_url(options)\n        @client.use_format_param = temp\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.0fp_search_condition_by_patient_reference_url_(full)_test" }, { "key" : "SE05.1P", "id" : "SE05.1P", "description" : "Search condition by patient reference id", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.1#{action[0]}\", 'Search condition by patient reference id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.1p_search_condition_by_patient_reference_id_test" }, { "key" : "SE05.2P", "id" : "SE05.2P", "description" : "Search condition by patient:Patient reference url", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.2#{action[0]}\", 'Search condition by patient:Patient reference url' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.resource_url(options)\n        patient_url = patient_url[1..-1] if patient_url[0]=='/'\n        @client.use_format_param = temp\n       \n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient:Patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.2p_search_condition_by_patient:patient_reference_url_test" }, { "key" : "SE05.3P", "id" : "SE05.3P", "description" : "Search condition by patient:Patient reference id", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.3#{action[0]}\", 'Search condition by patient:Patient reference id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient = @entries[0].resource\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient:Patient' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.3p_search_condition_by_patient:patient_reference_id_test" }, { "key" : "SE05.4P", "id" : "SE05.4P", "description" : "Search condition by patient:_id reference", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.4#{action[0]}\", 'Search condition by patient:_id reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient._id' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.4p_search_condition_by_patient:_id_reference_test" }, { "key" : "SE05.5P", "id" : "SE05.5P", "description" : "Search condition by patient:name reference", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.5#{action[0]}\", 'Search condition by patient:name reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_name = @patient.name[0].family[0]\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient.name' => patient_name\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.5p_search_condition_by_patient:name_reference_test" }, { "key" : "SE05.6P", "id" : "SE05.6P", "description" : "Search condition by patient:identifier reference", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.6#{action[0]}\", 'Search condition by patient:identifier reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @patient_id\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_identifier = @patient.identifier[0].value\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient.identifier' => patient_identifier\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.6p_search_condition_by_patient:identifier_reference_test" }, { "key" : "SE06P", "id" : "SE06P", "description" : "Search condition and _include", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE06#{action[0]}\", 'Search condition and _include' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @patient_id\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_identifier = @patient.identifier[0].value\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_include' => 'Condition:patient'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert reply.resource.total > 0, 'The server should have Conditions that _include=Condition:patient.'\n        has_patient = false\n        reply.resource.entry.each do |entry|\n          has_patient = true if (entry.resourceType == 'Patient')\n        end\n        assert(has_patient,'The server did not include the Patient referenced in the Condition.', reply.body)\n      end\n", "test_method" : "se06p_search_condition_and__include_test" }, { "key" : "SE21P", "id" : "SE21P", "description" : "Search for quantity (in observation) - precision tests", "status" : "skip", "message" : "Skipped: se21p_search_for_quantity_(in_observation)_-_precision_tests_test", "data" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html#quantity", "http://hl7.org/fhir/DSTU2/observation.html#search" ], "code" : "      test \"SE21#{action[0]}\", 'Search for quantity (in observation) - precision tests' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html#quantity\"\n          links \"#{BASE_SPEC_LINK}/observation.html#search\"\n          validates resource: \"Observation\", methods: [\"search\"]\n        }\n        skip unless (@obs_a && @obs_b && @obs_c)\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'value-quantity' => '4.1234||mmol'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Observation, options)\n        has_obs_a = has_obs_b = has_obs_c = false\n        while reply != nil\n          assert_response_ok(reply)\n          assert_bundle_response(reply)\n          has_obs_a = true if reply.resource.get_by_id(@obs_a)\n          has_obs_b = true if reply.resource.get_by_id(@obs_b)\n          has_obs_c = true if reply.resource.get_by_id(@obs_c)\n          reply = @client.next_page(reply)\n        end\n\n        assert has_obs_a,  'Search on quantity value 4.1234 should return 4.12345'\n        assert !has_obs_b, 'Search on quantity value 4.1234 should not return 4.12346'\n        assert !has_obs_c, 'Search on quantity value 4.1234 should not return 4.12349'\n      end\n", "test_method" : "se21p_search_for_quantity_(in_observation)_-_precision_tests_test" }, { "key" : "SE22P", "id" : "SE22P", "description" : "Search for quantity (in observation) - operators", "status" : "skip", "message" : "Skipped: se22p_search_for_quantity_(in_observation)_-_operators_test", "data" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html#quantity", "http://hl7.org/fhir/DSTU2/observation.html#search" ], "code" : "      test \"SE22#{action[0]}\", 'Search for quantity (in observation) - operators' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html#quantity\"\n          links \"#{BASE_SPEC_LINK}/observation.html#search\"\n          validates resource: \"Observation\", methods: [\"search\"]\n        }\n        skip unless (@obs_a && @obs_d && @obs_e)\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'value-quantity' => 'gt5||mmol'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Observation, options)\n        has_obs_a = has_obs_b = has_obs_c = false\n        while reply != nil\n          assert_response_ok(reply)\n          assert_bundle_response(reply)\n          has_obs_a = true if reply.resource.get_by_id(@obs_a)\n          has_obs_d = true if reply.resource.get_by_id(@obs_d)\n          has_obs_e = true if reply.resource.get_by_id(@obs_e)\n          reply = @client.next_page(reply)\n        end\n\n        assert !has_obs_a,  'Search greater than quantity should not return lesser value.'\n        assert has_obs_d, 'Search greater than quantity should return greater value.'\n        assert has_obs_e, 'Search greater than quantity should return greater value.'\n      end\n", "test_method" : "se22p_search_for_quantity_(in_observation)_-_operators_test" }, { "key" : "SE23P", "id" : "SE23P", "description" : "Search with quantifier :missing, on Patient.gender", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE23#{action[0]}\", 'Search with quantifier :missing, on Patient.gender' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # how many patients in the bundle have no gender?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          expected += 1 if !patient.nil? && patient.gender.nil?\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'gender:missing' => true\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se23p_search_with_quantifier_:missing,_on_patient.gender_test" }, { "key" : "SE24P", "id" : "SE24P", "description" : "Search with non-existing parameter", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE24#{action[0]}\", 'Search with non-existing parameter' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        # non-existing parameters should be ignored\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'bonkers' => 'foobar'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "se24p_search_with_non-existing_parameter_test" }, { "key" : "SE25P", "id" : "SE25P", "description" : "Search with malformed parameters", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 405. ", "data" : "{\"Message\":\"The requested resource does not support http method 'POST'.\"}", "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE25#{action[0]}\", 'Search with malformed parameters' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        # a malformed parameters are non-existing parameters, and they should be ignored\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '...' => 'foobar'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "se25p_search_with_malformed_parameters_test" }, { "key" : "SE01G", "id" : "SE01G", "description" : "Search patients without criteria (except _count)", "status" : "pass", "message" : null, "warnings" : [ "The server did not report the correct number of results. Expected: 1, but found: 311." ], "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html" ], "code" : "      test \"SE01#{action[0]}\",'Search patients without criteria (except _count)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_count' => '1'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.entry.size, 'The server did not return the correct number of results.'\n        warning { assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.' }\n      end\n", "test_method" : "se01g_search_patients_without_criteria_(except__count)_test" }, { "key" : "SE02G", "id" : "SE02G", "description" : "Search on non-existing resource", "status" : "pass", "message" : null, "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html" ], "code" : "      test \"SE02#{action[0]}\", 'Search on non-existing resource' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n        }\n        options = {\n          :resource => Crucible::Tests::SprinklerSearchTest,\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => nil\n          }\n        }\n        reply = @client.search_all(options)\n        assert( (reply.code >= 400 && reply.code < 600), 'If the search fails, the return value should be status code 4xx or 5xx.', reply)\n      end\n", "test_method" : "se02g_search_on_non-existing_resource_test" }, { "key" : "SE03G", "id" : "SE03G", "description" : "Search patient resource on partial family surname", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 2, but found: 0.", "data" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE03#{action[0]}\",'Search patient resource on partial family surname' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        search_string = @patient.name[0].family[0][0..2]\n        search_regex = Regexp.new(search_string)\n        # how many patients in the bundle have matching names?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          isMatch = false\n          if !patient.nil? && !patient.name.nil?\n            patient.name.each do |name|\n              if !name.family.nil?\n                name.family.each do |family|\n                  if !(family =~ search_regex).nil?\n                    isMatch = true\n                  end\n                end\n              end\n            end\n          end\n          expected += 1 if isMatch\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'family' => search_string\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se03g_search_patient_resource_on_partial_family_surname_test" }, { "key" : "SE04G", "id" : "SE04G", "description" : "Search patient resource on given name", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 3, but found: 0.", "data" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE04#{action[0]}\", 'Search patient resource on given name' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        search_string = @patient.name[0].given[0]\n        search_regex = Regexp.new(search_string)\n        # how many patients in the bundle have matching names?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          isMatch = false\n          if !patient.nil? && !patient.name.nil?\n            patient.name.each do |name|\n              if !name.given.nil?\n                name.given.each do |given|\n                  if !(given =~ search_regex).nil?\n                    isMatch = true\n                  end\n                end\n              end\n            end\n          end\n          expected += 1 if isMatch\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'given' => search_string\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se04g_search_patient_resource_on_given_name_test" }, { "key" : "SE05.0G", "id" : "SE05.0G", "description" : "Search condition by patient reference url (partial)", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 1, but found: 0.", "data" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.0#{action[0]}\", 'Search condition by patient reference url (partial)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.resource_url(options)\n        patient_url = patient_url[1..-1] if patient_url[0]=='/'\n        @client.use_format_param = temp\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.0g_search_condition_by_patient_reference_url_(partial)_test" }, { "key" : "SE05.0FG", "id" : "SE05.0FG", "description" : "Search condition by patient reference url (full)", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 1, but found: 0.", "data" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.0F#{action[0]}\", 'Search condition by patient reference url (full)' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.full_resource_url(options)\n        @client.use_format_param = temp\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.0fg_search_condition_by_patient_reference_url_(full)_test" }, { "key" : "SE05.1G", "id" : "SE05.1G", "description" : "Search condition by patient reference id", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 1, but found: 0.", "data" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.1#{action[0]}\", 'Search condition by patient reference id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.1g_search_condition_by_patient_reference_id_test" }, { "key" : "SE05.2G", "id" : "SE05.2G", "description" : "Search condition by patient:Patient reference url", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 1, but found: 23.", "data" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.2#{action[0]}\", 'Search condition by patient:Patient reference url' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        options = {\n          :id => @entries[0].resource.xmlId,\n          :resource => @entries[0].resource.class\n        }\n        temp = @client.use_format_param\n        @client.use_format_param = false\n        patient_url = @client.resource_url(options)\n        patient_url = patient_url[1..-1] if patient_url[0]=='/'\n        @client.use_format_param = temp\n       \n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient:Patient' => patient_url\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.2g_search_condition_by_patient:patient_reference_url_test" }, { "key" : "SE05.3G", "id" : "SE05.3G", "description" : "Search condition by patient:Patient reference id", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 1, but found: 23.", "data" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.3#{action[0]}\", 'Search condition by patient:Patient reference id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient = @entries[0].resource\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient:Patient' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.3g_search_condition_by_patient:patient_reference_id_test" }, { "key" : "SE05.4G", "id" : "SE05.4G", "description" : "Search condition by patient:_id reference", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 1, but found: 23.", "data" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.4#{action[0]}\", 'Search condition by patient:_id reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_id = @entries[0].resource.xmlId\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient._id' => patient_id\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.4g_search_condition_by_patient:_id_reference_test" }, { "key" : "SE05.5G", "id" : "SE05.5G", "description" : "Search condition by patient:name reference", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 1, but found: 23.", "data" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.5#{action[0]}\", 'Search condition by patient:name reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_name = @patient.name[0].family[0]\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient.name' => patient_name\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.5g_search_condition_by_patient:name_reference_test" }, { "key" : "SE05.6G", "id" : "SE05.6G", "description" : "Search condition by patient:identifier reference", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 1, but found: 23.", "data" : null, "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE05.6#{action[0]}\", 'Search condition by patient:identifier reference' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @patient_id\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_identifier = @patient.identifier[0].value\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'patient.identifier' => patient_identifier\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal 1, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se05.6g_search_condition_by_patient:identifier_reference_test" }, { "key" : "SE06G", "id" : "SE06G", "description" : "Search condition and _include", "status" : "fail", "message" : "The server did not include the Patient referenced in the Condition.", "data" : "﻿<Bundle xmlns=\"http://hl7.org/fhir\"><id value=\"urn:uuid:14acf86fe150472f90ca7a78317353e5\" /><meta><lastUpdated value=\"2015-10-02T23:00:15.166+00:00\" /></meta><type value=\"searchset\" /><total value=\"23\" /><link><relation value=\"self\" /><url value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition?_format=application/xml+fhir&amp;_include=Condition:patient&amp;_snapshot=635794236151661956\" /></link><link><relation value=\"first\" /><url value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition?_format=application/xml+fhir&amp;_include=Condition:patient&amp;_snapshot=635794236151661956\" /></link><link><relation value=\"next\" /><url value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition?_format=application/xml+fhir&amp;_include=Condition:patient&amp;_snapshot=635794236151661956&amp;_page=1\" /></link><link><relation value=\"last\" /><url value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition?_format=application/xml+fhir&amp;_include=Condition:patient&amp;_snapshot=635794236151661956&amp;_page=1\" /></link><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/fb4fb6a6076e4d54814cafacb96191d3/_history/47\" /><resource><Condition><id value=\"fb4fb6a6076e4d54814cafacb96191d3\" /><meta><versionId value=\"47\" /><lastUpdated value=\"2015-10-02T22:39:52.307+00:00\" /></meta><implicitRules value=\"k7UL+e8vKOr7JNZlsMIDeg==\" /><language value=\"en-US\" /><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f002</p>\r\n  <p>\r\n    <b>patient</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Encounter/f002</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 03/06/2012</p>\r\n  <p>\r\n    <b>code</b>: NSCLC - Non-small cell lung cancer <span>(Details : {SNOMED CT code '254637007' = '254637007', given as 'NSCLC - Non-small cell lung cancer'})</span></p>\r\n  <p>\r\n    <b>category</b>: diagnosis <span>(Details : {SNOMED CT code '439401001' = '439401001', given as 'diagnosis'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Severe <span>(Details : {SNOMED CT code '24484000' = '24484000', given as 'Severe'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 05/05/2011</p>\r\n  <h3>Stages</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Summary</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>stage II <span>(Details : {SNOMED CT code '258219007' = '258219007', given as 'stage II'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Code</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>CT of thorax <span>(Details : {SNOMED CT code '169069000' = '169069000', given as 'CT of thorax'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Thorax <span>(Details : {SNOMED CT code '51185008' = '51185008', given as 'Thorax'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></patient><encounter><reference value=\"Encounter/f002\" /></encounter><asserter><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></asserter><dateRecorded value=\"2015-10-02\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"254637007\" /><display value=\"NSCLC - Non-small cell lung cancer\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"439401001\" /><display value=\"diagnosis\" /></coding></category><clinicalStatus value=\"resolved\" /><verificationStatus value=\"refuted\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"24484000\" /><display value=\"Severe\" /></coding></severity><onsetDateTime value=\"2011-05-05\" /><stage><summary><coding><system value=\"http://snomed.info/sct\" /><code value=\"258219007\" /><display value=\"stage II\" /></coding></summary></stage><evidence><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"169069000\" /><display value=\"CT of thorax\" /></coding></code></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"51185008\" /><display value=\"Thorax\" /></coding></bodySite><notes value=\"EeJy9bl69PMtbaoQ3GjyEQ==\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/fb4fb6a6076e4d54814cafacb96191d3/_history/47\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/f64b8c0a4f6941f6b0caf150e28c50d8/_history/22\" /><resource><Condition><id value=\"f64b8c0a4f6941f6b0caf150e28c50d8\" /><meta><versionId value=\"22\" /><lastUpdated value=\"2015-09-29T11:46:53.04+00:00\" /></meta><implicitRules value=\"2rV0CbZdr0jzlFLwtB6Rbg==\" /><language value=\"mJEmqoLoAzICvuIJ4lzM\" /><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: Apr 4, 2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/f05ce89900d74949a29b6c0e315b89ab\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/8eb06628d1864005be9c4669f91107c3\" /></asserter><dateRecorded value=\"2015-09-24\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"resolved\" /><verificationStatus value=\"differential\" /><notes value=\"0vJafgEq+WjKCKHdPJMnqg==\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/f64b8c0a4f6941f6b0caf150e28c50d8/_history/22\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/e538f73dc9d3438ca83bcd0476ee4cbd/_history/21\" /><resource><Condition><id value=\"e538f73dc9d3438ca83bcd0476ee4cbd\" /><meta><versionId value=\"21\" /><lastUpdated value=\"2015-09-29T11:46:52.953+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">Ischemic stroke, July 18, 2010</div></text><patient><reference value=\"Patient/example\" /></patient><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"422504002\" /><display value=\"Ischemic stroke (disorder)\" /></coding><text value=\"Stroke\" /></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /><display value=\"Diagnosis\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><onsetDateTime value=\"2010-07-18\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/e538f73dc9d3438ca83bcd0476ee4cbd/_history/21\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/e2744e5eda674fb79ac25f7c052bbcd1/_history/20\" /><resource><Condition><id value=\"e2744e5eda674fb79ac25f7c052bbcd1\" /><meta><versionId value=\"20\" /><lastUpdated value=\"2015-09-29T11:46:52.92+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f204</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Roel's encounter on March eleventh</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 11/03/2013</p>\r\n  <p>\r\n    <b>code</b>: Acute renal insufficiency specified as due to procedure <span>(Details : {SNOMED CT code '36225005' = '36225005', given as 'Acute renal insufficiency specified as due to procedure'})</span></p>\r\n  <p>\r\n    <b>category</b>: Problem <span>(Details : {SNOMED CT code '55607006' = '55607006', given as 'Problem'}; {http://hl7.org/fhir/condition-category code 'finding' = 'Finding)</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n  <p>\r\n    <b>severity</b>: Severe <span>(Details : {SNOMED CT code '24484000' = '24484000', given as 'Severe'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 11/03/2013</p>\r\n  <p>\r\n    <b>abatement</b>: 20/03/2013</p>\r\n  <h3>Stages</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Summary</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>Temporary <span>(Details : {SNOMED CT code '14803004' = '14803004', given as 'Temporary'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Kidney <span>(Details : {SNOMED CT code '181414000' = '181414000', given as 'Kidney'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><encounter><reference value=\"Encounter/f203\" /><display value=\"Roel's encounter on March eleventh\" /></encounter><asserter><reference value=\"Practitioner/f201\" /></asserter><dateRecorded value=\"2013-03-11\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"36225005\" /><display value=\"Acute renal insufficiency specified as due to procedure\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"55607006\" /><display value=\"Problem\" /></coding><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"finding\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"differential\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"24484000\" /><display value=\"Severe\" /></coding></severity><onsetDateTime value=\"2013-03-11\" /><abatementDateTime value=\"2013-03-20\" /><stage><summary><coding><system value=\"http://snomed.info/sct\" /><code value=\"14803004\" /><display value=\"Temporary\" /></coding></summary></stage><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"181414000\" /><display value=\"Kidney\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/e2744e5eda674fb79ac25f7c052bbcd1/_history/20\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/e1becf46200746f69811c853e0243def/_history/19\" /><resource><Condition><id value=\"e1becf46200746f69811c853e0243def\" /><meta><versionId value=\"19\" /><lastUpdated value=\"2015-09-29T11:46:52.89+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: cond-uslab-example1</p>\r\n  <p>\r\n    <b>patient</b>: <a>Todd Lerr</a></p>\r\n  <p>\r\n    <b>code</b>: Increased lead level <span>(Details : {SNOMED CT code '407152001' = '407152001', given as 'Increased blood lead level'})</span></p>\r\n  <p>\r\n    <b>category</b>: Diagnosis <span>(Details : {http://hl7.org/fhir/condition-category code 'diagnosis' = 'Diagnosis', given as 'Diagnosis'})</span></p>\r\n  <p>\r\n    <b>verificationStatus</b>: provisional</p>\r\n  <p>\r\n    <b>notes</b>: Elevated lead levels on screening</p>\r\n</div></text><patient><reference value=\"Patient/patient-uslab-example1\" /><display value=\"Todd Lerr\" /></patient><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"407152001\" /><display value=\"Increased blood lead level\" /></coding><text value=\"Increased lead level\" /></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /><display value=\"Diagnosis\" /></coding></category><verificationStatus value=\"provisional\" /><notes value=\"Elevated lead levels on screening\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/e1becf46200746f69811c853e0243def/_history/19\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/e1ad86a294234fc3887dfdb7e3041ece/_history/18\" /><resource><Condition><id value=\"e1ad86a294234fc3887dfdb7e3041ece\" /><meta><versionId value=\"18\" /><lastUpdated value=\"2015-09-29T11:46:52.843+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: Apr 4, 2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/3631114706dd425582ffcb9ce51d0445\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/88e335d1546743728f2581e12c29429f\" /></asserter><dateRecorded value=\"2013-04-04\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"active\" /><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/e1ad86a294234fc3887dfdb7e3041ece/_history/18\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/cfba157a60924338aefaeed951022307/_history/17\" /><resource><Condition><id value=\"cfba157a60924338aefaeed951022307\" /><meta><versionId value=\"17\" /><lastUpdated value=\"2015-09-29T11:46:52.813+00:00\" /></meta><implicitRules value=\"2rV0CbZdr0jzlFLwtB6Rbg==\" /><language value=\"mJEmqoLoAzICvuIJ4lzM\" /><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: Apr 4, 2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/f05ce89900d74949a29b6c0e315b89ab\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/8eb06628d1864005be9c4669f91107c3\" /></asserter><dateRecorded value=\"2015-09-24\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"resolved\" /><verificationStatus value=\"differential\" /><notes value=\"0vJafgEq+WjKCKHdPJMnqg==\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/cfba157a60924338aefaeed951022307/_history/17\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/cb34abce81a143808e58ac12a9ced226/_history/16\" /><resource><Condition><id value=\"cb34abce81a143808e58ac12a9ced226\" /><meta><versionId value=\"16\" /><lastUpdated value=\"2015-09-29T11:46:52.78+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f201</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Encounter/f201</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 04/04/2013</p>\r\n  <p>\r\n    <b>code</b>: Fever <span>(Details : {SNOMED CT code '386661006' = '386661006', given as 'Fever'})</span></p>\r\n  <p>\r\n    <b>category</b>: Problem <span>(Details : {SNOMED CT code '55607006' = '55607006', given as 'Problem'}; {http://hl7.org/fhir/condition-category code 'finding' = 'Finding)</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Mild <span>(Details : {SNOMED CT code '255604002' = '255604002', given as 'Mild'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 02/04/2013</p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Code</b>\r\n      </td>\r\n      <td>\r\n        <b>Detail</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>degrees C <span>(Details : {SNOMED CT code '258710007' = '258710007', given as 'degrees C'})</span></td>\r\n      <td>\r\n        <a>Temperature</a>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Entire body as a whole <span>(Details : {SNOMED CT code '38266002' = '38266002', given as 'Entire body as a whole'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><encounter><reference value=\"Encounter/f201\" /></encounter><asserter><reference value=\"Practitioner/f201\" /></asserter><dateRecorded value=\"2013-04-04\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"386661006\" /><display value=\"Fever\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"55607006\" /><display value=\"Problem\" /></coding><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"finding\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"255604002\" /><display value=\"Mild\" /></coding></severity><onsetDateTime value=\"2013-04-02\" /><evidence><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"258710007\" /><display value=\"degrees C\" /></coding></code><detail><reference value=\"Observation/f202\" /><display value=\"Temperature\" /></detail></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"38266002\" /><display value=\"Entire body as a whole\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/cb34abce81a143808e58ac12a9ced226/_history/16\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/be0ea600c75d4e1abebc9b3d3b3ee815/_history/15\" /><resource><Condition><id value=\"be0ea600c75d4e1abebc9b3d3b3ee815\" /><meta><versionId value=\"15\" /><lastUpdated value=\"2015-09-29T11:46:52.75+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <div>code:Posttraumatic stress disorder (disorder)</div>\r\n  <div>verificationStatus:confirmed</div>\r\n  <div>abatementDate:1975-04-14T00:00:00-04:00</div>\r\n  <div>onsetDate:1975-04-14T00:00:00-04:00</div>\r\n</div></text><patient><reference value=\"Patient/zachary-broussard\" /><display value=\"Zachary Broussard\" /></patient><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"47505003\" /><display value=\"Posttraumatic stress disorder (disorder)\" /></coding><text value=\"Posttraumatic stress disorder (disorder)\" /></code><verificationStatus value=\"confirmed\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/be0ea600c75d4e1abebc9b3d3b3ee815/_history/15\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/bb0bca2f094648918ce71feb486ec48f/_history/14\" /><resource><Condition><id value=\"bb0bca2f094648918ce71feb486ec48f\" /><meta><versionId value=\"14\" /><lastUpdated value=\"2015-09-29T11:46:52.717+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f001</p>\r\n  <p>\r\n    <b>patient</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Encounter/f001</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 05/10/2011</p>\r\n  <p>\r\n    <b>code</b>: Heart valve disorder <span>(Details : {SNOMED CT code '368009' = '368009', given as 'Heart valve disorder'})</span></p>\r\n  <p>\r\n    <b>category</b>: diagnosis <span>(Details : {SNOMED CT code '439401001' = '439401001', given as 'diagnosis'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Moderate <span>(Details : {SNOMED CT code '6736007' = '6736007', given as 'Moderate'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 05/08/2011</p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Code</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>Cardiac chest pain <span>(Details : {SNOMED CT code '426396005' = '426396005', given as 'Cardiac chest pain'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: heart structure <span>(Details : {SNOMED CT code '40768004' = '40768004', given as 'Left thorax'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></patient><encounter><reference value=\"Encounter/f001\" /></encounter><asserter><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></asserter><dateRecorded value=\"2011-10-05\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"368009\" /><display value=\"Heart valve disorder\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"439401001\" /><display value=\"diagnosis\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"6736007\" /><display value=\"Moderate\" /></coding></severity><onsetDateTime value=\"2011-08-05\" /><evidence><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"426396005\" /><display value=\"Cardiac chest pain\" /></coding></code></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"40768004\" /><display value=\"Left thorax\" /></coding><text value=\"heart structure\" /></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/bb0bca2f094648918ce71feb486ec48f/_history/14\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/a8b25a8b7ef34e74ba95c31fd140e6c4/_history/13\" /><resource><Condition><id value=\"a8b25a8b7ef34e74ba95c31fd140e6c4\" /><meta><versionId value=\"13\" /><lastUpdated value=\"2015-09-29T11:46:52.703+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f203</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Roel's encounter on March eleventh</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 11/03/2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial sepsis <span>(Details : {SNOMED CT code '10001005' = '10001005', given as 'Bacterial sepsis'})</span></p>\r\n  <p>\r\n    <b>category</b>: Problem <span>(Details : {SNOMED CT code '55607006' = '55607006', given as 'Problem'}; {http://hl7.org/fhir/condition-category code 'finding' = 'Finding)</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Moderate to severe <span>(Details : {SNOMED CT code '371924009' = '371924009', given as 'Moderate to severe'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 08/03/2013</p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Detail</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>\r\n        <a>Diagnostic report for Roel's sepsis</a>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Pulmonary vascular structure <span>(Details : {SNOMED CT code '281158006' = '281158006', given as 'Pulmonary vascular structure'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><encounter><reference value=\"Encounter/f203\" /><display value=\"Roel's encounter on March eleventh\" /></encounter><asserter><reference value=\"Practitioner/f201\" /></asserter><dateRecorded value=\"2013-03-11\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"10001005\" /><display value=\"Bacterial sepsis\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"55607006\" /><display value=\"Problem\" /></coding><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"finding\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"371924009\" /><display value=\"Moderate to severe\" /></coding></severity><onsetDateTime value=\"2013-03-08\" /><evidence><detail><reference value=\"DiagnosticReport/f202\" /><display value=\"Diagnostic report for Roel's sepsis\" /></detail></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"281158006\" /><display value=\"Pulmonary vascular structure\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/a8b25a8b7ef34e74ba95c31fd140e6c4/_history/13\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/9833268b2e5f491b98a1a5c0e535b813/_history/12\" /><resource><Condition><id value=\"9833268b2e5f491b98a1a5c0e535b813\" /><meta><versionId value=\"12\" /><lastUpdated value=\"2015-09-29T11:46:52.67+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">Severe burn of left ear (Date: 24-May 2012)</div></text><extension url=\"http://hl7.org/fhir/StructureDefinition/condition-criticality\"><valueCodeableConcept><coding><system value=\"http://hl7.org/fhir/ValueSet/condition-severity\" /><code value=\"399166001\" /><display value=\"Fatal\" /></coding></valueCodeableConcept></extension><patient><reference value=\"Patient/example\" /></patient><code><coding><system value=\"http://hl7.org/fhir/ValueSet/daf-problem\" /><code value=\"39065001\" /><display value=\"Burn of ear\" /></coding><text value=\"Burnt Ear\" /></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /><display value=\"Diagnosis\" /></coding><coding><system value=\"http://snomed.info/sct\" /><code value=\"439401001\" /><display value=\"Diagnosis\" /></coding></category><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"24484000\" /><display value=\"Severe\" /></coding></severity><onsetDateTime value=\"2012-05-24\" /><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"49521004\" /><display value=\"Left external ear structure\" /></coding><text value=\"Left Ear\" /></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/9833268b2e5f491b98a1a5c0e535b813/_history/12\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/9054892526b04a3ab94a2264a8d9a9ee/_history/11\" /><resource><Condition><id value=\"9054892526b04a3ab94a2264a8d9a9ee\" /><meta><versionId value=\"11\" /><lastUpdated value=\"2015-09-29T11:46:52.61+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <div xmlns=\"\">code:asthma</div>\r\n  <div xmlns=\"\">verificationStatus:differential</div>\r\n</div></text><patient><reference value=\"Patient/5df8b715b3ed4225b72869dc984cf364\" /><display value=\"david hay \" /></patient><code><text value=\"asthma\" /></code><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/9054892526b04a3ab94a2264a8d9a9ee/_history/11\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/786dbc25d9a14687b4225fa3b5f71932/_history/10\" /><resource><Condition><id value=\"786dbc25d9a14687b4225fa3b5f71932\" /><meta><versionId value=\"10\" /><lastUpdated value=\"2015-09-29T11:46:52.53+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f202</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 01/12/2012</p>\r\n  <p>\r\n    <b>code</b>: Malignant neoplastic disease <span>(Details : {SNOMED CT code '363346000' = '363346000', given as 'Malignant neoplastic disease'})</span></p>\r\n  <p>\r\n    <b>category</b>: Diagnosis <span>(Details : {http://hl7.org/fhir/condition-category code 'diagnosis' = 'Diagnosis)</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Severe <span>(Details : {SNOMED CT code '24484000' = '24484000', given as 'Severe'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 52 years<span> (Details: SNOMED CT code 258707000 = '258707000')</span></p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Detail</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>\r\n        <a>Erasmus' diagnostic report of Roel's tumor</a>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Entire head and neck <span>(Details : {SNOMED CT code '361355005' = '361355005', given as 'Entire head and neck'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><dateRecorded value=\"2012-12-01\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"363346000\" /><display value=\"Malignant neoplastic disease\" /></coding></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"24484000\" /><display value=\"Severe\" /></coding></severity><onsetQuantity><value value=\"52\" /><unit value=\"years\" /><system value=\"http://snomed.info/sct\" /><code value=\"258707000\" /></onsetQuantity><evidence><detail><reference value=\"DiagnosticReport/f201\" /><display value=\"Erasmus' diagnostic report of Roel's tumor\" /></detail></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"361355005\" /><display value=\"Entire head and neck\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/786dbc25d9a14687b4225fa3b5f71932/_history/10\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/68d1644650ac47109c148d18d7c31e94/_history/9\" /><resource><Condition><id value=\"68d1644650ac47109c148d18d7c31e94\" /><meta><versionId value=\"9\" /><lastUpdated value=\"2015-09-29T11:46:52.5+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 04/04/2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/f201\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/f201\" /></asserter><dateRecorded value=\"2013-04-04\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"active\" /><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/68d1644650ac47109c148d18d7c31e94/_history/9\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/50c57f80063742628757a5e9252ac804/_history/8\" /><resource><Condition><id value=\"50c57f80063742628757a5e9252ac804\" /><meta><versionId value=\"8\" /><lastUpdated value=\"2015-09-29T11:46:52.483+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <div xmlns=\"\">code:Asthma finding (finding)</div>\r\n  <div xmlns=\"\">verificationStatus:differential</div>\r\n</div></text><patient><reference value=\"Patient/89780f9eb9ab41da8ed0189807c55150\" /><display value=\"david hay\" /></patient><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"390798007\" /><display value=\"Asthma finding (finding)\" /></coding><text value=\"Asthma finding (finding)\" /></code><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/50c57f80063742628757a5e9252ac804/_history/8\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/478e0a37381f47f3ae69afd67d77c7df/_history/7\" /><resource><Condition><id value=\"478e0a37381f47f3ae69afd67d77c7df\" /><meta><versionId value=\"7\" /><lastUpdated value=\"2015-09-29T11:46:52.437+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f205</p>\r\n  <p>\r\n    <b>patient</b>: <a>Roel</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>Practitioner/f201</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: Apr 4, 2013</p>\r\n  <p>\r\n    <b>code</b>: Bacterial infectious disease <span>(Details : {SNOMED CT code '87628006' = '87628006', given as 'Bacterial infectious disease'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: differential</p>\r\n</div></text><patient><reference value=\"Patient/c919e3aa2e3f4ca1bc5e08c7c802f9f4\" /><display value=\"Roel\" /></patient><asserter><reference value=\"Practitioner/0e473e39e9b24ea896cc48fa22ec343b\" /></asserter><dateRecorded value=\"2013-04-04\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"87628006\" /><display value=\"Bacterial infectious disease\" /></coding></code><clinicalStatus value=\"active\" /><verificationStatus value=\"differential\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/478e0a37381f47f3ae69afd67d77c7df/_history/7\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/3f86216bef164c15a92360dba2ef5b28/_history/6\" /><resource><Condition><id value=\"3f86216bef164c15a92360dba2ef5b28\" /><meta><versionId value=\"6\" /><lastUpdated value=\"2015-09-29T11:46:52.407+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: f003</p>\r\n  <p>\r\n    <b>patient</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>encounter</b>: <a>Encounter/f003</a></p>\r\n  <p>\r\n    <b>asserter</b>: <a>P. van de Heuvel</a></p>\r\n  <p>\r\n    <b>dateRecorded</b>: 20/02/2012</p>\r\n  <p>\r\n    <b>code</b>: Retropharyngeal abscess <span>(Details : {SNOMED CT code '18099001' = '18099001', given as 'Retropharyngeal abscess'})</span></p>\r\n  <p>\r\n    <b>category</b>: diagnosis <span>(Details : {SNOMED CT code '439401001' = '439401001', given as 'diagnosis'})</span></p>\r\n  <p>\r\n    <b>clinicalStatus</b>: active</p>\r\n  <p>\r\n    <b>verificationStatus</b>: confirmed</p>\r\n  <p>\r\n    <b>severity</b>: Mild to moderate <span>(Details : {SNOMED CT code '371923003' = '371923003', given as 'Mild to moderate'})</span></p>\r\n  <p>\r\n    <b>onset</b>: 27/02/2012</p>\r\n  <h3>Evidences</h3>\r\n  <table>\r\n    <tr>\r\n      <td>-</td>\r\n      <td>\r\n        <b>Code</b>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>*</td>\r\n      <td>CT of neck <span>(Details : {SNOMED CT code '169068008' = '169068008', given as 'CT of neck'})</span></td>\r\n    </tr>\r\n  </table>\r\n  <p>\r\n    <b>bodySite</b>: Entire retropharyngeal area <span>(Details : {SNOMED CT code '280193007' = '280193007', given as 'Entire retropharyngeal area'})</span></p>\r\n</div></text><patient><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></patient><encounter><reference value=\"Encounter/f003\" /></encounter><asserter><reference value=\"Patient/f001\" /><display value=\"P. van de Heuvel\" /></asserter><dateRecorded value=\"2012-02-20\" /><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"18099001\" /><display value=\"Retropharyngeal abscess\" /></coding></code><category><coding><system value=\"http://snomed.info/sct\" /><code value=\"439401001\" /><display value=\"diagnosis\" /></coding></category><clinicalStatus value=\"active\" /><verificationStatus value=\"confirmed\" /><severity><coding><system value=\"http://snomed.info/sct\" /><code value=\"371923003\" /><display value=\"Mild to moderate\" /></coding></severity><onsetDateTime value=\"2012-02-27\" /><evidence><code><coding><system value=\"http://snomed.info/sct\" /><code value=\"169068008\" /><display value=\"CT of neck\" /></coding></code></evidence><bodySite><coding><system value=\"http://snomed.info/sct\" /><code value=\"280193007\" /><display value=\"Entire retropharyngeal area\" /></coding></bodySite></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/3f86216bef164c15a92360dba2ef5b28/_history/6\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/3df918d8e4774a91a9f880e8be2b26ef/_history/5\" /><resource><Condition><id value=\"3df918d8e4774a91a9f880e8be2b26ef\" /><meta><versionId value=\"5\" /><lastUpdated value=\"2015-09-29T11:46:52.36+00:00\" /></meta><implicitRules value=\"jzDd7YdIROai9Tbh8ggiCw==\" /><language value=\"X3eCOckAXdynkLZep8Zb\" /><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <div xmlns=\"\">code:asthma</div>\r\n  <div xmlns=\"\">verificationStatus:confirmed</div>\r\n</div></text><patient><reference value=\"Patient/5df8b715b3ed4225b72869dc984cf364\" /><display value=\"david hay \" /></patient><asserter><reference value=\"Practitioner/38b041800a8a43d1952ecb43439192a6\" /><display value=\"Practitioner\" /></asserter><dateRecorded value=\"2015-09-16\" /><code><text value=\"asthma\" /></code><clinicalStatus value=\"resolved\" /><verificationStatus value=\"confirmed\" /><notes value=\"s6F3OF+VYbYTBZWnLmsI9Q==\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/3df918d8e4774a91a9f880e8be2b26ef/_history/5\" /></request></entry><entry><fullUrl value=\"http://sqlonfhir-dstu2.azurewebsites.net/fhir/Condition/36310207febe42a495b426169d36bb44/_history/4\" /><resource><Condition><id value=\"36310207febe42a495b426169d36bb44\" /><meta><versionId value=\"4\" /><lastUpdated value=\"2015-09-29T11:46:52.327+00:00\" /></meta><text><status value=\"generated\" /><div xmlns=\"http://www.w3.org/1999/xhtml\">\r\n  <p>\r\n    <b>Generated Narrative with Details</b>\r\n  </p>\r\n  <p>\r\n    <b>id</b>: cond-uslab-example2</p>\r\n  <p>\r\n    <b>patient</b>: <a>Todd Lerr</a></p>\r\n  <p>\r\n    <b>code</b>: Abnormal lead level in blood <span>(Details : {http://www.cms.gov/Medicare/Coding/ICD10/index.html code 'R78.71' = '??', given as 'Abnormal lead level in blood'})</span></p>\r\n  <p>\r\n    <b>category</b>: Diagnosis <span>(Details : {http://hl7.org/fhir/condition-category code 'diagnosis' = 'Diagnosis', given as 'Diagnosis'})</span></p>\r\n  <p>\r\n    <b>verificationStatus</b>: provisional</p>\r\n</div></text><patient><reference value=\"Patient/patient-uslab-example2\" /><display value=\"Todd Lerr\" /></patient><code><coding><system value=\"http://www.cms.gov/Medicare/Coding/ICD10/index.html\" /><code value=\"R78.71\" /><display value=\"Abnormal lead level in blood\" /></coding></code><category><coding><system value=\"http://hl7.org/fhir/condition-category\" /><code value=\"diagnosis\" /><display value=\"Diagnosis\" /></coding></category><verificationStatus value=\"provisional\" /></Condition></resource><request><method value=\"GET\" /><url value=\"Condition/36310207febe42a495b426169d36bb44/_history/4\" /></request></entry></Bundle>", "validates" : [ { "resource" : "Condition", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/condition.html#search" ], "code" : "      test \"SE06#{action[0]}\", 'Search condition and _include' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/condition.html#search\"\n          validates resource: \"Condition\", methods: [\"search\"]\n        }\n        skip unless @patient_id\n        # pick some search parameters... we previously created\n        # a condition for the first (0-index) patient in the setup method.\n        patient_identifier = @patient.identifier[0].value\n\n        # next, we're going execute a series of searches for conditions referencing the patient\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '_include' => 'Condition:patient'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Condition, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert reply.resource.total > 0, 'The server should have Conditions that _include=Condition:patient.'\n        has_patient = false\n        reply.resource.entry.each do |entry|\n          has_patient = true if (entry.resourceType == 'Patient')\n        end\n        assert(has_patient,'The server did not include the Patient referenced in the Condition.', reply.body)\n      end\n", "test_method" : "se06g_search_condition_and__include_test" }, { "key" : "SE21G", "id" : "SE21G", "description" : "Search for quantity (in observation) - precision tests", "status" : "skip", "message" : "Skipped: se21g_search_for_quantity_(in_observation)_-_precision_tests_test", "data" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html#quantity", "http://hl7.org/fhir/DSTU2/observation.html#search" ], "code" : "      test \"SE21#{action[0]}\", 'Search for quantity (in observation) - precision tests' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html#quantity\"\n          links \"#{BASE_SPEC_LINK}/observation.html#search\"\n          validates resource: \"Observation\", methods: [\"search\"]\n        }\n        skip unless (@obs_a && @obs_b && @obs_c)\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'value-quantity' => '4.1234||mmol'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Observation, options)\n        has_obs_a = has_obs_b = has_obs_c = false\n        while reply != nil\n          assert_response_ok(reply)\n          assert_bundle_response(reply)\n          has_obs_a = true if reply.resource.get_by_id(@obs_a)\n          has_obs_b = true if reply.resource.get_by_id(@obs_b)\n          has_obs_c = true if reply.resource.get_by_id(@obs_c)\n          reply = @client.next_page(reply)\n        end\n\n        assert has_obs_a,  'Search on quantity value 4.1234 should return 4.12345'\n        assert !has_obs_b, 'Search on quantity value 4.1234 should not return 4.12346'\n        assert !has_obs_c, 'Search on quantity value 4.1234 should not return 4.12349'\n      end\n", "test_method" : "se21g_search_for_quantity_(in_observation)_-_precision_tests_test" }, { "key" : "SE22G", "id" : "SE22G", "description" : "Search for quantity (in observation) - operators", "status" : "skip", "message" : "Skipped: se22g_search_for_quantity_(in_observation)_-_operators_test", "data" : null, "validates" : [ { "resource" : "Observation", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html#quantity", "http://hl7.org/fhir/DSTU2/observation.html#search" ], "code" : "      test \"SE22#{action[0]}\", 'Search for quantity (in observation) - operators' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html#quantity\"\n          links \"#{BASE_SPEC_LINK}/observation.html#search\"\n          validates resource: \"Observation\", methods: [\"search\"]\n        }\n        skip unless (@obs_a && @obs_d && @obs_e)\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'value-quantity' => 'gt5||mmol'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Observation, options)\n        has_obs_a = has_obs_b = has_obs_c = false\n        while reply != nil\n          assert_response_ok(reply)\n          assert_bundle_response(reply)\n          has_obs_a = true if reply.resource.get_by_id(@obs_a)\n          has_obs_d = true if reply.resource.get_by_id(@obs_d)\n          has_obs_e = true if reply.resource.get_by_id(@obs_e)\n          reply = @client.next_page(reply)\n        end\n\n        assert !has_obs_a,  'Search greater than quantity should not return lesser value.'\n        assert has_obs_d, 'Search greater than quantity should return greater value.'\n        assert has_obs_e, 'Search greater than quantity should return greater value.'\n      end\n", "test_method" : "se22g_search_for_quantity_(in_observation)_-_operators_test" }, { "key" : "SE23G", "id" : "SE23G", "description" : "Search with quantifier :missing, on Patient.gender", "status" : "fail", "message" : "The server did not report the correct number of results. Expected: 3, but found: 311.", "data" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE23#{action[0]}\", 'Search with quantifier :missing, on Patient.gender' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        skip unless @read_entire_feed\n        # how many patients in the bundle have no gender?\n        expected = 0\n        @entries.each do |entry|\n          patient = entry.resource\n          expected += 1 if !patient.nil? && patient.gender.nil?\n        end\n\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'gender:missing' => true\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n        assert_equal expected, reply.resource.total, 'The server did not report the correct number of results.'\n      end\n", "test_method" : "se23g_search_with_quantifier_:missing,_on_patient.gender_test" }, { "key" : "SE24G", "id" : "SE24G", "description" : "Search with non-existing parameter", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE24#{action[0]}\", 'Search with non-existing parameter' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        # non-existing parameters should be ignored\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              'bonkers' => 'foobar'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "se24g_search_with_non-existing_parameter_test" }, { "key" : "SE25G", "id" : "SE25G", "description" : "Search with malformed parameters", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Patient", "methods" : [ "search" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#search", "http://hl7.org/fhir/DSTU2/search.html", "http://hl7.org/fhir/DSTU2/patient.html#search" ], "code" : "      test \"SE25#{action[0]}\", 'Search with malformed parameters' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#search\"\n          links \"#{BASE_SPEC_LINK}/search.html\"\n          links \"#{BASE_SPEC_LINK}/patient.html#search\"\n          validates resource: \"Patient\", methods: [\"search\"]\n        }\n        # a malformed parameters are non-existing parameters, and they should be ignored\n        options = {\n          :search => {\n            :flag => flag,\n            :compartment => nil,\n            :parameters => {\n              '...' => 'foobar'\n            }\n          }\n        }\n        reply = @client.search(FHIR::Patient, options)\n        assert_response_ok(reply)\n        assert_bundle_response(reply)\n      end\n", "test_method" : "se25g_search_with_malformed_parameters_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840200" }, "updated_at" : { "$date" : "2015-10-02T19:00:21.757-0400" }, "created_at" : { "$date" : "2015-10-02T19:00:21.757-0400" } }
]