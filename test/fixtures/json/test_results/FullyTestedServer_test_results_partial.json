[
    {
        "_id": {
            "$oid": "560f070c4d4d3266f8990201"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:00.273-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'CT01', 'Request xml using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format)\n          assert compare_response_format(patient, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (headers) resource does not match created resource' }\n        rescue => e\n          raise AssertionException.new(\"CTO1 - Failed to handle XML format header response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request xml using headers",
                "id": "CT01",
                "key": "CT01",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct01_request_xml_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (headers) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT02A', 'Request [xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[0], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [xml] using [_format]",
                "id": "CT02A",
                "key": "CT02A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct02a_request_[xml]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT02B', 'Request [text/xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[1], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [text/xml] using [_format]",
                "id": "CT02B",
                "key": "CT02B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct02b_request_[text/xml]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT02C', 'Request [application/xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[2], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/xml] using [_format]",
                "id": "CT02C",
                "key": "CT02C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct02c_request_[application/xml]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT02D', 'Request [application/xml+fhir] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[3], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/xml+fhir] using [_format]",
                "id": "CT02D",
                "key": "CT02D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct02d_request_[application/xml+fhir]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT03', 'Request json using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format)\n          assert compare_response_format(patient, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (headers) resource does not match created resource' }\n        rescue => e\n          raise AssertionException.new(\"CTO3 - Failed to handle JSON format header response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request json using headers",
                "id": "CT03",
                "key": "CT03",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct03_request_json_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (headers) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT04A', 'Request [json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[0], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [json] using [_format]",
                "id": "CT04A",
                "key": "CT04A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct04a_request_[json]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT04B', 'Request [text/json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[1], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [text/json] using [_format]",
                "id": "CT04B",
                "key": "CT04B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct04b_request_[text/json]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT04C', 'Request [application/json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[2], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/json] using [_format]",
                "id": "CT04C",
                "key": "CT04C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct04c_request_[application/json]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'CT04D', 'Request [application/json+fhir] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[3], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/json+fhir] using [_format]",
                "id": "CT04D",
                "key": "CT04D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ct04d_request_[application/json+fhir]_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested JSON (_format) resource does not match created resource"
                ]
            },
            {
                "code": "      test 'FT01', 'Request xml and json using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML','JSON']\n        }\n        begin\n          patient_xml = request_entry(FHIR::Patient, @id, @xml_format)\n          patient_json = request_entry(FHIR::Patient, @id, @json_format)\n\n          assert compare_response_format(patient_xml, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient_xml.response_format}\"\n          assert compare_response_format(patient_json, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient_json.response_format}\"\n          warning { assert compare_entries(patient_xml, patient_json), 'requested XML & JSON (headers) resources do not match created resource or each other' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"FTO1 - Failed to handle XML & JSON header param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request xml and json using headers",
                "id": "FT01",
                "key": "FT01",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft01_request_xml_and_json_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "XML",
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML & JSON (headers) resources do not match created resource or each other"
                ]
            },
            {
                "code": "      test 'FT02', 'Request xml and json using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML','JSON']\n        }\n        begin\n          patient_xml = request_entry(FHIR::Patient, @id, @xml_format, true)\n          patient_json = request_entry(FHIR::Patient, @id, @json_format, true)\n\n          assert compare_response_format(patient_xml, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient_xml.response_format}\"\n          assert compare_response_format(patient_json, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient_json.response_format}\"\n          warning { assert compare_entries(patient_xml, patient_json), 'requested XML & JSON (_format) resources do not match created resource or each other' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"FTO2 - Failed to handle XML & JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request xml and json using [_format]",
                "id": "FT02",
                "key": "FT02",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft02_request_xml_and_json_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML",
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "warnings": [
                    "requested XML & JSON (_format) resources do not match created resource or each other"
                ]
            },
            {
                "code": "      test 'FT03', 'Request xml Bundle using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format header mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO3 - Failed to handle Bundle XML format header response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request xml Bundle using headers",
                "id": "FT03",
                "key": "FT03",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft03_request_xml_bundle_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT04A', 'Request [xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[0], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [xml] Bundle using [_format]",
                "id": "FT04A",
                "key": "FT04A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft04a_request_[xml]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT04B', 'Request [text/xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[1], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [text/xml] Bundle using [_format]",
                "id": "FT04B",
                "key": "FT04B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft04b_request_[text/xml]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT04C', 'Request [application/xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[2], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/xml] Bundle using [_format]",
                "id": "FT04C",
                "key": "FT04C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft04c_request_[application/xml]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT04D', 'Request [application/xml+fhir] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[3], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/xml+fhir] Bundle using [_format]",
                "id": "FT04D",
                "key": "FT04D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft04d_request_[application/xml+fhir]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "XML"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT05', 'Request json Bundle using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format header mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FT05 - Failed to handle Bundle JSON format header response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request json Bundle using headers",
                "id": "FT05",
                "key": "FT05",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft05_request_json_bundle_using_headers_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT06A', 'Request [json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[0], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [json] Bundle using [_format]",
                "id": "FT06A",
                "key": "FT06A",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft06a_request_[json]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT06B', 'Request [text/json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[1], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [text/json] Bundle using [_format]",
                "id": "FT06B",
                "key": "FT06B",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft06b_request_[text/json]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT06C', 'Request [application/json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[2], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/json] Bundle using [_format]",
                "id": "FT06C",
                "key": "FT06C",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft06c_request_[application/json]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'FT06D', 'Request [application/json+fhir] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[3], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n",
                "description": "Request [application/json+fhir] Bundle using [_format]",
                "id": "FT06D",
                "key": "FT06D",
                "links": [
                    "http://hl7.org/fhir/DSTU2/formats.html",
                    "http://hl7.org/fhir/DSTU2/http.html#mime-type",
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "ft06d_request_[application/json+fhir]_bundle_using_[_format]_test",
                "validates": [
                    {
                        "formats": [
                            "JSON"
                        ],
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a6070000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:00.273-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07244d4d3266f89d0201"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:24.408-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test  'HI01','History for specific resource' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n        bundle = result.resource\n\n        assert_equal \"history\", bundle.fhirType, \"The bundle type is not correct\"\n        assert_equal @version_count, bundle.total, \"the number of returned versions is not correct\"\n        check_sort_order(bundle.entry)\n      end\n",
                "description": "History for specific resource",
                "id": "HI01",
                "key": "HI01",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi01_history_for_specific_resource_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test  'HI01.1','History request entries' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history\"]\n        }\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n        bundle = result.resource\n        entries = bundle.entry\n\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'DELETE' }.size, 'Wrong number of DELETE transactions in the history bundle'\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'PUT' }.size, 'Wrong number of PUT transactions in the history bundle'\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'POST' }.size, 'Wrong number of POST transactions in the history bundle'\n\n      end\n",
                "data": null,
                "description": "History request entries",
                "id": "HI01.1",
                "key": "HI01.1",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "Wrong number of PUT transactions in the history bundle Expected: 1, but found: 0.",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi01.1_history_request_entries_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI02\", \"full history of a resource by id with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history\"]\n        }\n\n        before = @create_date - 1.minute\n        after = before + 1.hour\n\n        all_history = @client.resource_instance_history(FHIR::Patient,@id)\n\n        result = @client.resource_instance_history_as_of(FHIR::Patient,@id,before)\n        assert_response_ok result\n        bundle = result.resource\n\n        assert_equal @version_count, bundle.total, \"the number of returned versions since the creation date is not correct\"\n\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n        result = @client.resource_instance_history_as_of(FHIR::Patient,@id,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"there should not be any history one hour after the creation date\"\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Exception of type 'Hl7.Fhir.Server.FhirServerException' was thrown.\" /></details></issue></OperationOutcome>",
                "description": "full history of a resource by id with since",
                "id": "HI02",
                "key": "HI02",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "Bad response code: expected 200, 201, but found 404. ",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi02_full_history_of_a_resource_by_id_with_since_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI03\", \"individual history versions\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"vread\", \"history\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n\n        bundle = result.resource\n\n        active_entries(bundle.entry).each do |entry|\n          pulled = @client.vread(FHIR::Patient, entry.resource.xmlId, entry.resource.meta.versionId)\n          assert_response_ok pulled\n          assert !pulled.nil?, \"Cannot find version that was present in history\"\n        end\n\n        deleted_entries(bundle.entry).each do |entry|\n          # FIXME: Should we parse the request URL or drop this assertion?\n          if entry.resource\n            pulled = @client.vread(FHIR::Patient, entry.resource.xmlId, entry.resource.meta.versionId)\n            assert pulled.resource.nil?, \"resource should not be found since it was deleted\"\n            assert_response_gone pulled\n          end\n        end\n      end\n",
                "description": "individual history versions",
                "id": "HI03",
                "key": "HI03",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi03_individual_history_versions_test",
                "validates": [
                    {
                        "methods": [
                            "vread",
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI04\", \"history for missing resource\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,'3141592unlikely')\n        assert_response_not_found result\n        assert result.resource.nil?, 'bad history request should not return a resource'\n      end\n",
                "description": "history for missing resource",
                "id": "HI04",
                "key": "HI04",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi04_history_for_missing_resource_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI06\", \"all history for resource with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        before = @create_date - 1.minute\n        after = Time.now.utc + 1.minute\n\n        result = @client.resource_history_as_of(FHIR::Patient,before)\n        assert_response_ok result\n        bundle = result.resource\n\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n\n        result = @client.resource_history_as_of(FHIR::Patient,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"Setting since to a future moment still returns history\"\n\n      end\n",
                "data": null,
                "description": "all history for resource with since",
                "id": "HI06",
                "key": "HI06",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "Setting since to a future moment still returns history Expected: 0, but found: 9.",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi06_all_history_for_resource_with_since_test",
                "validates": [
                    {
                        "methods": [
                            "history-type"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI08\", \"all history whole system with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: nil, methods: [\"history-system\"]\n        }\n\n        before = @create_date - 1.minute\n        after = Time.now.utc + 1.minute\n\n        result = @client.all_history_as_of(before)\n        assert_response_ok result\n        bundle = result.resource\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n        warning { assert_navigation_links(bundle) }\n\n        result = @client.resource_history_as_of(FHIR::Patient,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"Setting since to a future moment still returns history\"\n\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Resource [_history] is not supported on this server\" /></details></issue></OperationOutcome>",
                "description": "all history whole system with since",
                "id": "HI08",
                "key": "HI08",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "Bad response code: expected 200, 201, but found 404. ",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi08_all_history_whole_system_with_since_test",
                "validates": [
                    {
                        "methods": [
                            "history-system"
                        ],
                        "resource": null
                    }
                ]
            },
            {
                "code": "      test \"HI09\", \"resource history page forward\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        page_size = 2\n        page = @client.history(resource: FHIR::Patient, history: {since: (Time.now.utc - 1.hour), count: page_size})\n\n        forward_count = 0\n        # browse forwards\n        while page != nil\n          assert !page.resource.nil?, \"Unable to page forward through results.  A bundle was not returned from the page forward request.\"\n          warning { entry_ids_are_present(page.resource.entry) }\n          assert page.resource.entry.size <= page_size, \"Server returned a page with more entries than set by _count\"\n          forward_count += page.resource.entry.size\n          page = @client.next_page(page)\n        end\n\n        assert forward_count > 2, \"there should be at least 2 history entries\"\n      end\n",
                "description": "resource history page forward",
                "id": "HI09",
                "key": "HI09",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi09_resource_history_page_forward_test",
                "validates": [
                    {
                        "methods": [
                            "history-type"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI10\", \"resource history page backwards\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        page_size = 2\n        page = @client.history(resource: FHIR::Patient, history: {since: (Time.now.utc - 1.hour), count: page_size})\n\n        forward_count = 0\n        last_page = page\n        # browse forwards\n        while page != nil\n          assert !page.resource.nil?, \"Unable to page forward through results.  A bundle was not returned from the page forward request.\"\n          forward_count += page.resource.entry.size\n          page = @client.next_page(page)\n          last_page = page if page\n        end\n\n        backward_count = 0\n        page = last_page\n        # browse backwards\n        while page != nil\n          warning { entry_ids_are_present(page.resource.entry) }\n          assert page.resource.entry.size <= page_size, \"Server returned a page with more entries than set by _count\"\n          backward_count += page.resource.entry.size\n          page = @client.next_page(page, FHIR::Sections::Feed::BACKWARD)\n        end\n\n        assert_equal forward_count, backward_count, \"entry numbers were different moving forwards and backwards\"\n\n      end\n",
                "description": "resource history page backwards",
                "id": "HI10",
                "key": "HI10",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "hi10_resource_history_page_backwards_test",
                "validates": [
                    {
                        "methods": [
                            "history-type"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test \"HI11\", \"first page full history\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: nil, methods: [\"history-system\"]\n        }\n\n        history = @client.all_history\n        assert !history.resource.nil?, \"A bundle was not returned from the history request.\"\n        assert history.resource.entry.size >= 3, \"there should be at least 3 history entries\"\n      end\n",
                "data": null,
                "description": "first page full history",
                "id": "HI11",
                "key": "HI11",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history"
                ],
                "message": "A bundle was not returned from the history request.",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "hi11_first_page_full_history_test",
                "validates": [
                    {
                        "methods": [
                            "history-system"
                        ],
                        "resource": null
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a6080000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:24.408-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07274d4d3266f89e0201"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:27.821-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'R001', 'Result headers on normal read.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        assert(@id, 'Setup was unable to create a patient.',@body)\n        reply = @client.read(FHIR::Patient, @id)\n        assert_response_ok(reply)\n        assert_equal @id, reply.id, 'Server returned wrong patient.'\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_etag_present(reply) }\n        warning { assert_last_modified_present(reply) }\n      end\n",
                "description": "Result headers on normal read.",
                "id": "R001",
                "key": "R001",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "r001_result_headers_on_normal_read._test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'R002', 'Read unknown resource type.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{REST_SPEC_LINK}#update\"\n        }\n\n        reply = @client.read(Crucible::Tests::ReadTest, @id)\n        assert_response_not_found(reply)\n      end\n",
                "description": "Read unknown resource type.",
                "id": "R002",
                "key": "R002",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/http.html#update"
                ],
                "message": null,
                "status": "pass",
                "test_method": "r002_read_unknown_resource_type._test"
            },
            {
                "code": "      test 'R003', 'Read non-existing resource id.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        reply = @client.read(FHIR::Patient, 'Supercalifragilisticexpialidocious')\n        assert_response_not_found(reply)\n      end\n",
                "description": "Read non-existing resource id.",
                "id": "R003",
                "key": "R003",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read"
                ],
                "message": null,
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "pass",
                "test_method": "r003_read_non-existing_resource_id._test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'R004', 'Read invalid format resource id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/datatypes.html#id\"\n          links \"#{BASE_SPEC_LINK}/resource.html#id\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        reply = @client.read(FHIR::Patient, 'Invalid-ID-Because_Of_!@$Special_Characters_and_Length_Over_Sixty_Four_Characters')\n        assert_response_bad(reply)\n      end\n",
                "data": null,
                "description": "Read invalid format resource id",
                "id": "R004",
                "key": "R004",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/datatypes.html#id",
                    "http://hl7.org/fhir/DSTU2/resource.html#id"
                ],
                "message": "Bad response code: expected 400, but found 404",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "r004_read_invalid_format_resource_id_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            },
            {
                "code": "      test 'R005', 'Read _summary=text' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/datatypes.html#id\"\n          links \"#{BASE_SPEC_LINK}/resource.html#id\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        assert(@id, 'Setup was unable to create a patient.', @body)\n        reply = @client.read(FHIR::Patient, @id, @client.default_format, 'text')\n        assert_response_ok(reply)\n        assert(reply.try(:resource).try(:text), 'Requested summary narrative was not provided.', reply.body)\n      end      \n",
                "data": "\ufeff<Patient xmlns=\"http://hl7.org/fhir\"><id value=\"9940f2415237475d8e8d62753dd1b79f\" /><meta><versionId value=\"458\" /><lastUpdated value=\"2015-10-02T22:37:24.957+00:00\" /></meta><name><family value=\"Emerald\" /><given value=\"Caro\" /></name></Patient>",
                "description": "Read _summary=text",
                "id": "R005",
                "key": "R005",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/datatypes.html#id",
                    "http://hl7.org/fhir/DSTU2/resource.html#id"
                ],
                "message": "Requested summary narrative was not provided.",
                "requires": [
                    {
                        "methods": [
                            "create",
                            "read",
                            "delete"
                        ],
                        "resource": "Patient"
                    }
                ],
                "status": "fail",
                "test_method": "r005_read__summary=text_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Patient"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a6090000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:27.821-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f072f4d4d3266f89f0201"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:35.185-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Account: Read Type",
                "id": "X000_Account",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Account: Create New",
                "id": "X010_Account",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "New Account was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Account: Read Existing",
                "id": "X020_Account",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Successfully read preexisting Account.",
                "status": "skip",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Account: Update Existing",
                "id": "X030_Account",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Updated existing Account.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Account: Read History of existing",
                "id": "X040_Account",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Account: Version read existing",
                "id": "X050_Account",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Read current version of preexisting Account.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Account: Previous version read existing",
                "id": "X055_Account",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Read previous version of preexisting Account.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Account: Validate",
                "id": "X060_Account",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Account was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Account"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Account: Validate Existing",
                "id": "X065_Account",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Existing Account was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Account"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Account: Validate against a profile",
                "id": "X067_Account",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Account was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Account"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Account: Delete Existing",
                "id": "X070_Account",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Existing Account was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Account"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Account: Get Deleted Resource",
                "id": "X075_Account",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/account.html"
                ],
                "message": "Deleted Account was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Account"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60a0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:35.185-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07364d4d3266f8a00201"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:42.691-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "AllergyIntolerance: Read Type",
                "id": "X000_AllergyIntolerance",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Create New",
                "id": "X010_AllergyIntolerance",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "New AllergyIntolerance was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "AllergyIntolerance: Read Existing",
                "id": "X020_AllergyIntolerance",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Successfully read preexisting AllergyIntolerance.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Update Existing",
                "id": "X030_AllergyIntolerance",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Updated existing AllergyIntolerance.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "AllergyIntolerance: Read History of existing",
                "id": "X040_AllergyIntolerance",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AllergyIntolerance: Version read existing",
                "id": "X050_AllergyIntolerance",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Read current version of preexisting AllergyIntolerance.",
                "status": "skip",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AllergyIntolerance"
                    },
                    {
                        "extensions": [
                            "extensions"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AllergyIntolerance: Previous version read existing",
                "id": "X055_AllergyIntolerance",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Read previous version of preexisting AllergyIntolerance.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Validate",
                "id": "X060_AllergyIntolerance",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "AllergyIntolerance was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AllergyIntolerance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Validate Existing",
                "id": "X065_AllergyIntolerance",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Existing AllergyIntolerance was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AllergyIntolerance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Validate against a profile",
                "id": "X067_AllergyIntolerance",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "AllergyIntolerance was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AllergyIntolerance"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Delete Existing",
                "id": "X070_AllergyIntolerance",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Existing AllergyIntolerance was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AllergyIntolerance: Get Deleted Resource",
                "id": "X075_AllergyIntolerance",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/allergyintolerance.html"
                ],
                "message": "Deleted AllergyIntolerance was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AllergyIntolerance"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60b0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:42.691-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f073e4d4d3266f8a10201"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:50.242-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Appointment: Read Type",
                "id": "X000_Appointment",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Appointment: Create New",
                "id": "X010_Appointment",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "New Appointment was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Appointment: Read Existing",
                "id": "X020_Appointment",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Successfully read preexisting Appointment.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Appointment: Update Existing",
                "id": "X030_Appointment",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Updated existing Appointment.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Appointment: Read History of existing",
                "id": "X040_Appointment",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Appointment: Version read existing",
                "id": "X050_Appointment",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Read current version of preexisting Appointment.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Appointment: Previous version read existing",
                "id": "X055_Appointment",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Read previous version of preexisting Appointment.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Appointment: Validate",
                "id": "X060_Appointment",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Appointment was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Appointment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Appointment: Validate Existing",
                "id": "X065_Appointment",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Existing Appointment was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Appointment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Appointment: Validate against a profile",
                "id": "X067_Appointment",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Appointment was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Appointment"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Appointment: Delete Existing",
                "id": "X070_Appointment",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Existing Appointment was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Appointment"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Appointment: Get Deleted Resource",
                "id": "X075_Appointment",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/appointment.html"
                ],
                "message": "Deleted Appointment was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Appointment"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60c0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:50.242-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07454d4d3266f8a20201"
        },
        "created_at": {
            "$date": "2015-10-02T18:37:57.257-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "AppointmentResponse: Read Type",
                "id": "X000_AppointmentResponse",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Create New",
                "id": "X010_AppointmentResponse",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "New AppointmentResponse was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "AppointmentResponse: Read Existing",
                "id": "X020_AppointmentResponse",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Successfully read preexisting AppointmentResponse.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Update Existing",
                "id": "X030_AppointmentResponse",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Updated existing AppointmentResponse.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "AppointmentResponse: Read History of existing",
                "id": "X040_AppointmentResponse",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AppointmentResponse: Version read existing",
                "id": "X050_AppointmentResponse",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Read current version of preexisting AppointmentResponse.",
                "status": "error",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AppointmentResponse: Previous version read existing",
                "id": "X055_AppointmentResponse",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Read previous version of preexisting AppointmentResponse.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Validate",
                "id": "X060_AppointmentResponse",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "AppointmentResponse was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AppointmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Validate Existing",
                "id": "X065_AppointmentResponse",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Existing AppointmentResponse was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AppointmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Validate against a profile",
                "id": "X067_AppointmentResponse",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "AppointmentResponse was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AppointmentResponse"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Delete Existing",
                "id": "X070_AppointmentResponse",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Existing AppointmentResponse was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AppointmentResponse: Get Deleted Resource",
                "id": "X075_AppointmentResponse",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/appointmentresponse.html"
                ],
                "message": "Deleted AppointmentResponse was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AppointmentResponse"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60d0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:37:57.257-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f074e4d4d3266f8a30201"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:06.839-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "AuditEvent: Read Type",
                "id": "X000_AuditEvent",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Create New",
                "id": "X010_AuditEvent",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "New AuditEvent was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "AuditEvent: Read Existing",
                "id": "X020_AuditEvent",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Successfully read preexisting AuditEvent.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"System AuditEvents cannot be modified\" /></details></issue></OperationOutcome>",
                "description": "AuditEvent: Update Existing",
                "id": "X030_AuditEvent",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": [
                    "error: : System AuditEvents cannot be modified"
                ],
                "status": "fail",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "AuditEvent: Read History of existing",
                "id": "X040_AuditEvent",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AuditEvent: Version read existing",
                "id": "X050_AuditEvent",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Read current version of preexisting AuditEvent.",
                "status": "error",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "AuditEvent: Previous version read existing",
                "id": "X055_AuditEvent",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Read previous version of preexisting AuditEvent.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Validate",
                "id": "X060_AuditEvent",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "AuditEvent was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AuditEvent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Validate Existing",
                "id": "X065_AuditEvent",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Existing AuditEvent was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AuditEvent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Validate against a profile",
                "id": "X067_AuditEvent",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "AuditEvent was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "AuditEvent"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Delete Existing",
                "id": "X070_AuditEvent",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Existing AuditEvent was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "AuditEvent: Get Deleted Resource",
                "id": "X075_AuditEvent",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/auditevent.html"
                ],
                "message": "Deleted AuditEvent was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "AuditEvent"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0444d4d3261a60e0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:06.839-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f07584d4d3266f8a40201"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:16.381-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "description": "Basic: Read Type",
                "id": "X000_Basic",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": null,
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Basic: Create New",
                "id": "X010_Basic",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "New Basic was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Basic: Read Existing",
                "id": "X020_Basic",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Successfully read preexisting Basic.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Basic: Update Existing",
                "id": "X030_Basic",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Updated existing Basic.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Basic: Read History of existing",
                "id": "X040_Basic",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Basic: Version read existing",
                "id": "X050_Basic",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Read current version of preexisting Basic.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Basic: Previous version read existing",
                "id": "X055_Basic",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Read previous version of preexisting Basic.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Basic: Validate",
                "id": "X060_Basic",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Basic was validated.",
                "status": "pass",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Basic"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Basic: Validate Existing",
                "id": "X065_Basic",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Existing Basic was validated.",
                "status": "pass",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Basic"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "description": "Basic: Validate against a profile",
                "id": "X067_Basic",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Basic was validated.",
                "status": "pass",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Basic"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Basic: Delete Existing",
                "id": "X070_Basic",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Existing Basic was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Basic"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Basic: Get Deleted Resource",
                "id": "X075_Basic",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/basic.html"
                ],
                "message": "Deleted Basic was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Basic"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a60f0000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:16.381-0400"
        }
    },
    {
        "_id": {
            "$oid": "560f075f4d4d3266f8a50201"
        },
        "created_at": {
            "$date": "2015-10-02T18:38:23.689-0400"
        },
        "has_run": true,
        "result": [
            {
                "code": "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n",
                "data": "\ufeff<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>",
                "description": "Binary: Read Type",
                "id": "X000_Binary",
                "key": "X000",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Expected FHIR Bundle but found: OperationOutcome",
                "status": "pass",
                "test_method": "x000_read_type_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n",
                "description": "Binary: Create New",
                "id": "X010_Binary",
                "key": "X010",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#create",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "New Binary was created.",
                "status": "pass",
                "test_method": "x010_create_new_test",
                "validates": [
                    {
                        "methods": [
                            "create"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n",
                "description": "Binary: Read Existing",
                "id": "X020_Binary",
                "key": "X020",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#read",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Successfully read preexisting Binary.",
                "status": "pass",
                "test_method": "x020_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "read"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Binary: Update Existing",
                "id": "X030_Binary",
                "key": "X030",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#update",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Updated existing Binary.",
                "status": "pass",
                "test_method": "x030_update_existing_test",
                "validates": [
                    {
                        "methods": [
                            "update"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n",
                "description": "Binary: Read History of existing",
                "id": "X040_Binary",
                "key": "X040",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#history",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Service responded with bundle.",
                "status": "pass",
                "test_method": "x040_read_history_of_existing_test",
                "validates": [
                    {
                        "methods": [
                            "history"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Binary: Version read existing",
                "id": "X050_Binary",
                "key": "X050",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Read current version of preexisting Binary.",
                "status": "pass",
                "test_method": "x050_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n",
                "description": "Binary: Previous version read existing",
                "id": "X055_Binary",
                "key": "X055",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#vread",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Read previous version of preexisting Binary.",
                "status": "pass",
                "test_method": "x055_previous_version_read_existing_test",
                "validates": [
                    {
                        "methods": [
                            "vread"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "data": "{\"Message\":\"The request is invalid.\"}",
                "description": "Binary: Validate",
                "id": "X060_Binary",
                "key": "X060",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Response code 400 with no OperationOutcome provided.",
                "status": "fail",
                "test_method": "x060_validate_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Binary"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "data": "{\"Message\":\"The request is invalid.\"}",
                "description": "Binary: Validate Existing",
                "id": "X065_Binary",
                "key": "X065",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Response code 400 with no OperationOutcome provided.",
                "status": "fail",
                "test_method": "x065_validate_existing_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Binary"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('$validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n",
                "data": "{\"Message\":\"The request is invalid.\"}",
                "description": "Binary: Validate against a profile",
                "id": "X067_Binary",
                "key": "X067",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#validate",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Response code 400 with no OperationOutcome provided.",
                "status": "fail",
                "test_method": "x067_validate_against_a_profile_test",
                "validates": [
                    {
                        "methods": [
                            "$validate"
                        ],
                        "resource": "Binary"
                    },
                    {
                        "profiles": [
                            "validate-profile"
                        ]
                    }
                ]
            },
            {
                "code": "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Binary: Delete Existing",
                "id": "X070_Binary",
                "key": "X070",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Existing Binary was deleted.",
                "status": "pass",
                "test_method": "x070_delete_existing_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Binary"
                    }
                ]
            },
            {
                "code": "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n",
                "description": "Binary: Get Deleted Resource",
                "id": "X075_Binary",
                "key": "X075",
                "links": [
                    "http://hl7.org/fhir/DSTU2/http.html#delete",
                    "http://hl7.org/fhir/DSTU2/binary.html"
                ],
                "message": "Deleted Binary was correctly reported as gone.",
                "status": "pass",
                "test_method": "x075_get_deleted_resource_test",
                "validates": [
                    {
                        "methods": [
                            "delete"
                        ],
                        "resource": "Binary"
                    }
                ]
            }
        ],
        "server_id": {
            "$oid": "560eefc34d4d326197010000"
        },
        "test_id": {
            "$oid": "560ef0454d4d3261a6100000"
        },
        "test_run_id": {
            "$oid": "560f068c4d4d3266f8840201"
        },
        "updated_at": {
            "$date": "2015-10-02T18:38:23.689-0400"
        }
    }
]
