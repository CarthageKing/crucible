[{ "_id" : { "$oid" : "560f070c4d4d3266f8990201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a6070000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "CT01", "id" : "CT01", "description" : "Request xml using headers", "status" : "pass", "message" : null, "warnings" : [ "requested XML (headers) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT01', 'Request xml using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format)\n          assert compare_response_format(patient, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (headers) resource does not match created resource' }\n        rescue => e\n          raise AssertionException.new(\"CTO1 - Failed to handle XML format header response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct01_request_xml_using_headers_test" }, { "key" : "CT02A", "id" : "CT02A", "description" : "Request [xml] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT02A', 'Request [xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[0], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct02a_request_[xml]_using_[_format]_test" }, { "key" : "CT02B", "id" : "CT02B", "description" : "Request [text/xml] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT02B', 'Request [text/xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[1], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct02b_request_[text/xml]_using_[_format]_test" }, { "key" : "CT02C", "id" : "CT02C", "description" : "Request [application/xml] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT02C', 'Request [application/xml] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[2], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct02c_request_[application/xml]_using_[_format]_test" }, { "key" : "CT02D", "id" : "CT02D", "description" : "Request [application/xml+fhir] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT02D', 'Request [application/xml+fhir] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @xml_format_params[3], true)\n          assert compare_response_format(patient, @xml_format), \"XML format param mismatch: requested #{@xml_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested XML (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO2 - Failed to handle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct02d_request_[application/xml+fhir]_using_[_format]_test" }, { "key" : "CT03", "id" : "CT03", "description" : "Request json using headers", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (headers) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT03', 'Request json using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format)\n          assert compare_response_format(patient, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (headers) resource does not match created resource' }\n        rescue => e\n          raise AssertionException.new(\"CTO3 - Failed to handle JSON format header response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct03_request_json_using_headers_test" }, { "key" : "CT04A", "id" : "CT04A", "description" : "Request [json] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT04A', 'Request [json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[0], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct04a_request_[json]_using_[_format]_test" }, { "key" : "CT04B", "id" : "CT04B", "description" : "Request [text/json] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT04B', 'Request [text/json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[1], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct04b_request_[text/json]_using_[_format]_test" }, { "key" : "CT04C", "id" : "CT04C", "description" : "Request [application/json] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT04C', 'Request [application/json] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[2], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct04c_request_[application/json]_using_[_format]_test" }, { "key" : "CT04D", "id" : "CT04D", "description" : "Request [application/json+fhir] using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested JSON (_format) resource does not match created resource" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'CT04D', 'Request [application/json+fhir] using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patient = request_entry(FHIR::Patient, @id, @json_format_params[3], true)\n          assert compare_response_format(patient, @json_format), \"JSON format param mismatch: requested #{@json_format}, received #{patient.response_format}\"\n          warning { assert compare_response(patient), 'requested JSON (_format) resource does not match created resource' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"CTO4 - Failed to handle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ct04d_request_[application/json+fhir]_using_[_format]_test" }, { "key" : "FT01", "id" : "FT01", "description" : "Request xml and json using headers", "status" : "pass", "message" : null, "warnings" : [ "requested XML & JSON (headers) resources do not match created resource or each other" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML", "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT01', 'Request xml and json using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML','JSON']\n        }\n        begin\n          patient_xml = request_entry(FHIR::Patient, @id, @xml_format)\n          patient_json = request_entry(FHIR::Patient, @id, @json_format)\n\n          assert compare_response_format(patient_xml, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient_xml.response_format}\"\n          assert compare_response_format(patient_json, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient_json.response_format}\"\n          warning { assert compare_entries(patient_xml, patient_json), 'requested XML & JSON (headers) resources do not match created resource or each other' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"FTO1 - Failed to handle XML & JSON header param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft01_request_xml_and_json_using_headers_test" }, { "key" : "FT02", "id" : "FT02", "description" : "Request xml and json using [_format]", "status" : "pass", "message" : null, "warnings" : [ "requested XML & JSON (_format) resources do not match created resource or each other" ], "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML", "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT02', 'Request xml and json using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML','JSON']\n        }\n        begin\n          patient_xml = request_entry(FHIR::Patient, @id, @xml_format, true)\n          patient_json = request_entry(FHIR::Patient, @id, @json_format, true)\n\n          assert compare_response_format(patient_xml, @xml_format), \"XML format header mismatch: requested #{@xml_format}, received #{patient_xml.response_format}\"\n          assert compare_response_format(patient_json, @json_format), \"JSON format header mismatch: requested #{@json_format}, received #{patient_json.response_format}\"\n          warning { assert compare_entries(patient_xml, patient_json), 'requested XML & JSON (_format) resources do not match created resource or each other' }\n        rescue => e\n          @client.use_format_param = false\n          raise AssertionException.new(\"FTO2 - Failed to handle XML & JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft02_request_xml_and_json_using_[_format]_test" }, { "key" : "FT03", "id" : "FT03", "description" : "Request xml Bundle using headers", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT03', 'Request xml Bundle using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format header mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO3 - Failed to handle Bundle XML format header response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft03_request_xml_bundle_using_headers_test" }, { "key" : "FT04A", "id" : "FT04A", "description" : "Request [xml] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT04A', 'Request [xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[0], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft04a_request_[xml]_bundle_using_[_format]_test" }, { "key" : "FT04B", "id" : "FT04B", "description" : "Request [text/xml] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT04B', 'Request [text/xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[1], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft04b_request_[text/xml]_bundle_using_[_format]_test" }, { "key" : "FT04C", "id" : "FT04C", "description" : "Request [application/xml] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT04C', 'Request [application/xml] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[2], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft04c_request_[application/xml]_bundle_using_[_format]_test" }, { "key" : "FT04D", "id" : "FT04D", "description" : "Request [application/xml+fhir] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "XML" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT04D', 'Request [application/xml+fhir] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['XML']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @xml_format_params[3], true)\n\n          assert compare_response_format(patients_bundle, @xml_format), \"Bundle XML format param mismatch: requested #{@xml_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO4- Failed to handle Bundle XML format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft04d_request_[application/xml+fhir]_bundle_using_[_format]_test" }, { "key" : "FT05", "id" : "FT05", "description" : "Request json Bundle using headers", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT05', 'Request json Bundle using headers' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format header mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FT05 - Failed to handle Bundle JSON format header response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft05_request_json_bundle_using_headers_test" }, { "key" : "FT06A", "id" : "FT06A", "description" : "Request [json] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT06A', 'Request [json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[0], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft06a_request_[json]_bundle_using_[_format]_test" }, { "key" : "FT06B", "id" : "FT06B", "description" : "Request [text/json] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT06B', 'Request [text/json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[1], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft06b_request_[text/json]_bundle_using_[_format]_test" }, { "key" : "FT06C", "id" : "FT06C", "description" : "Request [application/json] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT06C', 'Request [application/json] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[2], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft06c_request_[application/json]_bundle_using_[_format]_test" }, { "key" : "FT06D", "id" : "FT06D", "description" : "Request [application/json+fhir] Bundle using [_format]", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ], "formats" : [ "JSON" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/formats.html", "http://hl7.org/fhir/DSTU2/http.html#mime-type", "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'FT06D', 'Request [application/json+fhir] Bundle using [_format]' do\n        metadata {\n          links \"#{BASE_SPEC_LINK}/formats.html\"\n          links \"#{REST_SPEC_LINK}#mime-type\"\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: 'Patient', methods: ['create','read']\n          validates resource: 'Patient', methods: ['read'], formats: ['JSON']\n        }\n        begin\n          patients_bundle = request_bundle(FHIR::Patient, @json_format_params[3], true)\n\n          assert compare_response_format(patients_bundle, @json_format), \"Bundle JSON format param mismatch: requested #{@json_format}, received #{patients_bundle.response_format}\"\n        rescue => e\n          raise AssertionException.new(\"FTO6 - Failed to handle Bundle JSON format param response. Error: #{e.message}\")\n        end\n      end\n", "test_method" : "ft06d_request_[application/json+fhir]_bundle_using_[_format]_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:37:00.273-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:00.273-0400" } }
,{ "_id" : { "$oid" : "560f07244d4d3266f89d0201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a6080000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "HI01", "id" : "HI01", "description" : "History for specific resource", "status" : "fail", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test  'HI01','History for specific resource' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-instance\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n        bundle = result.resource\n\n        assert_equal \"history\", bundle.fhirType, \"The bundle type is not correct\"\n        assert_equal @version_count, bundle.total, \"the number of returned versions is not correct\"\n        check_sort_order(bundle.entry)\n      end\n", "test_method" : "hi01_history_for_specific_resource_test" }, { "key" : "HI01.1", "id" : "HI01.1", "description" : "History request entries", "status" : "fail", "message" : "Wrong number of PUT transactions in the history bundle Expected: 1, but found: 0.", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test  'HI01.1','History request entries' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-instance\"]\n        }\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n        bundle = result.resource\n        entries = bundle.entry\n\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'DELETE' }.size, 'Wrong number of DELETE transactions in the history bundle'\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'PUT' }.size, 'Wrong number of PUT transactions in the history bundle'\n        assert_equal 1, entries.select{|entry| entry.request.try(:method) == 'POST' }.size, 'Wrong number of POST transactions in the history bundle'\n\n      end\n", "test_method" : "hi01.1_history_request_entries_test" }, { "key" : "HI02", "id" : "HI02", "description" : "full history of a resource by id with since", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 404. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Exception of type 'Hl7.Fhir.Server.FhirServerException' was thrown.\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI02\", \"full history of a resource by id with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-instance\"]\n        }\n\n        before = @create_date - 1.minute\n        after = before + 1.hour\n\n        all_history = @client.resource_instance_history(FHIR::Patient,@id)\n\n        result = @client.resource_instance_history_as_of(FHIR::Patient,@id,before)\n        assert_response_ok result\n        bundle = result.resource\n\n        assert_equal @version_count, bundle.total, \"the number of returned versions since the creation date is not correct\"\n\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n        result = @client.resource_instance_history_as_of(FHIR::Patient,@id,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"there should not be any history one hour after the creation date\"\n      end\n", "test_method" : "hi02_full_history_of_a_resource_by_id_with_since_test" }, { "key" : "HI03", "id" : "HI03", "description" : "individual history versions", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "vread", "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI03\", \"individual history versions\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"vread\", \"history-instance\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,@id)\n        assert_response_ok result\n\n        bundle = result.resource\n\n        active_entries(bundle.entry).each do |entry|\n          pulled = @client.vread(FHIR::Patient, entry.resource.xmlId, entry.resource.meta.versionId)\n          assert_response_ok pulled\n          assert !pulled.nil?, \"Cannot find version that was present in history\"\n        end\n\n        deleted_entries(bundle.entry).each do |entry|\n          # FIXME: Should we parse the request URL or drop this assertion?\n          if entry.resource\n            pulled = @client.vread(FHIR::Patient, entry.resource.xmlId, entry.resource.meta.versionId)\n            assert pulled.resource.nil?, \"resource should not be found since it was deleted\"\n            assert_response_gone pulled\n          end\n        end\n      end\n", "test_method" : "hi03_individual_history_versions_test" }, { "key" : "HI04", "id" : "HI04", "description" : "history for missing resource", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-instance" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI04\", \"history for missing resource\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-instance\"]\n        }\n\n        result = @client.resource_instance_history(FHIR::Patient,'3141592unlikely')\n        assert_response_not_found result\n        assert result.resource.nil?, 'bad history request should not return a resource'\n      end\n", "test_method" : "hi04_history_for_missing_resource_test" }, { "key" : "HI06", "id" : "HI06", "description" : "all history for resource with since", "status" : "fail", "message" : "Setting since to a future moment still returns history Expected: 0, but found: 9.", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-type" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI06\", \"all history for resource with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        before = @create_date - 1.minute\n        after = Time.now.utc + 1.minute\n\n        result = @client.resource_history_as_of(FHIR::Patient,before)\n        assert_response_ok result\n        bundle = result.resource\n\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n\n        result = @client.resource_history_as_of(FHIR::Patient,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"Setting since to a future moment still returns history\"\n\n      end\n", "test_method" : "hi06_all_history_for_resource_with_since_test" }, { "key" : "HI08", "id" : "HI08", "description" : "all history whole system with since", "status" : "fail", "message" : "Bad response code: expected 200, 201, but found 404. ", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Resource [_history] is not supported on this server\" /></details></issue></OperationOutcome>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : null, "methods" : [ "history-system" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI08\", \"all history whole system with since\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: nil, methods: [\"history-system\"]\n        }\n\n        before = @create_date - 1.minute\n        after = Time.now.utc + 1.minute\n\n        result = @client.all_history_as_of(before)\n        assert_response_ok result\n        bundle = result.resource\n        entry_ids_are_present(bundle.entry)\n        check_sort_order(bundle.entry)\n\n        warning { assert_navigation_links(bundle) }\n\n        result = @client.resource_history_as_of(FHIR::Patient,after)\n        assert_response_ok result\n        assert_equal 0, bundle.total, \"Setting since to a future moment still returns history\"\n\n      end\n", "test_method" : "hi08_all_history_whole_system_with_since_test" }, { "key" : "HI09", "id" : "HI09", "description" : "resource history page forward", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-type" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI09\", \"resource history page forward\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        page_size = 2\n        page = @client.history(resource: FHIR::Patient, history: {since: (Time.now.utc - 1.hour), count: page_size})\n\n        forward_count = 0\n        # browse forwards\n        while page != nil\n          assert !page.resource.nil?, \"Unable to page forward through results.  A bundle was not returned from the page forward request.\"\n          warning { entry_ids_are_present(page.resource.entry) }\n          assert page.resource.entry.size <= page_size, \"Server returned a page with more entries than set by _count\"\n          forward_count += page.resource.entry.size\n          page = @client.next_page(page)\n        end\n\n        assert forward_count > 2, \"there should be at least 2 history entries\"\n      end\n", "test_method" : "hi09_resource_history_page_forward_test" }, { "key" : "HI10", "id" : "HI10", "description" : "resource history page backwards", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "history-type" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI10\", \"resource history page backwards\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"history-type\"]\n        }\n\n        page_size = 2\n        page = @client.history(resource: FHIR::Patient, history: {since: (Time.now.utc - 1.hour), count: page_size})\n\n        forward_count = 0\n        last_page = page\n        # browse forwards\n        while page != nil\n          assert !page.resource.nil?, \"Unable to page forward through results.  A bundle was not returned from the page forward request.\"\n          forward_count += page.resource.entry.size\n          page = @client.next_page(page)\n          last_page = page if page\n        end\n\n        backward_count = 0\n        page = last_page\n        # browse backwards\n        while page != nil\n          warning { entry_ids_are_present(page.resource.entry) }\n          assert page.resource.entry.size <= page_size, \"Server returned a page with more entries than set by _count\"\n          backward_count += page.resource.entry.size\n          page = @client.next_page(page, FHIR::Sections::Feed::BACKWARD)\n        end\n\n        assert_equal forward_count, backward_count, \"entry numbers were different moving forwards and backwards\"\n\n      end\n", "test_method" : "hi10_resource_history_page_backwards_test" }, { "key" : "HI11", "id" : "HI11", "description" : "first page full history", "status" : "fail", "message" : "A bundle was not returned from the history request.", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "update", "delete" ] } ], "validates" : [ { "resource" : null, "methods" : [ "history-system" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history" ], "code" : "      test \"HI11\", \"first page full history\" do\n        metadata {\n          links \"#{REST_SPEC_LINK}#history\"\n          requires resource: \"Patient\", methods: [\"create\", \"update\", \"delete\"]\n          validates resource: nil, methods: [\"history-system\"]\n        }\n\n        history = @client.all_history\n        assert !history.resource.nil?, \"A bundle was not returned from the history request.\"\n        assert history.resource.entry.size >= 3, \"there should be at least 3 history entries\"\n      end\n", "test_method" : "hi11_first_page_full_history_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:37:24.408-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:24.408-0400" } }
,{ "_id" : { "$oid" : "560f07274d4d3266f89e0201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a6090000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "R001", "id" : "R001", "description" : "Result headers on normal read.", "status" : "fail", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'R001', 'Result headers on normal read.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        assert(@id, 'Setup was unable to create a patient.',@body)\n        reply = @client.read(FHIR::Patient, @id)\n        assert_response_ok(reply)\n        assert_equal @id, reply.id, 'Server returned wrong patient.'\n        warning { assert_valid_resource_content_type_present(reply) }\n        warning { assert_etag_present(reply) }\n        warning { assert_last_modified_present(reply) }\n      end\n", "test_method" : "r001_result_headers_on_normal_read._test" }, { "key" : "R002", "id" : "R002", "description" : "Read unknown resource type.", "status" : "pass", "message" : null, "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/http.html#update" ], "code" : "      test 'R002', 'Read unknown resource type.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{REST_SPEC_LINK}#update\"\n        }\n\n        reply = @client.read(Crucible::Tests::ReadTest, @id)\n        assert_response_not_found(reply)\n      end\n", "test_method" : "r002_read_unknown_resource_type._test" }, { "key" : "R003", "id" : "R003", "description" : "Read non-existing resource id.", "status" : "pass", "message" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read" ], "code" : "      test 'R003', 'Read non-existing resource id.' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        reply = @client.read(FHIR::Patient, 'Supercalifragilisticexpialidocious')\n        assert_response_not_found(reply)\n      end\n", "test_method" : "r003_read_non-existing_resource_id._test" }, { "key" : "R004", "id" : "R004", "description" : "Read invalid format resource id", "status" : "fail", "message" : "Bad response code: expected 400, but found 404", "data" : null, "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/datatypes.html#id", "http://hl7.org/fhir/DSTU2/resource.html#id" ], "code" : "      test 'R004', 'Read invalid format resource id' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/datatypes.html#id\"\n          links \"#{BASE_SPEC_LINK}/resource.html#id\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        reply = @client.read(FHIR::Patient, 'Invalid-ID-Because_Of_!@$Special_Characters_and_Length_Over_Sixty_Four_Characters')\n        assert_response_bad(reply)\n      end\n", "test_method" : "r004_read_invalid_format_resource_id_test" }, { "key" : "R005", "id" : "R005", "description" : "Read _summary=text", "status" : "fail", "message" : "Requested summary narrative was not provided.", "data" : "﻿<Patient xmlns=\"http://hl7.org/fhir\"><id value=\"9940f2415237475d8e8d62753dd1b79f\" /><meta><versionId value=\"458\" /><lastUpdated value=\"2015-10-02T22:37:24.957+00:00\" /></meta><name><family value=\"Emerald\" /><given value=\"Caro\" /></name></Patient>", "requires" : [ { "resource" : "Patient", "methods" : [ "create", "read", "delete" ] } ], "validates" : [ { "resource" : "Patient", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/datatypes.html#id", "http://hl7.org/fhir/DSTU2/resource.html#id" ], "code" : "      test 'R005', 'Read _summary=text' do\n        metadata {\n          links \"#{REST_SPEC_LINK}#read\"\n          links \"#{BASE_SPEC_LINK}/datatypes.html#id\"\n          links \"#{BASE_SPEC_LINK}/resource.html#id\"\n          requires resource: \"Patient\", methods: [\"create\", \"read\", \"delete\"]\n          validates resource: \"Patient\", methods: [\"read\"]\n        }\n\n        assert(@id, 'Setup was unable to create a patient.', @body)\n        reply = @client.read(FHIR::Patient, @id, @client.default_format, 'text')\n        assert_response_ok(reply)\n        assert(reply.try(:resource).try(:text), 'Requested summary narrative was not provided.', reply.body)\n      end      \n", "test_method" : "r005_read__summary=text_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:37:27.821-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:27.821-0400" } }
,{ "_id" : { "$oid" : "560f072f4d4d3266f89f0201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60a0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Account", "description" : "Account: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Account", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Account", "description" : "Account: Create New", "status" : "pass", "message" : "New Account was created.", "validates" : [ { "resource" : "Account", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Account", "description" : "Account: Read Existing", "status" : "skip", "message" : "Successfully read preexisting Account.", "validates" : [ { "resource" : "Account", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Account", "description" : "Account: Update Existing", "status" : "pass", "message" : "Updated existing Account.", "validates" : [ { "resource" : "Account", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Account", "description" : "Account: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Account", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Account", "description" : "Account: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Account.", "validates" : [ { "resource" : "Account", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Account", "description" : "Account: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Account.", "validates" : [ { "resource" : "Account", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Account", "description" : "Account: Validate", "status" : "pass", "message" : "Account was validated.", "validates" : [ { "resource" : "Account", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Account", "description" : "Account: Validate Existing", "status" : "pass", "message" : "Existing Account was validated.", "validates" : [ { "resource" : "Account", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Account", "description" : "Account: Validate against a profile", "status" : "pass", "message" : "Account was validated.", "validates" : [ { "resource" : "Account", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Account", "description" : "Account: Delete Existing", "status" : "pass", "message" : "Existing Account was deleted.", "validates" : [ { "resource" : "Account", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Account", "description" : "Account: Get Deleted Resource", "status" : "pass", "message" : "Deleted Account was correctly reported as gone.", "validates" : [ { "resource" : "Account", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/account.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:37:35.185-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:35.185-0400" } }
,{ "_id" : { "$oid" : "560f07364d4d3266f8a00201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60b0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_AllergyIntolerance", "description" : "AllergyIntolerance: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_AllergyIntolerance", "description" : "AllergyIntolerance: Create New", "status" : "pass", "message" : "New AllergyIntolerance was created.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_AllergyIntolerance", "description" : "AllergyIntolerance: Read Existing", "status" : "pass", "message" : "Successfully read preexisting AllergyIntolerance.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_AllergyIntolerance", "description" : "AllergyIntolerance: Update Existing", "status" : "pass", "message" : "Updated existing AllergyIntolerance.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_AllergyIntolerance", "description" : "AllergyIntolerance: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_AllergyIntolerance", "description" : "AllergyIntolerance: Version read existing", "status" : "skip", "message" : "Read current version of preexisting AllergyIntolerance.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "vread" ] }, {"extensions": ["extensions"]} ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_AllergyIntolerance", "description" : "AllergyIntolerance: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting AllergyIntolerance.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_AllergyIntolerance", "description" : "AllergyIntolerance: Validate", "status" : "pass", "message" : "AllergyIntolerance was validated.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_AllergyIntolerance", "description" : "AllergyIntolerance: Validate Existing", "status" : "pass", "message" : "Existing AllergyIntolerance was validated.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_AllergyIntolerance", "description" : "AllergyIntolerance: Validate against a profile", "status" : "pass", "message" : "AllergyIntolerance was validated.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_AllergyIntolerance", "description" : "AllergyIntolerance: Delete Existing", "status" : "pass", "message" : "Existing AllergyIntolerance was deleted.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_AllergyIntolerance", "description" : "AllergyIntolerance: Get Deleted Resource", "status" : "pass", "message" : "Deleted AllergyIntolerance was correctly reported as gone.", "validates" : [ { "resource" : "AllergyIntolerance", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/allergyintolerance.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:37:42.691-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:42.691-0400" } }
,{ "_id" : { "$oid" : "560f073e4d4d3266f8a10201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60c0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Appointment", "description" : "Appointment: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Appointment", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Appointment", "description" : "Appointment: Create New", "status" : "pass", "message" : "New Appointment was created.", "validates" : [ { "resource" : "Appointment", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Appointment", "description" : "Appointment: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Appointment.", "validates" : [ { "resource" : "Appointment", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Appointment", "description" : "Appointment: Update Existing", "status" : "pass", "message" : "Updated existing Appointment.", "validates" : [ { "resource" : "Appointment", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Appointment", "description" : "Appointment: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Appointment", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Appointment", "description" : "Appointment: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Appointment.", "validates" : [ { "resource" : "Appointment", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Appointment", "description" : "Appointment: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Appointment.", "validates" : [ { "resource" : "Appointment", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Appointment", "description" : "Appointment: Validate", "status" : "pass", "message" : "Appointment was validated.", "validates" : [ { "resource" : "Appointment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Appointment", "description" : "Appointment: Validate Existing", "status" : "pass", "message" : "Existing Appointment was validated.", "validates" : [ { "resource" : "Appointment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Appointment", "description" : "Appointment: Validate against a profile", "status" : "pass", "message" : "Appointment was validated.", "validates" : [ { "resource" : "Appointment", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Appointment", "description" : "Appointment: Delete Existing", "status" : "pass", "message" : "Existing Appointment was deleted.", "validates" : [ { "resource" : "Appointment", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Appointment", "description" : "Appointment: Get Deleted Resource", "status" : "pass", "message" : "Deleted Appointment was correctly reported as gone.", "validates" : [ { "resource" : "Appointment", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/appointment.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:37:50.242-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:50.242-0400" } }
,{ "_id" : { "$oid" : "560f07454d4d3266f8a20201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60d0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_AppointmentResponse", "description" : "AppointmentResponse: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_AppointmentResponse", "description" : "AppointmentResponse: Create New", "status" : "pass", "message" : "New AppointmentResponse was created.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_AppointmentResponse", "description" : "AppointmentResponse: Read Existing", "status" : "pass", "message" : "Successfully read preexisting AppointmentResponse.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_AppointmentResponse", "description" : "AppointmentResponse: Update Existing", "status" : "pass", "message" : "Updated existing AppointmentResponse.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_AppointmentResponse", "description" : "AppointmentResponse: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_AppointmentResponse", "description" : "AppointmentResponse: Version read existing", "status" : "error", "message" : "Read current version of preexisting AppointmentResponse.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_AppointmentResponse", "description" : "AppointmentResponse: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting AppointmentResponse.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_AppointmentResponse", "description" : "AppointmentResponse: Validate", "status" : "pass", "message" : "AppointmentResponse was validated.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_AppointmentResponse", "description" : "AppointmentResponse: Validate Existing", "status" : "pass", "message" : "Existing AppointmentResponse was validated.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_AppointmentResponse", "description" : "AppointmentResponse: Validate against a profile", "status" : "pass", "message" : "AppointmentResponse was validated.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_AppointmentResponse", "description" : "AppointmentResponse: Delete Existing", "status" : "pass", "message" : "Existing AppointmentResponse was deleted.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_AppointmentResponse", "description" : "AppointmentResponse: Get Deleted Resource", "status" : "pass", "message" : "Deleted AppointmentResponse was correctly reported as gone.", "validates" : [ { "resource" : "AppointmentResponse", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/appointmentresponse.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:37:57.257-0400" }, "created_at" : { "$date" : "2015-10-02T18:37:57.257-0400" } }
,{ "_id" : { "$oid" : "560f074e4d4d3266f8a30201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0444d4d3261a60e0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_AuditEvent", "description" : "AuditEvent: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "AuditEvent", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_AuditEvent", "description" : "AuditEvent: Create New", "status" : "pass", "message" : "New AuditEvent was created.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_AuditEvent", "description" : "AuditEvent: Read Existing", "status" : "pass", "message" : "Successfully read preexisting AuditEvent.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_AuditEvent", "description" : "AuditEvent: Update Existing", "status" : "fail", "message" : [ "error: : System AuditEvents cannot be modified" ], "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"System AuditEvents cannot be modified\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_AuditEvent", "description" : "AuditEvent: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_AuditEvent", "description" : "AuditEvent: Version read existing", "status" : "error", "message" : "Read current version of preexisting AuditEvent.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_AuditEvent", "description" : "AuditEvent: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting AuditEvent.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_AuditEvent", "description" : "AuditEvent: Validate", "status" : "pass", "message" : "AuditEvent was validated.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_AuditEvent", "description" : "AuditEvent: Validate Existing", "status" : "pass", "message" : "Existing AuditEvent was validated.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_AuditEvent", "description" : "AuditEvent: Validate against a profile", "status" : "pass", "message" : "AuditEvent was validated.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_AuditEvent", "description" : "AuditEvent: Delete Existing", "status" : "pass", "message" : "Existing AuditEvent was deleted.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_AuditEvent", "description" : "AuditEvent: Get Deleted Resource", "status" : "pass", "message" : "Deleted AuditEvent was correctly reported as gone.", "validates" : [ { "resource" : "AuditEvent", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/auditevent.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:38:06.839-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:06.839-0400" } }
,{ "_id" : { "$oid" : "560f07584d4d3266f8a40201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a60f0000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Basic", "description" : "Basic: Read Type", "status" : "pass", "message" : null, "validates" : [ { "resource" : "Basic", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Basic", "description" : "Basic: Create New", "status" : "pass", "message" : "New Basic was created.", "validates" : [ { "resource" : "Basic", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Basic", "description" : "Basic: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Basic.", "validates" : [ { "resource" : "Basic", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Basic", "description" : "Basic: Update Existing", "status" : "pass", "message" : "Updated existing Basic.", "validates" : [ { "resource" : "Basic", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Basic", "description" : "Basic: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Basic", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Basic", "description" : "Basic: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Basic.", "validates" : [ { "resource" : "Basic", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Basic", "description" : "Basic: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Basic.", "validates" : [ { "resource" : "Basic", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Basic", "description" : "Basic: Validate", "status" : "pass", "message" : "Basic was validated.", "validates" : [ { "resource" : "Basic", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Basic", "description" : "Basic: Validate Existing", "status" : "pass", "message" : "Existing Basic was validated.", "validates" : [ { "resource" : "Basic", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Basic", "description" : "Basic: Validate against a profile", "status" : "pass", "message" : "Basic was validated.", "validates" : [ { "resource" : "Basic", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Basic", "description" : "Basic: Delete Existing", "status" : "pass", "message" : "Existing Basic was deleted.", "validates" : [ { "resource" : "Basic", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Basic", "description" : "Basic: Get Deleted Resource", "status" : "pass", "message" : "Deleted Basic was correctly reported as gone.", "validates" : [ { "resource" : "Basic", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/basic.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:38:16.381-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:16.381-0400" } }
,{ "_id" : { "$oid" : "560f075f4d4d3266f8a50201" }, "has_run" : true, "test_id" : { "$oid" : "560ef0454d4d3261a6100000" }, "server_id" : { "$oid" : "560eefc34d4d326197010000" }, "result" : [ { "key" : "X000", "id" : "X000_Binary", "description" : "Binary: Read Type", "status" : "pass", "message" : "Expected FHIR Bundle but found: OperationOutcome", "data" : "﻿<OperationOutcome xmlns=\"http://hl7.org/fhir\"><issue><severity value=\"error\" /><details><coding /><text value=\"Search Operation not supported\" /></details></issue></OperationOutcome>", "validates" : [ { "resource" : "Binary", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X000', 'Read Type' do\n        metadata {\n          define_metadata('read')\n        }\n\n        reply = @client.read_feed(@resource_class)\n        @bundle = reply.resource\n        assert_bundle_response reply\n        assert !@bundle.nil?, 'Service did not respond with bundle.'\n      end\n", "test_method" : "x000_read_type_test" }, { "key" : "X010", "id" : "X010_Binary", "description" : "Binary: Create New", "status" : "pass", "message" : "New Binary was created.", "validates" : [ { "resource" : "Binary", "methods" : [ "create" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#create", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X010', 'Create New' do\n        metadata {\n          define_metadata('create')\n        }\n\n        result = TestResult.new('X010',\"Create new #{resource_class.name.demodulize}\", nil, nil, nil)\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.create @temp_resource\n        @temp_id = reply.id\n        @temp_resource.xmlId = (reply.resource.try(:xmlId) || reply.id)\n        @temp_version = reply.version\n\n        if reply.code==201\n          result.update(STATUS[:pass], \"New #{resource_class.name.demodulize} was created.\", reply.body)\n        else\n          outcome = (self.parse_operation_outcome(reply.body) rescue nil)\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n          @temp_resource = nil\n        end\n\n        result\n      end\n", "test_method" : "x010_create_new_test" }, { "key" : "X020", "id" : "X020_Binary", "description" : "Binary: Read Existing", "status" : "pass", "message" : "Successfully read preexisting Binary.", "validates" : [ { "resource" : "Binary", "methods" : [ "read" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#read", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X020', 'Read Existing' do\n        metadata {\n          define_metadata('read')\n        }\n\n        result = TestResult.new('X020',\"Read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n        else\n          raise AssertionException.new(\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        end\n\n        reply = @client.read(@resource_class, @preexisting_id)\n        @preexisting = reply.resource\n\n        if @preexisting.nil?\n          raise AssertionException.new(\"Failed to read preexisting #{resource_class.name.demodulize}: #{@preexisting_id}\", reply.body)\n        else\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n            raise AssertionException.new(\"Read preexisting #{resource_class.name.demodulize}, but it appears invalid.\", reply.response)\n          end\n        end\n\n        @preexisting_version = reply.version\n\n        result.update(STATUS[:pass], \"Successfully read preexisting #{resource_class.name.demodulize}.\", reply.response)\n        result\n      end\n", "test_method" : "x020_read_existing_test" }, { "key" : "X030", "id" : "X030_Binary", "description" : "Binary: Update Existing", "status" : "pass", "message" : "Updated existing Binary.", "validates" : [ { "resource" : "Binary", "methods" : [ "update" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#update", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X030', 'Update Existing' do\n        metadata {\n          define_metadata('update')\n        }\n\n        result = TestResult.new('X030',\"Update existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to update -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n          reply = @client.update @preexisting, @preexisting_id\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Updated existing #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code==201\n            # check created id -- see if it matches the one we used, or is new\n            resulting_id = reply.id\n\n            if(@preexisting_id != resulting_id)\n              result.update(STATUS[:fail], \"Server created (201) new #{resource_class.name.demodulize} rather than update (200). A new ID (#{resulting_id}) was also created (was #{@preexisting_id}).\", reply.body)\n            else\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server responded with the wrong code (201, but should have been 200).\", reply.body)\n            end\n\n            resulting_version = reply.version\n            if(@preexisting_version == resulting_version)\n              result.update(STATUS[:fail], \"The #{resource_class.name.demodulize} was successfully updated, but the server did not update the resource version number.\", reply.body)\n            end\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x030_update_existing_test" }, { "key" : "X040", "id" : "X040_Binary", "description" : "Binary: Read History of existing", "status" : "pass", "message" : "Service responded with bundle.", "validates" : [ { "resource" : "Binary", "methods" : [ "history" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#history", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X040', 'Read History of existing' do\n        metadata {\n          define_metadata('history')\n        }\n\n        result = TestResult.new('X040',\"Read history of existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.resource_instance_history(@resource_class, @preexisting_id)\n          @history_bundle = reply.resource\n          if @history_bundle.nil?\n            raise AssertionException.new('Service did not respond with bundle.', nil)\n          end\n          result.update(STATUS[:pass], 'Service responded with bundle.', reply.body)\n        end\n        result\n      end\n", "test_method" : "x040_read_history_of_existing_test" }, { "key" : "X050", "id" : "X050_Binary", "description" : "Binary: Version read existing", "status" : "pass", "message" : "Read current version of preexisting Binary.", "validates" : [ { "resource" : "Binary", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X050', 'Version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X050',\"Version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting_version = @temp_version\n          @preexisting = @temp_resource\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read current version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x050_version_read_existing_test" }, { "key" : "X055", "id" : "X055_Binary", "description" : "Binary: Previous version read existing", "status" : "pass", "message" : "Read previous version of preexisting Binary.", "validates" : [ { "resource" : "Binary", "methods" : [ "vread" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#vread", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X055', 'Previous version read existing' do\n        metadata {\n          define_metadata('vread')\n        }\n\n        result = TestResult.new('X055',\"Previous version read existing #{resource_class.name.demodulize} by ID\", nil, nil, nil)\n\n        if !@history_bundle.nil? && @history_bundle.total>0 && !@history_bundle.entry[0].nil? && !@history_bundle.entry[0].resource.nil?\n          @preexisting = @history_bundle.entry[0].resource\n          @preexisting_id = @preexisting.xmlId\n          @preexisting_version = nil\n          @preexisting_version = @preexisting.meta.versionId if !@preexisting.meta.nil?\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip],\"Previous version of #{resource_class.name.demodulize} unavailable.\", nil)\n        else\n          reply = @client.vread(@resource_class, @preexisting_id, @preexisting_version)\n          if reply.resource.nil?\n            raise AssertionException.new(\"Server failed to return preexisting #{resource_class.name.demodulize}.\", reply.body)\n          elsif reply.code != 200\n            raise AssertionException.new(\"Server returned preexisting #{resource_class.name.demodulize}, but responded with HTTP#{reply.code}.\", nil)\n          elsif (reply.id != @preexisting_id) and (reply.version != @preexisting_version)\n            raise AssertionException.new(\"Server did not respond with correct information in the content-location header.\", nil)\n          end\n          result.update(STATUS[:pass], \"Read previous version of preexisting #{resource_class.name.demodulize}.\", reply.body)\n        end\n        result\n      end\n", "test_method" : "x055_previous_version_read_existing_test" }, { "key" : "X060", "id" : "X060_Binary", "description" : "Binary: Validate", "status" : "fail", "message" : "Response code 400 with no OperationOutcome provided.", "data" : "{\"Message\":\"The request is invalid.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X060', 'Validate' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X060',\"Validate #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate @temp_resource\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x060_validate_test" }, { "key" : "X065", "id" : "X065_Binary", "description" : "Binary: Validate Existing", "status" : "fail", "message" : "Response code 400 with no OperationOutcome provided.", "data" : "{\"Message\":\"The request is invalid.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X065', 'Validate Existing' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        result = TestResult.new('X065',\"Validate existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        elsif !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n\n        if !@preexisting.nil?\n          begin\n            @preexisting.to_xml\n          rescue Exception\n            @preexisting = nil\n          end\n        end\n\n        if @preexisting.nil?\n          result.update(STATUS[:skip], \"Unable to validate -- existing #{resource_class.name.demodulize} is not available or was not valid.\", nil)\n        else\n          ResourceGenerator.set_fields!(@preexisting)\n\n          reply = @client.validate_existing(@preexisting, @preexisting_id)\n\n          if reply.code==200\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was validated.\", reply.body)\n          elsif reply.code==201\n            result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            if outcome.nil?\n              message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n            else\n              message = self.build_messages(outcome)\n            end\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x065_validate_existing_test" }, { "key" : "X067", "id" : "X067_Binary", "description" : "Binary: Validate against a profile", "status" : "fail", "message" : "Response code 400 with no OperationOutcome provided.", "data" : "{\"Message\":\"The request is invalid.\"}", "validates" : [ { "resource" : "Binary", "methods" : [ "validate" ] }, { "profiles" : [ "validate-profile" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#validate", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X067', 'Validate against a profile' do\n        metadata {\n          define_metadata('validate')\n          validates profiles: ['validate-profile']\n        }\n\n        profile_uri = \"http://hl7.org/fhir/StructureDefinition/#{resource_class.name.demodulize}\" # the profile to validate with\n\n        result = TestResult.new('X067',\"Validate #{resource_class.name.demodulize} against a profile\", nil, nil, nil)\n\n        @temp_resource = ResourceGenerator.generate(@resource_class,3)\n        reply = @client.validate(@temp_resource,{profile_uri: profile_uri})\n\n        if reply.code==200\n          result.update(STATUS[:pass], \"#{resource_class.name.demodulize} was validated.\", reply.body)\n        elsif reply.code==201\n          result.update(STATUS[:fail], \"Server created a #{resource_class.name.demodulize} with the ID `_validate` rather than validate the resource.\", reply.body)\n        else\n          outcome = self.parse_operation_outcome(reply.body) rescue nil\n          if outcome.nil?\n            message = \"Response code #{reply.code} with no OperationOutcome provided.\"\n          else\n            message = self.build_messages(outcome)\n          end\n          result.update(STATUS[:fail], message, reply.body)\n        end\n\n        result\n      end\n", "test_method" : "x067_validate_against_a_profile_test" }, { "key" : "X070", "id" : "X070_Binary", "description" : "Binary: Delete Existing", "status" : "pass", "message" : "Existing Binary was deleted.", "validates" : [ { "resource" : "Binary", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X070', 'Delete Existing' do\n        metadata {\n          define_metadata('delete')\n        }\n\n        @x070_success = false\n        result = TestResult.new('X070',\"Delete existing #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.destroy(@resource_class,@preexisting_id)\n          if reply.code==204\n            @x070_success = true\n            result.update(STATUS[:pass], \"Existing #{resource_class.name.demodulize} was deleted.\", reply.body)\n          elsif reply.code==405\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server does not allow deletion of #{resource_class.name.demodulize}\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==404\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server was unable to find (404 not found) the #{resource_class.name.demodulize} with the ID `#{preexisting_id}`\"\n            result.update(STATUS[:fail], message, reply.body)\n          elsif reply.code==409\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            message.unshift \"Server had a conflict try to delete the #{resource_class.name.demodulize} with the ID `#{preexisting_id}\"\n            result.update(STATUS[:fail], message, reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x070_delete_existing_test" }, { "key" : "X075", "id" : "X075_Binary", "description" : "Binary: Get Deleted Resource", "status" : "pass", "message" : "Deleted Binary was correctly reported as gone.", "validates" : [ { "resource" : "Binary", "methods" : [ "delete" ] } ], "links" : [ "http://hl7.org/fhir/DSTU2/http.html#delete", "http://hl7.org/fhir/DSTU2/binary.html" ], "code" : "      test 'X075', 'Get Deleted Resource' do\n        metadata {\n          define_metadata('delete')\n        }\n        skip unless @x070_success\n\n        result = TestResult.new('X075',\"Get Deleted #{resource_class.name.demodulize}\", nil, nil, nil)\n\n        if !@temp_resource.nil?\n          @preexisting_id = @temp_id\n          @preexisting = @temp_resource\n        end\n        if @preexisting_id.nil? && !@bundle.nil? && @bundle.total>0 && !@bundle.entry[0].nil? && !@bundle.entry[0].resource.nil?\n          @preexisting_id = @bundle.entry[0].resource.xmlId\n          @preexisting = @bundle.entry[0].resource\n        end\n\n        if @preexisting_id.nil?\n          result.update(STATUS[:skip],\"Preexisting #{resource_class.name.demodulize} unknown.\", nil)\n        else\n          reply = @client.read(@resource_class,@preexisting_id)\n          if reply.code==410\n            result.update(STATUS[:pass], \"Deleted #{resource_class.name.demodulize} was correctly reported as gone.\", reply.body)\n          else\n            outcome = self.parse_operation_outcome(reply.body) rescue nil\n            message = self.build_messages(outcome)\n            result.update(STATUS[:fail], message, reply.body)\n          end\n        end\n\n        result\n      end\n", "test_method" : "x075_get_deleted_resource_test" } ], "test_run_id" : { "$oid" : "560f068c4d4d3266f8840201" }, "updated_at" : { "$date" : "2015-10-02T18:38:23.689-0400" }, "created_at" : { "$date" : "2015-10-02T18:38:23.689-0400" } }
]
